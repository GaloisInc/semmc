////////////////////////////////////////////////////////////////////////
// Proprietary Notice
//
//     This document is protected by copyright and other related rights
// and the practice or implementation of the information contained in
// this document may be protected by one or more patents or pending
// patent applications. No part of this document may be reproduced in any
// form by any means without the express prior written permission of
// Arm. No license, express or implied, by estoppel or otherwise to
// any intellectual property rights is granted by this document unless
// specifically stated.
//
//     Your access to the information in this document is conditional upon
// your acceptance that you will not use or permit others to use the
// information for the purposes of determining whether implementations
// infringe any third party patents.
//
//     THIS DOCUMENT IS PROVIDED "AS IS". ARM PROVIDES NO REPRESENTATIONS
// AND NO WARRANTIES, EXPRESS, IMPLIED OR STATUTORY, INCLUDING, WITHOUT
// LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY
// QUALITY, NON-INFRINGEMENT OR FITNESS FOR A PARTICULAR PURPOSE WITH
// RESPECT TO THE DOCUMENT. For the avoidance of doubt, Arm makes no
// representation with respect to, and has undertaken no analysis to
// identify or understand the scope and content of, patents, copyrights,
// trade secrets, or other rights.
//
//     This document may include technical inaccuracies or typographical
// errors.
//
//     TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ARM BE
// LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT,
// INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES,
// HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT
// OF ANY USE OF THIS DOCUMENT, EVEN IF ARM HAS BEEN ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGES.
//
//     This document consists solely of commercial items. You shall be
// responsible for ensuring that any use, duplication or disclosure of
// this document complies fully with any relevant export laws and
// regulations to assure that this document or any portion thereof is not
// exported, directly or indirectly, in violation of such export
// laws. Use of the word "partner" in reference to Arm's customers is not
// intended to create or refer to any partnership relationship with any
// other company. Arm may make changes to this document at any time and
// without notice.
//
//     If any of the provisions contained in these terms conflict with
// any of the provisions of any click through or signed written agreement
// covering this document with Arm, then the click through or signed
// written agreement prevails over and supersedes the conflicting
// provisions of these terms. This document may be translated into other
// languages for convenience, and you agree that if there is any conflict
// between the English version of this document and any translation, the
// terms of the English version of the Agreement shall prevail.
//
//     The Arm corporate logo and words marked with (R) or (TM)(TM)
// are registered trademarks or trademarks of Arm Limited (or its
// subsidiaries) in the US and/or elsewhere. All rights reserved.  Other
// brands and names mentioned in this document may be the trademarks of
// their respective owners. Please follow Arm's trademark usage
// guidelines at
// http://www.arm.com/company/policies/trademarks.
//
//     Copyright (C) 2018 Arm Limited (or its affiliates). All rights reserved.
//
//     Arm Limited. Company 02557590 registered in England.
//
//     110 Fulbourn Road, Cambridge, England CB1 9NJ.
//
//     LES-PRE-20349
////////////////////////////////////////////////////////////////////////

__instruction aarch32_UHSAX_A
    __encoding aarch32_UHSAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHSAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum  = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);
        diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);
        R[d]<15:0>  = sum<16:1>;
        R[d]<31:16> = diff<16:1>;

__instruction aarch32_TSB_A
    __encoding aarch32_TSB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00010010'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if !HaveSelfHostedTrace() then EndOfInstruction(); // Instruction executes as NOP
            if cond != '1110' then UNPREDICTABLE;              // ESB must be encoded with AL condition

    __encoding aarch32_TSB_T1_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00010010'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            if !HaveSelfHostedTrace() then EndOfInstruction(); // Instruction executes as NOP
            if InITBlock() then UNPREDICTABLE;

    __execute __conditional
        TraceSynchronizationBarrier();

__instruction aarch32_VCVTB_A
    __encoding aarch32_VCVTB_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field op 16 +: 1
        __field Vd 12 +: 4
        __field sz 8 +: 1
        __field T 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x11001x xxxx101x 11x0xxxx'
        __guard cond != '1111'
        __decode
            uses_double = (sz == '1'); convert_from_half = (op == '0');
            lowbit = (if T == '1' then 16 else 0);
            if uses_double then
                if convert_from_half then
                    d = UInt(D:Vd); m = UInt(Vm:M);
                else
                    d = UInt(Vd:D); m = UInt(M:Vm);
            else
                d = UInt(Vd:D); m = UInt(Vm:M);

    __encoding aarch32_VCVTB_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 16 +: 1
        __field Vd 12 +: 4
        __field sz 8 +: 1
        __field T 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x11001x xxxx101x 11x0xxxx'
        __guard TRUE
        __decode
            uses_double = (sz == '1'); convert_from_half = (op == '0');
            lowbit = (if T == '1' then 16 else 0);
            if uses_double then
                if convert_from_half then
                    d = UInt(D:Vd); m = UInt(Vm:M);
                else
                    d = UInt(Vd:D); m = UInt(M:Vm);
            else
                d = UInt(Vd:D); m = UInt(Vm:M);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        bits(16) hp;
        if convert_from_half then
            hp = S[m]<lowbit+15:lowbit>;
            if uses_double then
                D[d] = FPConvert(hp, FPSCR);
            else
                S[d] = FPConvert(hp, FPSCR);
        else
            if uses_double then
                hp = FPConvert(D[m], FPSCR);
            else
                hp = FPConvert(S[m], FPSCR);
            S[d]<lowbit+15:lowbit> = hp;

__instruction aarch32_MRS_br_AS
    __encoding aarch32_MRS_br_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field R 22 +: 1
        __field M1 16 +: 4
        __field Rd 12 +: 4
        __field M 8 +: 1
        __opcode 'xxxx0001 0x00xxxx xxxxxx1x 0000xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            d = UInt(Rd);  read_spsr = (R == '1');
            if d == 15 then UNPREDICTABLE;
            SYSm = M:M1;

    __encoding aarch32_MRS_br_T1_AS
        __instruction_set T32
        __field R 20 +: 1
        __field M1 16 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __opcode '11110011 111xxxxx 10x0xxxx xx1xxxxx'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            d = UInt(Rd);  read_spsr = (R == '1');
            if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
            SYSm = M:M1;

    __execute __conditional
        if PSTATE.EL == EL0 then
           UNPREDICTABLE;
        else
            mode = PSTATE.M;
            if read_spsr then
                SPSRaccessValid(SYSm, mode);           // Check for UNPREDICTABLE cases
                case SYSm of
                    when '01110'  R[d] = SPSR_fiq;
                    when '10000'  R[d] = SPSR_irq;
                    when '10010'  R[d] = SPSR_svc;
                    when '10100'  R[d] = SPSR_abt;
                    when '10110'  R[d] = SPSR_und;
                    when '11100'
                        if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                        R[d] = SPSR_mon;
                    when '11110'  R[d] = SPSR_hyp;
            else
                BankedRegisterAccessValid(SYSm, mode); // Check for UNPREDICTABLE cases
                case SYSm of
                    when '00xxx'                       // Access the User mode registers
                        m = UInt(SYSm<2:0>) + 8;
                        R[d] = Rmode[m,M32_User];
                    when '01xxx'                       // Access the FIQ mode registers
                        m = UInt(SYSm<2:0>) + 8;
                        R[d] = Rmode[m,M32_FIQ];
                    when '1000x'                       // Access the IRQ mode registers
                        m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                        R[d] = Rmode[m,M32_IRQ];
                    when '1001x'                       // Access the Supervisor mode registers
                        m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                        R[d] = Rmode[m,M32_Svc];
                    when '1010x'                       // Access the Abort mode registers
                        m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                        R[d] = Rmode[m,M32_Abort];
                    when '1011x'                       // Access the Undefined mode registers
                        m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                        R[d] = Rmode[m,M32_Undef];
                    when '1110x'                       // Access Monitor registers
                        if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                        m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                        R[d] = Rmode[m,M32_Monitor];
                    when '11110'                       // Access ELR_hyp register
                        R[d] = ELR_hyp;
                    when '11111'                       // Access SP_hyp register
                        R[d] = Rmode[13,M32_Hyp];

__instruction aarch32_MRS_AS
    __encoding aarch32_MRS_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field R 22 +: 1
        __field Rd 12 +: 4
        __opcode 'xxxx0001 0x00xxxx xxxxxx0x 0000xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            d = UInt(Rd);  read_spsr = (R == '1');
            if d == 15 then UNPREDICTABLE;

    __encoding aarch32_MRS_T1_AS
        __instruction_set T32
        __field R 20 +: 1
        __field Rd 8 +: 4
        __opcode '11110011 111xxxxx 10x0xxxx xx0xxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            d = UInt(Rd);  read_spsr = (R == '1');
            if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        if read_spsr then
            if PSTATE.M IN {M32_User,M32_System} then
                UNPREDICTABLE;
            else
                R[d] = SPSR[];
        else
            // CPSR has same bit assignments as SPSR, but with the IT, J, SS, IL, and T bits masked out.
            bits(32) mask = '11111000 00001111 00000011 11011111';
            if HavePANExt() then
                mask<22> = '1';
            psr_val = GetPSRFromPSTATE() AND mask;
            if PSTATE.EL == EL0 then
                // If accessed from User mode return UNKNOWN values for E, A, I, F bits, bits<9:6>,
                // and for the M field, bits<4:0>
                psr_val<22> = bits(1) UNKNOWN;
                psr_val<9:6> = bits(4) UNKNOWN;
                psr_val<4:0> = bits(5) UNKNOWN;
            R[d] = psr_val;

__instruction aarch32_VMOVL_A
    __encoding aarch32_VMOVL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm3H 19 +: 3
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxx000 xxxx1010 00x1xxxx'
        __guard TRUE
        __decode
            if imm3H == '000' then SEE "Related encodings";
            if imm3H != '001' && imm3H != '010' && imm3H != '100' then SEE "VSHLL";
            if Vd<0> == '1' then UNDEFINED;
            esize = 8 * UInt(imm3H);
            unsigned = (U == '1');  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VMOVL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm3H 19 +: 3
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxx000 xxxx1010 00x1xxxx'
        __guard TRUE
        __decode
            if imm3H == '000' then SEE "Related encodings";
            if imm3H != '001' && imm3H != '010' && imm3H != '100' then SEE "VSHLL";
            if Vd<0> == '1' then UNDEFINED;
            esize = 8 * UInt(imm3H);
            unsigned = (U == '1');  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            result = Int(Elem[Din[m],e,esize], unsigned);
            Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_QDSUB_A
    __encoding aarch32_QDSUB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0110xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QDSUB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 1011xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);
        (R[d], sat2)  = SignedSatQ(SInt(R[m]) - SInt(doubled), 32);
        if sat1 || sat2 then
            PSTATE.Q = '1';

__instruction aarch32_LDR_i_A
    __encoding aarch32_LDR_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x0x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE "LDR (literal)";
            if P == '0' && W == '1' then SEE "LDRT";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if wback && n == t then UNPREDICTABLE;

    __encoding aarch32_LDR_i_T1_A
        __instruction_set T16
        __field imm5 22 +: 5
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '01101xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'00', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_LDR_i_T2_A
        __instruction_set T16
        __field Rt 24 +: 3
        __field imm8 16 +: 8
        __opcode '10011xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = 13;  imm32 = ZeroExtend(imm8:'00', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_LDR_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1101xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "LDR (literal)";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32); index = TRUE;  add = TRUE;
            wback = FALSE; if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_LDR_i_T4_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0101xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "LDR (literal)";
            if P == '1' && U == '1' && W == '0' then SEE "LDRT";
            if P == '0' && W == '0' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);
            imm32 = ZeroExtend(imm8, 32); index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if (wback && n == t) || (t == 15 && InITBlock() && !LastInITBlock()) then UNPREDICTABLE;

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            data = MemU[address,4];
            if wback then R[n] = offset_addr;
            if t == 15 then
                if address<1:0> == '00' then
                    LoadWritePC(data);
                else
                    UNPREDICTABLE;
            else
                R[t] = data;
        else
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            data = MemU[address,4];
            if wback then R[n] = offset_addr;
            if t == 15 then
                if address<1:0> == '00' then
                    LoadWritePC(data);
                else
                    UNPREDICTABLE;
            else
                R[t] = data;

__instruction aarch32_STLH_A
    __encoding aarch32_STLH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1110xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_STLH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1001xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        MemO[address, 2] = R[t]<15:0>;

__instruction aarch32_VRSQRTS_A
    __encoding aarch32_VRSQRTS_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x1xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRSQRTS_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x1xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = FPRSqrtStep(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize]);

__instruction aarch32_STLEXH_A
    __encoding aarch32_STLEXH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1110xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STLEXH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1101xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        if AArch32.ExclusiveMonitorsPass(address,2) then
            MemO[address, 2] = R[t]<15:0>;
            R[d] = ZeroExtend('0');
        else
            R[d] = ZeroExtend('1');

__instruction aarch32_VLDM_A
    __encoding aarch32_VLDM_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx1xxxx xxxx1011 xxxxxxx0'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VLDR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FLDM*X".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VLDM_T2A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx1xxxx xxxx1010 xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VLDR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = TRUE;  add = (U == '1');  wback = (W == '1');  d = UInt(Vd:D);  n = UInt(Rn);
            imm32 = ZeroExtend(imm8:'00', 32);  regs = UInt(imm8);
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;

    __encoding aarch32_VLDM_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx1xxxx xxxx1011 xxxxxxx0'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VLDR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FLDM*X".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VLDM_T2A2_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx1xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VLDR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = TRUE;  add = (U == '1');  wback = (W == '1');  d = UInt(Vd:D);  n = UInt(Rn);
            imm32 = ZeroExtend(imm8:'00', 32);  regs = UInt(imm8);
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;

    __execute __conditional
        CheckVFPEnabled(TRUE);
        address = if add then R[n] else R[n]-imm32;
        for r = 0 to regs-1
            if single_regs then
                S[d+r] = MemA[address,4];  address = address+4;
            else
                word1 = MemA[address,4];  word2 = MemA[address+4,4];  address = address+8;
                // Combine the word-aligned words in the correct order for current endianness.
                D[d+r] = if BigEndian() then word1:word2 else word2:word1;
        if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;

__instruction aarch32_TST_rr_A
    __encoding aarch32_TST_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0001xxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            shift_t = DecodeRegShift(type1);
            if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] AND shifted;
        PSTATE.N = result<31>;
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged

__instruction aarch32_VRINTA_asimd_A
    __encoding aarch32_VRINTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0111 1xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0111 1xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_ADC_i_A
    __encoding aarch32_ADC_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 101xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_ADC_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 010xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if d == 15 || n == 15 then UNPREDICTABLE;  // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (result, nzcv) = AddWithCarry(R[n], imm32, PSTATE.C);
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_RFE_AS
    __encoding aarch32_RFE_A1_AS
        __instruction_set A32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __opcode '1111100x x0x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            n = UInt(Rn);
            wback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_RFE_T1_AS
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __opcode '11101000 00x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            n = UInt(Rn);  wback = (W == '1');  increment = FALSE;  wordhigher = FALSE;
            if n == 15 then UNPREDICTABLE;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_RFE_T2_AS
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __opcode '11101001 10x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            n = UInt(Rn);  wback = (W == '1');  increment = TRUE;  wordhigher = FALSE;
            if n == 15 then UNPREDICTABLE;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        if PSTATE.EL == EL2 then
            UNDEFINED;
        elsif PSTATE.EL == EL0 then
            UNPREDICTABLE;                        // UNDEFINED or NOP
        else
            address = if increment then R[n] else R[n]-8;
            if wordhigher then address = address+4;
            new_pc_value = MemA[address,4];
            spsr = MemA[address+4,4];
            if wback then R[n] = if increment then R[n]+8 else R[n]-8;
            AArch32.ExceptionReturn(new_pc_value, spsr);

__instruction aarch32_VMVN_i_A
    __encoding aarch32_VMVN_i_T1A1_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx0xx0 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_i_T2A2_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx10x0 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_i_T3A3_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx110x 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_i_T1A1_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx0xx0 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_i_T2A2_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx10x0 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_i_T3A3_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx110x 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            D[d+r] = NOT(imm64);

__instruction aarch32_LDRSH_l_A
    __encoding aarch32_LDRSH_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x11111 xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "LDRSHT";
            t = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || wback then UNPREDICTABLE;

    __encoding aarch32_LDRSH_l_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111001 x0111111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE "Related instructions";
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        base = Align(PC,4);
        address = if add then (base + imm32) else (base - imm32);
        data = MemU[address,2];
        R[t] = SignExtend(data, 32);

__instruction aarch32_STREX_A
    __encoding aarch32_STREX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1000xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);  imm32 = Zeros(32); // Zero offset
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STREX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11101000 0100xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
            if d == n || d == t then UNPREDICTABLE;

    __execute __conditional
        address = R[n] + imm32;
        if AArch32.ExclusiveMonitorsPass(address,4) then
            MemA[address,4] = R[t];
            R[d] = ZeroExtend('0');
        else
            R[d] = ZeroExtend('1');

__instruction aarch32_SEVL_A
    __encoding aarch32_SEVL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000101'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_SEVL_T1_A
        __instruction_set T16
        __opcode '10111111 01010000 00000000 00000000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_SEVL_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000101'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute __conditional
        SendEventLocal();

__instruction aarch32_RSC_i_A
    __encoding aarch32_RSC_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 111xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __execute __conditional
        (result, nzcv) = AddWithCarry(NOT(R[n]), imm32, PSTATE.C);
        if d == 15 then
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VRINTA_vfp_A
    __encoding aarch32_VRINTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111001 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111001 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_VABA_A
    __encoding aarch32_VABA_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0111 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VABA_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0111 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];
                op2 = Elem[Din[m+r],e,esize];
                absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
                if long_destination then
                    Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + absdiff;
                else
                    Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + absdiff;

__instruction aarch32_VMAX_i_A
    __encoding aarch32_VMAX_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAX_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Int(Elem[D[n+r],e,esize], unsigned);
                op2 = Int(Elem[D[m+r],e,esize], unsigned);
                result = if maximum then Max(op1,op2) else Min(op1,op2);
                Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_TEQ_i_A
    __encoding aarch32_TEQ_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0011xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_TEQ_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm8 0 +: 8
        __opcode '11110x00 1001xxxx 0xxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = R[n] EOR imm32;
        PSTATE.N = result<31>;
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged

__instruction aarch32_VCVT_iv_A
    __encoding aarch32_VCVT_iv_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x11110x xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __encoding aarch32_VCVT_iv_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x11110x xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        if to_integer then
            case esize of
                when 16
                    S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
                when 32
                    S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
                when 64
                    S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);
        else
            case esize of
                when 16
                    bits(16) fp16 = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                    S[d] = Zeros(16):fp16;
                when 32
                    S[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                when 64
                    D[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_USADA8_A
    __encoding aarch32_USADA8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0111 1000xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __decode
            if Ra == '1111' then SEE "USAD8";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_USADA8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 0111xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE "USAD8";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        absdiff1 = Abs(UInt(R[n]<7:0>)   - UInt(R[m]<7:0>));
        absdiff2 = Abs(UInt(R[n]<15:8>)  - UInt(R[m]<15:8>));
        absdiff3 = Abs(UInt(R[n]<23:16>) - UInt(R[m]<23:16>));
        absdiff4 = Abs(UInt(R[n]<31:24>) - UInt(R[m]<31:24>));
        result = UInt(R[a]) + absdiff1 + absdiff2 + absdiff3 + absdiff4;
        R[d] = result<31:0>;

__instruction aarch32_LDRSBT_A
    __encoding aarch32_LDRSBT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx0000 x111xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_LDRSBT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0000 x011xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRSBT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111001 0001xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            if Rn == '1111' then SEE "LDRSB (literal)";
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = if register_form then R[m] else imm32;
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if postindex then R[n] else offset_addr;
        R[t] = SignExtend(MemU_unpriv[address,1], 32);
        if postindex then R[n] = offset_addr;

__instruction aarch32_VSEL_A
    __encoding aarch32_VSEL_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field cc 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0xxxxxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            cond = cc:(cc<1> EOR cc<0>):'0';

    __encoding aarch32_VSEL_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field cc 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0xxxxxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            cond = cc:(cc<1> EOR cc<0>):'0';

    __execute
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : (if ConditionHolds(cond) then S[n] else S[m])<15:0>;
            when 32
                S[d] = if ConditionHolds(cond) then S[n] else S[m];
            when 64
                D[d] = if ConditionHolds(cond) then D[n] else D[m];

__instruction aarch32_BL_i_A
    __encoding aarch32_BL_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm24 0 +: 24
        __opcode 'xxxx1011 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            imm32 = SignExtend(imm24:'00', 32);  targetInstrSet = InstrSet_A32;

    __encoding aarch32_BL_i_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field H 24 +: 1
        __field imm24 0 +: 24
        __opcode '1111101x xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            imm32 = SignExtend(imm24:H:'0', 32);  targetInstrSet = InstrSet_T32;

    __encoding aarch32_BL_i_T1_A
        __instruction_set T32
        __field S 26 +: 1
        __field imm10 16 +: 10
        __field J1 13 +: 1
        __field J2 11 +: 1
        __field imm11 0 +: 11
        __opcode '11110xxx xxxxxxxx 11x1xxxx xxxxxxxx'
        __guard TRUE
        __decode
            I1 = NOT(J1 EOR S);  I2 = NOT(J2 EOR S);  imm32 = SignExtend(S:I1:I2:imm10:imm11:'0', 32);
            targetInstrSet = InstrSet_T32;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_BL_i_T2_A
        __instruction_set T32
        __field S 26 +: 1
        __field imm10H 16 +: 10
        __field J1 13 +: 1
        __field J2 11 +: 1
        __field imm10L 1 +: 10
        __field H 0 +: 1
        __opcode '11110xxx xxxxxxxx 11x0xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if H == '1' then UNDEFINED;
            I1 = NOT(J1 EOR S);  I2 = NOT(J2 EOR S);  imm32 = SignExtend(S:I1:I2:imm10H:imm10L:'00', 32);
            targetInstrSet = InstrSet_A32;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        if CurrentInstrSet() == InstrSet_A32 then
            LR = PC - 4;
        else
            LR = PC<31:1> : '1';
        if targetInstrSet == InstrSet_A32 then
            targetAddress = Align(PC,4) + imm32;
        else
            targetAddress = PC + imm32;
        SelectInstrSet(targetInstrSet);
        BranchWritePC(targetAddress, BranchType_DIRCALL);

__instruction aarch32_VRSQRTE_A
    __encoding aarch32_VRSQRTE_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx010x 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            floating_point = (F == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRSQRTE_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx010x 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            floating_point = (F == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                if floating_point then
                    Elem[D[d+r],e,esize] = FPRSqrtEstimate(Elem[D[m+r],e,esize], StandardFPSCRValue());
                else
                    Elem[D[d+r],e,esize] = UnsignedRSqrtEstimate(Elem[D[m+r],e,esize]);

__instruction aarch32_SXTB_A
    __encoding aarch32_SXTB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 10101111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTB_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rd 16 +: 3
        __opcode '10110010 01xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

    __encoding aarch32_SXTB_T2_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 01001111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d] = SignExtend(rotated<7:0>, 32);

__instruction aarch32_VRSHR_A
    __encoding aarch32_VRSHR_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0010 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRSHR_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0010 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        round_const = 1 << (shift_amount - 1);
        for r = 0 to regs-1
            for e = 0 to elements-1
                result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) >> shift_amount;
                Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_SMC_AS
    __encoding aarch32_SMC_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field imm4 0 +: 4
        __opcode 'xxxx0001 0110xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // imm4 is for assembly/disassembly only and is ignored by hardware

    __encoding aarch32_SMC_T1_AS
        __instruction_set T32
        __field imm4 16 +: 4
        __opcode '11110111 1111xxxx 1000xxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            // imm4 is for assembly/disassembly only and is ignored by hardware
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        
        AArch32.CheckForSMCUndefOrTrap();
        
        if !ELUsingAArch32(EL3) then
            if SCR_EL3.SMD == '1' then
                // SMC disabled.
                UNDEFINED;
        else
            if SCR.SCD == '1' then
                // SMC disabled
                if IsSecure() then
                    // Executes either as a NOP or UNALLOCATED.
                    c = ConstrainUnpredictable(Unpredictable_SMD);
                    assert c IN {Constraint_NOP, Constraint_UNDEF};
                    if c == Constraint_NOP then EndOfInstruction();
                UNDEFINED;
        
        if !ELUsingAArch32(EL3) then
            AArch64.CallSecureMonitor(Zeros(16));
        else
            AArch32.TakeSMCException();

__instruction aarch32_VQSUB_A
    __encoding aarch32_VQSUB_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0010 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQSUB_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0010 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                diff = Int(Elem[D[n+r],e,esize], unsigned) - Int(Elem[D[m+r],e,esize], unsigned);
                (Elem[D[d+r],e,esize], sat) = SatQ(diff, esize, unsigned);
                if sat then FPSCR.QC = '1';

__instruction aarch32_VMOV_rs_A
    __encoding aarch32_VMOV_rs_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field opc1 21 +: 2
        __field Vd 16 +: 4
        __field Rt 12 +: 4
        __field D 7 +: 1
        __field opc2 5 +: 2
        __opcode 'xxxx1110 0xx0xxxx xxxx1011 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            case opc1:opc2 of
                when '1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1<0>:opc2);
                when '0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1<0>:opc2<1>);
                when '0x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1<0>);
                when '0x10'  UNDEFINED;
            d = UInt(D:Vd);  t = UInt(Rt);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMOV_rs_T1A1_A
        __instruction_set T32
        __field opc1 21 +: 2
        __field Vd 16 +: 4
        __field Rt 12 +: 4
        __field D 7 +: 1
        __field opc2 5 +: 2
        __opcode '11101110 0xx0xxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            case opc1:opc2 of
                when '1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1<0>:opc2);
                when '0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1<0>:opc2<1>);
                when '0x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1<0>);
                when '0x10'  UNDEFINED;
            d = UInt(D:Vd);  t = UInt(Rt);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        Elem[D[d],index,esize] = R[t]<esize-1:0>;

__instruction aarch32_SADD8_A
    __encoding aarch32_SADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);
        sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);
        sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);
        sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);
        R[d]<7:0>   = sum1<7:0>;
        R[d]<15:8>  = sum2<7:0>;
        R[d]<23:16> = sum3<7:0>;
        R[d]<31:24> = sum4<7:0>;
        PSTATE.GE<0>  = if sum1 >= 0 then '1' else '0';
        PSTATE.GE<1>  = if sum2 >= 0 then '1' else '0';
        PSTATE.GE<2>  = if sum3 >= 0 then '1' else '0';
        PSTATE.GE<3>  = if sum4 >= 0 then '1' else '0';

__instruction aarch32_ADR_A
    __encoding aarch32_ADR_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 10001111 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  imm32 = A32ExpandImm(imm12);  add = TRUE;

    __encoding aarch32_ADR_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 01001111 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  imm32 = A32ExpandImm(imm12);  add = FALSE;

    __encoding aarch32_ADR_T1_A
        __instruction_set T16
        __field Rd 24 +: 3
        __field imm8 16 +: 8
        __opcode '10100xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  imm32 = ZeroExtend(imm8:'00', 32);  add = TRUE;

    __encoding aarch32_ADR_T2_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 10101111 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  imm32 = ZeroExtend(i:imm3:imm8, 32);  add = FALSE;
            if d == 15 then UNPREDICTABLE;     // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_ADR_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 00001111 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  imm32 = ZeroExtend(i:imm3:imm8, 32);  add = TRUE;
            if d == 15 then UNPREDICTABLE;   // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
        if d == 15 then          // Can only occur for A32 encodings
            ALUWritePC(result);
        else
            R[d] = result;

__instruction aarch32_SBC_rr_A
    __encoding aarch32_SBC_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 110xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], NOT(shifted), PSTATE.C);
        R[d] = result;
        if setflags then
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VCGE_r_A
    __encoding aarch32_VCGE_r_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0011 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            type1 = if U == '1' then VCGEtype_unsigned else VCGEtype_signed;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGE_r_A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            type1 = VCGEtype_fp;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGE_r_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0011 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            type1 = if U == '1' then VCGEtype_unsigned else VCGEtype_signed;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGE_r_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            type1 = VCGEtype_fp;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                case type1 of
                    when VCGEtype_signed    test_passed = (SInt(op1) >= SInt(op2));
                    when VCGEtype_unsigned  test_passed = (UInt(op1) >= UInt(op2));
                    when VCGEtype_fp        test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());
                Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_VCVTB_A
    __encoding aarch32_VCVTB_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field op 16 +: 1
        __field Vd 12 +: 4
        __field sz 8 +: 1
        __field T 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x11001x xxxx101x 01x0xxxx'
        __guard cond != '1111'
        __decode
            uses_double = (sz == '1'); convert_from_half = (op == '0');
            lowbit = (if T == '1' then 16 else 0);
            if uses_double then
                if convert_from_half then
                    d = UInt(D:Vd); m = UInt(Vm:M);
                else
                    d = UInt(Vd:D); m = UInt(M:Vm);
            else
                d = UInt(Vd:D); m = UInt(Vm:M);

    __encoding aarch32_VCVTB_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 16 +: 1
        __field Vd 12 +: 4
        __field sz 8 +: 1
        __field T 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x11001x xxxx101x 01x0xxxx'
        __guard TRUE
        __decode
            uses_double = (sz == '1'); convert_from_half = (op == '0');
            lowbit = (if T == '1' then 16 else 0);
            if uses_double then
                if convert_from_half then
                    d = UInt(D:Vd); m = UInt(Vm:M);
                else
                    d = UInt(Vd:D); m = UInt(M:Vm);
            else
                d = UInt(Vd:D); m = UInt(Vm:M);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        bits(16) hp;
        if convert_from_half then
            hp = S[m]<lowbit+15:lowbit>;
            if uses_double then
                D[d] = FPConvert(hp, FPSCR);
            else
                S[d] = FPConvert(hp, FPSCR);
        else
            if uses_double then
                hp = FPConvert(D[m], FPSCR);
            else
                hp = FPConvert(S[m], FPSCR);
            S[d]<lowbit+15:lowbit> = hp;

__instruction aarch32_VQDMULH_A
    __encoding aarch32_VQDMULH_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0xxxxxxx xxxx1011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQDMULH_T2A2_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1100 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQDMULH_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0xxxxxxx xxxx1011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQDMULH_T2A2_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1100 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
        for r = 0 to regs-1
            for e = 0 to elements-1
                if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
                op1 = SInt(Elem[D[n+r],e,esize]);
                // The following only saturates if both op1 and op2 equal -(2^(esize-1))
                (result, sat) = SignedSatQ((2*op1*op2) >> esize, esize);
                Elem[D[d+r],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_STC_A
    __encoding aarch32_STC_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x x0x0xxxx 01011110 xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            n = UInt(Rn);  cp = 14;
            imm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;

    __encoding aarch32_STC_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x x0x0xxxx 01011110 xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            n = UInt(Rn);  cp = 14;
            imm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;

    __execute __conditional
        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
        address = if index then offset_addr else R[n];
        
        // System register read from DBGDTRRXint.
        MemA[address,4] = DBGDTR_EL0[];
        
        if wback then R[n] = offset_addr;

__instruction aarch32_VST4_m_A
    __encoding aarch32_VST4_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx000x xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            case type1 of
                when '0000'
                    inc = 1;
                when '0001'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx000x xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            case type1 of
                when '0000'
                    inc = 1;
                when '0001'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = TRUE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        for e = 0 to elements-1
            MemU[address,         ebytes] = Elem[D[d], e];
            MemU[address+ebytes,  ebytes] = Elem[D[d2],e];
            MemU[address+2*ebytes,ebytes] = Elem[D[d3],e];
            MemU[address+3*ebytes,ebytes] = Elem[D[d4],e];
            address = address + 4*ebytes;
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 32;

__instruction aarch32_VMOVX_A
    __encoding aarch32_VMOVX_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x110000 xxxx1010 01x0xxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            d = UInt(Vd:D); m = UInt(Vm:M);

    __encoding aarch32_VMOVX_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x110000 xxxx1010 01x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveFP16Ext() then UNDEFINED;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            d = UInt(Vd:D); m = UInt(Vm:M);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        S[d] = Zeros(16) : S[m]<31:16>;

__instruction aarch32_VPMAX_i_A
    __encoding aarch32_VPMAX_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx1010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPMAX_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx1010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        bits(64) dest;
        h = elements DIV 2;
        
        for e = 0 to h-1
            op1 = Int(Elem[D[n],2*e,esize], unsigned);
            op2 = Int(Elem[D[n],2*e+1,esize], unsigned);
            result = if maximum then Max(op1,op2) else Min(op1,op2);
            Elem[dest,e,esize] = result<esize-1:0>;
            op1 = Int(Elem[D[m],2*e,esize], unsigned);
            op2 = Int(Elem[D[m],2*e+1,esize], unsigned);
            result = if maximum then Max(op1,op2) else Min(op1,op2);
            Elem[dest,e+h,esize] = result<esize-1:0>;
        
        D[d] = dest;

__instruction aarch32_MVN_i_A
    __encoding aarch32_MVN_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 111xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  setflags = (S == '1');
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_MVN_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 011x1111 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = NOT(imm32);
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_SMLALD_A
    __encoding aarch32_SMLALD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0100xxxx xxxxxxxx 00x1xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_SMLALD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 1100xxxx xxxxxxxx 110xxxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute __conditional
        operand2 = if m_swap then ROR(R[m],16) else R[m];
        product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
        product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
        result = product1 + product2 + SInt(R[dHi]:R[dLo]);
        R[dHi] = result<63:32>;
        R[dLo] = result<31:0>;

__instruction aarch32_VBIF_A
    __encoding aarch32_VBIF_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x11xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE "VEOR";
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIF_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x11xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE "VEOR";
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            case operation of
                when VBitOps_VBIF  D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));
                when VBitOps_VBIT  D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));
                when VBitOps_VBSL  D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));

__instruction aarch32_VTBL_A
    __encoding aarch32_VTBL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field len 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xxxx xxxx10xx xxx0xxxx'
        __guard TRUE
        __decode
            is_vtbl = (op == '0');  length = UInt(len)+1;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            if n+length > 32 then UNPREDICTABLE;

    __encoding aarch32_VTBL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field len 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xxxx xxxx10xx xxx0xxxx'
        __guard TRUE
        __decode
            is_vtbl = (op == '0');  length = UInt(len)+1;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            if n+length > 32 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        
        // Create 256-bit = 32-byte table variable, with zeros in entries that will not be used.
        table3 = if length == 4 then D[n+3] else Zeros(64);
        table2 = if length >= 3 then D[n+2] else Zeros(64);
        table1 = if length >= 2 then D[n+1] else Zeros(64);
        table = table3 : table2 : table1 : D[n];
        
        for i = 0 to 7
            index = UInt(Elem[D[m],i,8]);
            if index < 8*length then
                Elem[D[d],i,8] = Elem[table,index,8];
            else
                if is_vtbl then
                    Elem[D[d],i,8] = Zeros(8);
                // else Elem[D[d],i,8] unchanged

__instruction aarch32_USAT16_A
    __encoding aarch32_USAT16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sat_imm 16 +: 4
        __field Rd 12 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0110 1110xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_USAT16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field sat_imm 0 +: 4
        __opcode '11110x11 1010xxxx 0000xxxx 00xxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
            if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (result1, sat1) = UnsignedSatQ(SInt(R[n]<15:0>), saturate_to);
        (result2, sat2) = UnsignedSatQ(SInt(R[n]<31:16>), saturate_to);
        R[d]<15:0> = ZeroExtend(result1, 16);
        R[d]<31:16> = ZeroExtend(result2, 16);
        if sat1 || sat2 then
            PSTATE.Q = '1';

__instruction aarch32_SMMUL_A
    __encoding aarch32_SMMUL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field R 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0101xxxx 1111xxxx 00x1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMMUL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field R 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0101xxxx 1111xxxx 000xxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = SInt(R[n]) * SInt(R[m]);
        if round then result = result + 0x80000000;
        R[d] = result<63:32>;

__instruction aarch32_VLD2_m_A
    __encoding aarch32_VLD2_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx100x xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align == '11' then UNDEFINED;
            if size == '11' then UNDEFINED;
            inc = if type1 == '1001' then 2 else 1;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD2_m_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  inc = 2;
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD2_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx100x xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align == '11' then UNDEFINED;
            if size == '11' then UNDEFINED;
            inc = if type1 == '1001' then 2 else 1;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD2_m_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  inc = 2;
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = FALSE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r], e] = MemU[address,ebytes];
                Elem[D[d2+r],e] = MemU[address+ebytes,ebytes];
                address = address + 2*ebytes;
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 16*regs;

__instruction aarch32_VREV16_A
    __encoding aarch32_VREV16_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0000 1xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VREV16_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0000 1xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        
        bits(64) result;
        integer element;
        integer rev_element;
        for r = 0 to regs-1
            element = 0;
            for c = 0 to containers-1
                rev_element = element + elements_per_container - 1;
                for e = 0 to elements_per_container-1
                    Elem[result, rev_element, esize] = Elem[D[m+r], element, esize];
                    element = element + 1;
                    rev_element = rev_element - 1;
            D[d+r] = result;

__instruction aarch32_UQSUB8_A
    __encoding aarch32_UQSUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQSUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);
        diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);
        diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);
        diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);
        R[d]<7:0>   = UnsignedSat(diff1, 8);
        R[d]<15:8>  = UnsignedSat(diff2, 8);
        R[d]<23:16> = UnsignedSat(diff3, 8);
        R[d]<31:24> = UnsignedSat(diff4, 8);

__instruction aarch32_VLDR_A
    __encoding aarch32_VLDR_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode 'xxxx1101 xx01xxxx xxxx10xx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);

    __encoding aarch32_VLDR_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode '11101101 xx01xxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        base = if n == 15 then Align(PC,4) else R[n];
        address = if add then (base + imm32) else (base - imm32);
        case esize of
            when 16
                S[d] = Zeros(16) : MemA[address,2];
            when 32
                S[d] = MemA[address,4];
            when 64
                word1 = MemA[address,4];  word2 = MemA[address+4,4];
                // Combine the word-aligned words in the correct order for current endianness.
                D[d] = if BigEndian() then word1:word2 else word2:word1;

__instruction aarch32_DCPS_A
    __encoding aarch32_DCPS_T1_A
        __instruction_set T32
        __field opt 0 +: 2
        __opcode '11110111 10001111 10000000 000000xx'
        __guard TRUE
        __decode
            if !Halted() || opt == '00' then UNDEFINED;

    __execute
        DCPSInstruction(opt);

__instruction aarch32_VABD_i_A
    __encoding aarch32_VABD_i_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0111 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __encoding aarch32_VABD_i_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0111 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];
                op2 = Elem[Din[m+r],e,esize];
                absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
                if long_destination then
                    Elem[Q[d>>1],e,2*esize] = absdiff<2*esize-1:0>;
                else
                    Elem[D[d+r],e,esize] = absdiff<esize-1:0>;

__instruction aarch32_VADDL_A
    __encoding aarch32_VADDL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0001 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VADDL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0001 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            if is_vaddw then
                op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
            else
                op1 = Int(Elem[Din[n],e,esize], unsigned);
            result = op1 + Int(Elem[Din[m],e,esize],unsigned);
            Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_VMLA_i_A
    __encoding aarch32_VMLA_i_T1A1_A
        __instruction_set A32
        __field op 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1001 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            add = (op == '0');  long_destination = FALSE;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_i_T1A1_A
        __instruction_set T32
        __field op 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1001 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            add = (op == '0');  long_destination = FALSE;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);
                addend = if add then product else -product;
                if long_destination then
                    Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                else
                    Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_VRINTZ_vfp_A
    __encoding aarch32_VRINTZ_vfp_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110110 xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
            exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTZ_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110110 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
            exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_BXJ_A
    __encoding aarch32_BXJ_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 0010xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            m = UInt(Rm);
            if m == 15 then UNPREDICTABLE;

    __encoding aarch32_BXJ_T1_A
        __instruction_set T32
        __field Rm 16 +: 4
        __opcode '11110011 1100xxxx 10x0xxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            m = UInt(Rm);
            if m == 15 then UNPREDICTABLE;  // Armv8-A removes UNPREDICTABLE for R13
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        BXWritePC(R[m], BranchType_INDIR);

__instruction aarch32_VQRDMLAH_A
    __encoding aarch32_VQRDMLAH_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            add = TRUE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMLAH_A2_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1110 x1x0xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            add = TRUE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQRDMLAH_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            add = TRUE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMLAH_T2_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1110 x1x0xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            add = TRUE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        CheckAdvSIMDEnabled();
        round_const = 1 << (esize-1);
        if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = SInt(Elem[D[n+r],e,esize]);
                op3 = SInt(Elem[D[d+r],e,esize]) << esize;
                if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
                (result, sat) = SignedSatQ((op3 + 2*(op1*op2) + round_const) >> esize, esize);
                Elem[D[d+r],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_VFMAL_A
    __encoding aarch32_VFMAL_A1_A
        __instruction_set A32
        __field S 23 +: 1
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111100 0x10xxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            
            integer d = UInt(D:Vd);
            integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
            integer m = if Q == '1' then UInt(M:Vm) else UInt(Vm:M);
            integer esize = 32;
            integer regs = if Q=='1' then 2 else 1;
            integer datasize = if Q=='1' then 64 else 32;
            boolean sub_op = S=='1';

    __encoding aarch32_VFMAL_T1_A
        __instruction_set T32
        __field S 23 +: 1
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111100 0x10xxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            
            integer d = UInt(D:Vd);
            integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
            integer m = if Q == '1' then UInt(M:Vm) else UInt(Vm:M);
            integer esize = 32;
            integer regs = if Q=='1' then 2 else 1;
            integer datasize = if Q=='1' then 64 else 32;
            boolean sub_op = S=='1';

    __execute
        CheckAdvSIMDEnabled();
        bits(datasize) operand1 ;
        bits(datasize) operand2 ;
        bits(64) operand3;
        bits(64) result;
        bits(esize DIV 2) element1;
        bits(esize DIV 2) element2;
        
        if Q=='0' then
            operand1 = S[n]<datasize-1:0>;
            operand2 = S[m]<datasize-1:0>;
        else
            operand1 = D[n]<datasize-1:0>;
            operand2 = D[m]<datasize-1:0>;
        for r = 0 to regs-1
            operand3 = D[d+r];
            for e = 0 to 1
                element1 = Elem[operand1, 2*r+e, esize DIV 2];
                element2 = Elem[operand2, 2*r+e, esize DIV 2];
                if sub_op then element1 = FPNeg(element1);
                Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, StandardFPSCRValue());
            D[d+r] = result;

__instruction aarch32_VDIV_A
    __encoding aarch32_VDIV_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x00xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VDIV_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x00xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPDiv(S[n]<15:0>, S[m]<15:0>, FPSCR);
            when 32
                S[d] = FPDiv(S[n], S[m], FPSCR);
            when 64
                D[d] = FPDiv(D[n], D[m], FPSCR);

__instruction aarch32_ORN_i_A
    __encoding aarch32_ORN_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 011xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "MVN (immediate)";
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = R[n] OR NOT(imm32);
        R[d] = result;
        if setflags then
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_VCNT_A
    __encoding aarch32_VCNT_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0101 0xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8;  elements = 8;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCNT_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0101 0xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8;  elements = 8;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = BitCount(Elem[D[m+r],e,esize])<esize-1:0>;

__instruction aarch32_VMLA_i_A
    __encoding aarch32_VMLA_i_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1000 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            add = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __encoding aarch32_VMLA_i_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1000 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            add = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);
                addend = if add then product else -product;
                if long_destination then
                    Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                else
                    Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_LDRSB_r_A
    __encoding aarch32_LDRSB_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x1xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if P == '0' && W == '1' then SEE "LDRSBT";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = (SRType_LSL, 0);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRSB_r_T1_A
        __instruction_set T16
        __field Rm 22 +: 3
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '0101011x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_LDRSB_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0001xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE "PLI";
            if Rn == '1111' then SEE "LDRSB (literal)";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if index then offset_addr else R[n];
        R[t] = SignExtend(MemU[address,1], 32);
        if wback then R[n] = offset_addr;

__instruction aarch32_VMOVN_A
    __encoding aarch32_VMOVN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0010 00x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VMOVN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0010 00x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            Elem[D[d],e,esize] = Elem[Qin[m>>1],e,2*esize]<esize-1:0>;

__instruction aarch32_SETPAN_A
    __encoding aarch32_SETPAN_A1_A
        __instruction_set A32
        __field imm1 9 +: 1
        __opcode '11110001 0001xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if !HavePANExt() then UNDEFINED;
            value = imm1;

    __encoding aarch32_SETPAN_T1_A
        __instruction_set T16
        __field imm1 19 +: 1
        __opcode '10110110 000xxxxx 00000000 00000000'
        __guard TRUE
        __unpredictable_unless 20 == '1'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HavePANExt() then UNDEFINED;
            value = imm1;

    __execute
        if PSTATE.EL != EL0 then
            PSTATE.PAN = value;

__instruction aarch32_VQDMLAL_A
    __encoding aarch32_VQDMLAL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1001 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMLAL_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx0011 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQDMLAL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1001 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMLAL_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx0011 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
        for e = 0 to elements-1
            if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
            op1 = SInt(Elem[Din[n],e,esize]);
            // The following only saturates if both op1 and op2 equal -(2^(esize-1))
            (product, sat1) = SignedSatQ(2*op1*op2, 2*esize);
            if add then
                result = SInt(Elem[Qin[d>>1],e,2*esize]) + SInt(product);
            else
                result = SInt(Elem[Qin[d>>1],e,2*esize]) - SInt(product);
            (Elem[Q[d>>1],e,2*esize], sat2) = SignedSatQ(result, 2*esize);
            if sat1 || sat2 then FPSCR.QC = '1';

__instruction aarch32_QDADD_A
    __encoding aarch32_QDADD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0100xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QDADD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 1001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);
        (R[d], sat2)  = SignedSatQ(SInt(R[m]) + SInt(doubled), 32);
        if sat1 || sat2 then
            PSTATE.Q = '1';

__instruction aarch32_REVSH_A
    __encoding aarch32_REVSH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1111xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  m = UInt(Rm);
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_REVSH_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rd 16 +: 3
        __opcode '10111010 11xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);

    __encoding aarch32_REVSH_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 1011xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
            if m != n || d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        bits(32) result;
        result<31:8>  = SignExtend(R[m]<7:0>, 24);
        result<7:0>   = R[m]<15:8>;
        R[d] = result;

__instruction aarch32_PLD_r_A
    __encoding aarch32_PLD_r_A1_A
        __instruction_set A32
        __field U 23 +: 1
        __field R 22 +: 1
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode '11110111 xx01xxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  add = (U == '1');  is_pldw = (R == '0');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if m == 15 || (n == 15 && is_pldw) then UNPREDICTABLE;

    __encoding aarch32_PLD_r_T1_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 00x1xxxx 11110000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "PLD (literal)";
            n = UInt(Rn);  m = UInt(Rm);  add = TRUE;  is_pldw = (W == '1');
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
        address = if add then (R[n] + offset) else (R[n] - offset);
        if is_pldw then
            Hint_PreloadDataForWrite(address);
        else
            Hint_PreloadData(address);

__instruction aarch32_VDUP_r_A
    __encoding aarch32_VDUP_r_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field B 22 +: 1
        __field Q 21 +: 1
        __field Vd 16 +: 4
        __field Rt 12 +: 4
        __field D 7 +: 1
        __field E 5 +: 1
        __opcode 'xxxx1110 1xx0xxxx xxxx1011 x0x1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            d = UInt(D:Vd);  t = UInt(Rt);  regs = if Q == '0' then 1 else 2;
            case B:E of
                when '00'  esize = 32;  elements = 2;
                when '01'  esize = 16;  elements = 4;
                when '10'  esize = 8;   elements = 8;
                when '11'  UNDEFINED;
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VDUP_r_T1A1_A
        __instruction_set T32
        __field B 22 +: 1
        __field Q 21 +: 1
        __field Vd 16 +: 4
        __field Rt 12 +: 4
        __field D 7 +: 1
        __field E 5 +: 1
        __opcode '11101110 1xx0xxxx xxxx1011 x0x1xxxx'
        __guard TRUE
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            d = UInt(D:Vd);  t = UInt(Rt);  regs = if Q == '0' then 1 else 2;
            case B:E of
                when '00'  esize = 32;  elements = 2;
                when '01'  esize = 16;  elements = 4;
                when '10'  esize = 8;   elements = 8;
                when '11'  UNDEFINED;
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        CheckAdvSIMDEnabled();
        scalar = R[t]<esize-1:0>;
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = scalar;

__instruction aarch32_EOR_r_A
    __encoding aarch32_EOR_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 001xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_EOR_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rdn 16 +: 3
        __opcode '01000000 01xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_EOR_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 100xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE "TEQ (register)";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] EOR shifted;
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_CRC32_A
    __encoding aarch32_CRC32_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sz 21 +: 2
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field C 9 +: 1
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0xx0xxxx xxxxxx1x 0100xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if ! HaveCRCExt() then UNDEFINED;
            d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
            size = 8 << UInt(sz);
            crc32c = (C == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if size == 64 then UNPREDICTABLE;
            if cond != '1110' then UNPREDICTABLE;

    __encoding aarch32_CRC32_T1_A
        __instruction_set T32
        __field C 20 +: 1
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field sz 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 10xxxxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if ! HaveCRCExt() then UNDEFINED;
            d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
            size = 8 << UInt(sz);
            crc32c = (C == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if size == 64 then UNPREDICTABLE;

    __execute __conditional
        
        acc = R[n];             // accumulator
        val = R[m]<size-1:0>;   // input value
        poly = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;
        tempacc = BitReverse(acc):Zeros(size);
        tempval = BitReverse(val):Zeros(32);
        // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
        R[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));

__instruction aarch32_VQSHL_i_A
    __encoding aarch32_VQSHL_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx011x xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQSHL_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx011x xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                operand = Int(Elem[D[m+r],e,esize], src_unsigned);
                (result, sat) = SatQ(operand << shift_amount, esize, dest_unsigned);
                Elem[D[d+r],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_VCMLA_idx_A
    __encoding aarch32_VCMLA_idx_A1_A
        __instruction_set A32
        __field S 23 +: 1
        __field D 22 +: 1
        __field rot 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 xxxxxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveFCADDExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn);
            m = if S=='1' then UInt(M:Vm) else UInt(Vm);
            esize = 16 << UInt(S);
            if !HaveFP16Ext() && esize == 16 then UNDEFINED;
            elements = 64 DIV esize;
            regs = if Q == '0' then 1 else 2;
            index = if S=='1' then 0 else UInt(M);

    __encoding aarch32_VCMLA_idx_T1_A
        __instruction_set T32
        __field S 23 +: 1
        __field D 22 +: 1
        __field rot 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 xxxxxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveFCADDExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn);
            m = if S=='1' then UInt(M:Vm) else UInt(Vm);
            esize = 16 << UInt(S);
            if !HaveFP16Ext() && esize == 16 then UNDEFINED;
            elements = 64 DIV esize;
            regs = if Q == '0' then 1 else 2;
            index = if S=='1' then 0 else UInt(M);

    __execute
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            operand1 = D[n+r];
            operand2 = Din[m];
            operand3 = D[d+r];
            for e = 0 to (elements DIV 2)-1
                case rot of
                    when '00'
                        element1 = Elem[operand2,index*2,esize];
                        element2 = Elem[operand1,e*2,esize];
                        element3 = Elem[operand2,index*2+1,esize];
                        element4 = Elem[operand1,e*2,esize];
                    when '01'
                        element1 = FPNeg(Elem[operand2,index*2+1,esize]);
                        element2 = Elem[operand1,e*2+1,esize];
                        element3 = Elem[operand2,index*2,esize];
                        element4 = Elem[operand1,e*2+1,esize];
                    when '10'
                        element1 = FPNeg(Elem[operand2,index*2,esize]);
                        element2 = Elem[operand1,e*2,esize];
                        element3 = FPNeg(Elem[operand2,index*2+1,esize]);
                        element4 = Elem[operand1,e*2,esize];
                    when '11'
                        element1 = Elem[operand2,index*2+1,esize];
                        element2 = Elem[operand1,e*2+1,esize];
                        element3 = FPNeg(Elem[operand2,index*2,esize]);
                        element4 = Elem[operand1,e*2+1,esize];
                result1 = FPMulAdd(Elem[operand3,e*2,esize],element2,element1, StandardFPSCRValue());
                result2 = FPMulAdd(Elem[operand3,e*2+1,esize],element4,element3,StandardFPSCRValue());
                Elem[D[d+r],e*2,esize] = result1;
                Elem[D[d+r],e*2+1,esize] = result2;

__instruction aarch32_VSUB_i_A
    __encoding aarch32_VSUB_i_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSUB_i_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = Elem[D[n+r],e,esize] - Elem[D[m+r],e,esize];

__instruction aarch32_VEOR_A
    __encoding aarch32_VEOR_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x00xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VEOR_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x00xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            D[d+r] = D[n+r] EOR D[m+r];

__instruction aarch32_VBIF_A
    __encoding aarch32_VBIF_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x10xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE "VEOR";
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIF_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x10xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE "VEOR";
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            case operation of
                when VBitOps_VBIF  D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));
                when VBitOps_VBIT  D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));
                when VBitOps_VBSL  D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));

__instruction aarch32_STR_i_A
    __encoding aarch32_STR_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x0x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "STRT";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STR_i_T1_A
        __instruction_set T16
        __field imm5 22 +: 5
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '01100xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'00', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_STR_i_T2_A
        __instruction_set T16
        __field Rt 24 +: 3
        __field imm8 16 +: 8
        __opcode '10010xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = 13;  imm32 = ZeroExtend(imm8:'00', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_STR_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1100xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            if t == 15 then UNPREDICTABLE;

    __encoding aarch32_STR_i_T4_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0100xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '1' && U == '1' && W == '0' then SEE "STRT";
            if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE;

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            MemU[address,4] = if t == 15 then PCStoreValue() else R[t];
            if wback then R[n] = offset_addr;
        else
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            MemU[address,4] = R[t];
            if wback then R[n] = offset_addr;

__instruction aarch32_ISB_A
    __encoding aarch32_ISB_A1_A
        __instruction_set A32
        __field option 0 +: 4
        __opcode '11110101 0111xxxx xxxxxxxx 0110xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_ISB_T1_A
        __instruction_set T32
        __field option 0 +: 4
        __opcode '11110011 1011xxxx 10x0xxxx 0110xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            // No additional decoding required

    __execute __conditional
        InstructionSynchronizationBarrier();

__instruction aarch32_VCGT_i_A
    __encoding aarch32_VCGT_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x00 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGT_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x00 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                if floating_point then
                    bits(esize) zero = FPZero('0');
                    test_passed = FPCompareGT(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());
                else
                    test_passed = (SInt(Elem[D[m+r],e,esize]) > 0);
                Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_VDOT_A
    __encoding aarch32_VDOT_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field U 4 +: 1
        __field Vm 0 +: 4
        __opcode '11111100 0x10xxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveDOTPExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            boolean signed = U=='0';
            integer d = UInt(D:Vd);
            integer n = UInt(N:Vn);
            integer m = UInt(M:Vm);
            integer esize = 32;
            integer regs = if Q == '1' then 2 else 1;

    __encoding aarch32_VDOT_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field U 4 +: 1
        __field Vm 0 +: 4
        __opcode '11111100 0x10xxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveDOTPExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            boolean signed = U=='0';
            integer d = UInt(D:Vd);
            integer n = UInt(N:Vn);
            integer m = UInt(M:Vm);
            integer esize = 32;
            integer regs = if Q == '1' then 2 else 1;

    __execute
        bits(64) operand1;
        bits(64) operand2;
        bits(64) result;
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            operand1 = D[n+r];
            operand2 = D[m+r];
            result = D[d+r];
            integer element1, element2;
            for e = 0 to 1
                integer res = 0;
                for i = 0 to 3
                    if signed then
                        element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                        element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);
                    else
                        element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                        element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);
                    res = res + element1 * element2;
                Elem[result, e, esize] = Elem[result, e, esize] + res;
            D[d+r] = result;

__instruction aarch32_UHADD8_A
    __encoding aarch32_UHADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);
        sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);
        sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);
        sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);
        R[d]<7:0>   = sum1<8:1>;
        R[d]<15:8>  = sum2<8:1>;
        R[d]<23:16> = sum3<8:1>;
        R[d]<31:24> = sum4<8:1>;

__instruction aarch32_VSUBHN_A
    __encoding aarch32_VSUBHN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx0110 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VSUBHN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx0110 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            result = Elem[Qin[n>>1],e,2*esize] - Elem[Qin[m>>1],e,2*esize];
            Elem[D[d],e,esize] = result<2*esize-1:esize>;

__instruction aarch32_VMOV_d_A
    __encoding aarch32_VMOV_d_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field op 20 +: 1
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1100 010xxxxx xxxx1011 00x1xxxx'
        __guard cond != '1111'
        __decode
            to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(M:Vm);
            if t == 15 || t2 == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
            if to_arm_registers && t == t2 then UNPREDICTABLE;

    __encoding aarch32_VMOV_d_T1A1_A
        __instruction_set T32
        __field op 20 +: 1
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101100 010xxxxx xxxx1011 00x1xxxx'
        __guard TRUE
        __decode
            to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(M:Vm);
            if t == 15 || t2 == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
            if to_arm_registers && t == t2 then UNPREDICTABLE;

    __execute __conditional
        CheckVFPEnabled(TRUE);
        if to_arm_registers then
            R[t] = D[m]<31:0>;
            R[t2] = D[m]<63:32>;
        else
            D[m]<31:0> = R[t];
            D[m]<63:32> = R[t2];

__instruction aarch32_MCRR_A
    __encoding aarch32_MCRR_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc1 4 +: 4
        __field CRm 0 +: 4
        __opcode 'xxxx1100 0100xxxx xxxx111x xxxxxxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15 || t2 == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_MCRR_T1A1_A
        __instruction_set T32
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc1 4 +: 4
        __field CRm 0 +: 4
        __opcode '11101100 0100xxxx xxxx111x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15 || t2 == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        value = R[t2]:R[t];
        AArch32.SysRegWrite64(cp, ThisInstr(), value);

__instruction aarch32_QADD16_A
    __encoding aarch32_QADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);
        sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);
        R[d]<15:0>  = SignedSat(sum1, 16);
        R[d]<31:16> = SignedSat(sum2, 16);

__instruction aarch32_VMOV_s_A
    __encoding aarch32_VMOV_s_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field op 20 +: 1
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __opcode 'xxxx1110 000xxxxx xxxx1010 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMOV_s_T1_A
        __instruction_set T32
        __field op 20 +: 1
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __opcode '11101110 000xxxxx xxxx1010 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        CheckVFPEnabled(TRUE);
        if to_arm_register then
            R[t] = S[n];
        else
            S[n] = R[t];

__instruction aarch32_LDREX_A
    __encoding aarch32_LDREX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1001xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = Zeros(32); // Zero offset
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDREX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11101000 0101xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            if t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        address = R[n] + imm32;
        AArch32.SetExclusiveMonitors(address,4);
        R[t] = MemA[address,4];

__instruction aarch32_VLDR_A
    __encoding aarch32_VLDR_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode 'xxxx1101 xx011111 xxxx10xx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);

    __encoding aarch32_VLDR_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode '11101101 xx011111 xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        base = if n == 15 then Align(PC,4) else R[n];
        address = if add then (base + imm32) else (base - imm32);
        case esize of
            when 16
                S[d] = Zeros(16) : MemA[address,2];
            when 32
                S[d] = MemA[address,4];
            when 64
                word1 = MemA[address,4];  word2 = MemA[address+4,4];
                // Combine the word-aligned words in the correct order for current endianness.
                D[d] = if BigEndian() then word1:word2 else word2:word1;

__instruction aarch32_VMOV_r_A
    __encoding aarch32_VMOV_r_T2A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110000 xxxx101x 01x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            single_register = (size == '10');  advsimd = FALSE;
            if single_register then
                d = UInt(Vd:D);  m = UInt(Vm:M);
            else
                d = UInt(D:Vd);  m = UInt(M:Vm);  regs = 1;

    __encoding aarch32_VMOV_r_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110000 xxxx101x 01x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            single_register = (size == '10');  advsimd = FALSE;
            if single_register then
                d = UInt(Vd:D);  m = UInt(Vm:M);
            else
                d = UInt(D:Vd);  m = UInt(M:Vm);  regs = 1;

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if single_register then
            S[d] = S[m];
        else
            for r = 0 to regs-1
                D[d+r] = D[m+r];

__instruction aarch32_AND_i_A
    __encoding aarch32_AND_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 000xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_AND_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 000xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE "TST (immediate)";
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = R[n] AND imm32;
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_VLDM_A
    __encoding aarch32_VLDM_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx1xxxx xxxx1011 xxxxxxx1'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VLDR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FLDM*X".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VLDM_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx1xxxx xxxx1011 xxxxxxx1'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VLDR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FLDM*X".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __execute __conditional
        CheckVFPEnabled(TRUE);
        address = if add then R[n] else R[n]-imm32;
        for r = 0 to regs-1
            if single_regs then
                S[d+r] = MemA[address,4];  address = address+4;
            else
                word1 = MemA[address,4];  word2 = MemA[address+4,4];  address = address+8;
                // Combine the word-aligned words in the correct order for current endianness.
                D[d+r] = if BigEndian() then word1:word2 else word2:word1;
        if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;

__instruction aarch32_VQRDMULH_A
    __encoding aarch32_VQRDMULH_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMULH_T2A2_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1101 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQRDMULH_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMULH_T2A2_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1101 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        round_const = 1 << (esize-1);
        if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = SInt(Elem[D[n+r],e,esize]);
                if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
                (result, sat) = SignedSatQ((2*op1*op2 + round_const) >> esize, esize);
                Elem[D[d+r],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_USAX_A
    __encoding aarch32_USAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_USAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum  = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);
        diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);
        R[d]<15:0>  = sum<15:0>;
        R[d]<31:16> = diff<15:0>;
        PSTATE.GE<1:0> = if sum  >= 0x10000 then '11' else '00';
        PSTATE.GE<3:2> = if diff >= 0 then '11' else '00';

__instruction aarch32_VMAX_f_A
    __encoding aarch32_VMAX_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x1xxxxx xxxx1111 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAX_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x1xxxxx xxxx1111 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                if maximum then
                    Elem[D[d+r],e,esize] = FPMax(op1, op2, StandardFPSCRValue());
                else
                    Elem[D[d+r],e,esize] = FPMin(op1, op2, StandardFPSCRValue());

__instruction aarch32_VBIC_r_A
    __encoding aarch32_VBIC_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x01xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIC_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x01xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            D[d+r] = D[n+r] AND NOT(D[m+r]);

__instruction aarch32_ADD_rr_A
    __encoding aarch32_ADD_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 100xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], shifted, '0');
        R[d] = result;
        if setflags then
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_DBG_A
    __encoding aarch32_DBG_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field option 0 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // DBG executes as a NOP. The 'option' field is ignored

    __encoding aarch32_DBG_T1_A
        __instruction_set T32
        __field option 0 +: 4
        __opcode '11110011 1010xxxx 10x0x000 1111xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // DBG executes as a NOP. The 'option' field is ignored

    __execute __conditional

__instruction aarch32_VQADD_A
    __encoding aarch32_VQADD_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQADD_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                sum = Int(Elem[D[n+r],e,esize], unsigned) + Int(Elem[D[m+r],e,esize], unsigned);
                (Elem[D[d+r],e,esize], sat) = SatQ(sum, esize, unsigned);
                if sat then FPSCR.QC = '1';

__instruction aarch32_MRC_A
    __encoding aarch32_MRC_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field opc1 21 +: 3
        __field CRn 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc2 5 +: 3
        __field CRm 0 +: 4
        __opcode 'xxxx1110 xxx1xxxx xxxx111x xxx1xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  cp = if coproc<0> == '0' then 14 else 15;
            // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_MRC_T1A1_A
        __instruction_set T32
        __field opc1 21 +: 3
        __field CRn 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc2 5 +: 3
        __field CRm 0 +: 4
        __opcode '11101110 xxx1xxxx xxxx111x xxx1xxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  cp = if coproc<0> == '0' then 14 else 15;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        bits(32) value = AArch32.SysRegRead(cp, ThisInstr());
        if t != 15 then
            R[t] = value;
        elsif AArch32.SysRegReadCanWriteAPSR(cp, ThisInstr()) then
            PSTATE.<N,Z,C,V> = value<31:28>;
            // value<27:0> are not used.
        else
            PSTATE.<N,Z,C,V> = bits(4) UNKNOWN;

__instruction aarch32_VBIF_A
    __encoding aarch32_VBIF_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x01xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE "VEOR";
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIF_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x01xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE "VEOR";
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            case operation of
                when VBitOps_VBIF  D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));
                when VBitOps_VBIT  D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));
                when VBitOps_VBSL  D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));

__instruction aarch32_VDUP_s_A
    __encoding aarch32_VDUP_s_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm4 16 +: 4
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xxxx xxxx1100 0xx0xxxx'
        __guard TRUE
        __decode
            if imm4 == 'x000' then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            case imm4 of
                when 'xxx1'  esize = 8;  elements = 8;  index = UInt(imm4<3:1>);
                when 'xx10'  esize = 16;  elements = 4;  index = UInt(imm4<3:2>);
                when 'x100'  esize = 32;  elements = 2;  index = UInt(imm4<3>);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VDUP_s_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm4 16 +: 4
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xxxx xxxx1100 0xx0xxxx'
        __guard TRUE
        __decode
            if imm4 == 'x000' then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            case imm4 of
                when 'xxx1'  esize = 8;  elements = 8;  index = UInt(imm4<3:1>);
                when 'xx10'  esize = 16;  elements = 4;  index = UInt(imm4<3:2>);
                when 'x100'  esize = 32;  elements = 2;  index = UInt(imm4<3>);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        scalar = Elem[D[m],index,esize];
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = scalar;

__instruction aarch32_YIELD_A
    __encoding aarch32_YIELD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000001'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_YIELD_T1_A
        __instruction_set T16
        __opcode '10111111 00010000 00000000 00000000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_YIELD_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000001'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute __conditional
        Hint_Yield();

__instruction aarch32_CPS_AS
    __encoding aarch32_CPS_A1_AS
        __instruction_set A32
        __field imod 18 +: 2
        __field M 17 +: 1
        __field A 8 +: 1
        __field I 7 +: 1
        __field F 6 +: 1
        __field mode 0 +: 5
        __opcode '11110001 0000xxx0 xxxxxxxx xx0xxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __decode
            if mode != '00000' && M == '0' then UNPREDICTABLE;
            if (imod<1> == '1' && A:I:F == '000') || (imod<1> == '0' && A:I:F != '000') then UNPREDICTABLE;
            enable = (imod == '10');  disable = (imod == '11');  changemode = (M == '1');
            affectA = (A == '1');  affectI = (I == '1');  affectF = (F == '1');
            if (imod == '00' && M == '0') || imod == '01' then UNPREDICTABLE;

    __encoding aarch32_CPS_T1_AS
        __instruction_set T16
        __field im 20 +: 1
        __field A 18 +: 1
        __field I 17 +: 1
        __field F 16 +: 1
        __opcode '10110110 011xxxxx 00000000 00000000'
        __guard TRUE
        __unpredictable_unless 19 == '0'
        __decode
            if A:I:F == '000' then UNPREDICTABLE;
            enable = (im == '0');  disable = (im == '1');  changemode = FALSE;
            affectA = (A == '1');  affectI = (I == '1');  affectF = (F == '1');
            if InITBlock() then UNPREDICTABLE;

    __encoding aarch32_CPS_T2_AS
        __instruction_set T32
        __field imod 9 +: 2
        __field M 8 +: 1
        __field A 7 +: 1
        __field I 6 +: 1
        __field F 5 +: 1
        __field mode 0 +: 5
        __opcode '11110011 1010xxxx 10x0xxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            if imod == '00' && M == '0' then SEE "Hint instructions";
            if mode != '00000' && M == '0' then UNPREDICTABLE;
            if (imod<1> == '1' && A:I:F == '000') || (imod<1> == '0' && A:I:F != '000') then UNPREDICTABLE;
            enable = (imod == '10');  disable = (imod == '11');  changemode = (M == '1');
            affectA = (A == '1');  affectI = (I == '1');  affectF = (F == '1');
            if imod == '01' || InITBlock() then UNPREDICTABLE;

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if PSTATE.EL != EL0 then
                if enable then
                    if affectA then PSTATE.A = '0';
                    if affectI then PSTATE.I = '0';
                    if affectF then PSTATE.F = '0';
                if disable then
                    if affectA then PSTATE.A = '1';
                    if affectI then PSTATE.I = '1';
                    if affectF then PSTATE.F = '1';
                if changemode then
                    // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
                    AArch32.WriteModeByInstr(mode);
        else
            if PSTATE.EL != EL0 then
                if enable then
                    if affectA then PSTATE.A = '0';
                    if affectI then PSTATE.I = '0';
                    if affectF then PSTATE.F = '0';
                if disable then
                    if affectA then PSTATE.A = '1';
                    if affectI then PSTATE.I = '1';
                    if affectF then PSTATE.F = '1';
                if changemode then
                    // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
                    AArch32.WriteModeByInstr(mode);

__instruction aarch32_VQDMULL_A
    __encoding aarch32_VQDMULL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1101 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMULL_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1011 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQDMULL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1101 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMULL_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1011 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
        for e = 0 to elements-1
            if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
            op1 = SInt(Elem[Din[n],e,esize]);
            // The following only saturates if both op1 and op2 equal -(2^(esize-1))
            (product, sat) = SignedSatQ(2*op1*op2, 2*esize);
            Elem[Q[d>>1],e,2*esize] = product;
            if sat then FPSCR.QC = '1';

__instruction aarch32_VQSHRN_A
    __encoding aarch32_VQSHRN_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx100x 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then SEE "VSHRN";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VQSHRN_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx100x 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then SEE "VSHRN";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
            (result, sat) = SatQ(operand >> shift_amount, esize, dest_unsigned);
            Elem[D[d],e,esize] = result;
            if sat then FPSCR.QC = '1';

__instruction aarch32_VLD4_m_A
    __encoding aarch32_VLD4_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx000x xxxxxxxx'
        __guard TRUE
        __decode
            case type1 of
                when '0000'
                    inc = 1;
                when '0001'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx000x xxxxxxxx'
        __guard TRUE
        __decode
            case type1 of
                when '0000'
                    inc = 1;
                when '0001'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = FALSE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        for e = 0 to elements-1
            Elem[D[d], e] = MemU[address,ebytes];
            Elem[D[d2],e] = MemU[address+ebytes,ebytes];
            Elem[D[d3],e] = MemU[address+2*ebytes,ebytes];
            Elem[D[d4],e] = MemU[address+3*ebytes,ebytes];
            address = address + 4*ebytes;
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 32;

__instruction aarch32_VPMAX_f_A
    __encoding aarch32_VPMAX_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x1xxxxx xxxx1111 x0x0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPMAX_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x1xxxxx xxxx1111 x0x0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        bits(64) dest;
        h = elements DIV 2;
        
        for e = 0 to h-1
            op1 = Elem[D[n],2*e,esize];  op2 = Elem[D[n],2*e+1,esize];
            Elem[dest,e,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());
            op1 = Elem[D[m],2*e,esize];  op2 = Elem[D[m],2*e+1,esize];
            Elem[dest,e+h,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());
        
        D[d] = dest;

__instruction aarch32_HLT_A
    __encoding aarch32_HLT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm12 8 +: 12
        __field imm4 0 +: 4
        __opcode 'xxxx0001 0000xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __decode
            if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;
            if cond != '1110' then UNPREDICTABLE; // HLT must be encoded with AL condition

    __encoding aarch32_HLT_T1_A
        __instruction_set T16
        __field imm6 16 +: 6
        __opcode '10111010 10xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;

    __execute
        Halt(DebugHalt_HaltInstruction);

__instruction aarch32_BX_A
    __encoding aarch32_BX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            m = UInt(Rm);

    __encoding aarch32_BX_T1_A
        __instruction_set T16
        __field Rm 19 +: 4
        __opcode '01000111 0xxxxxxx 00000000 00000000'
        __guard TRUE
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            m = UInt(Rm);
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        BXWritePC(R[m], BranchType_INDIR);

__instruction aarch32_VMOV_ss_A
    __encoding aarch32_VMOV_ss_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field op 20 +: 1
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1100 010xxxxx xxxx1010 00x1xxxx'
        __guard cond != '1111'
        __decode
            to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(Vm:M);
            if t == 15 || t2 == 15 || m == 31 then UNPREDICTABLE;
            if to_arm_registers && t == t2 then UNPREDICTABLE;

    __encoding aarch32_VMOV_ss_T1A1_A
        __instruction_set T32
        __field op 20 +: 1
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101100 010xxxxx xxxx1010 00x1xxxx'
        __guard TRUE
        __decode
            to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(Vm:M);
            if t == 15 || t2 == 15 || m == 31 then UNPREDICTABLE;
            if to_arm_registers && t == t2 then UNPREDICTABLE;

    __execute __conditional
        CheckVFPEnabled(TRUE);
        if to_arm_registers then
            R[t] = S[m];
            R[t2] = S[m+1];
        else
            S[m] = R[t];
            S[m+1] = R[t2];

__instruction aarch32_VSUBL_A
    __encoding aarch32_VSUBL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VSUBL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            if is_vsubw then
                op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
            else
                op1 = Int(Elem[Din[n],e,esize], unsigned);
            result = op1 - Int(Elem[Din[m],e,esize], unsigned);
            Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_CBNZ_A
    __encoding aarch32_CBNZ_T1_A
        __instruction_set T16
        __field op 27 +: 1
        __field i 25 +: 1
        __field imm5 19 +: 5
        __field Rn 16 +: 3
        __opcode '1011x0x1 xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            n = UInt(Rn);  imm32 = ZeroExtend(i:imm5:'0', 32);  nonzero = (op == '1');
            if InITBlock() then UNPREDICTABLE;

    __execute
        if nonzero != IsZero(R[n]) then
            BranchWritePC(PC + imm32, BranchType_DIR);

__instruction aarch32_LDR_l_A
    __encoding aarch32_LDR_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x0x11111 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "LDRT";
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);
            add = (U == '1');  wback = (P == '0') || (W == '1');
            if wback then UNPREDICTABLE;

    __encoding aarch32_LDR_l_T1_A
        __instruction_set T16
        __field Rt 24 +: 3
        __field imm8 16 +: 8
        __opcode '01001xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  imm32 = ZeroExtend(imm8:'00', 32);  add = TRUE;

    __encoding aarch32_LDR_l_T2_A
        __instruction_set T32
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 x1011111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
            if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        base = Align(PC,4);
        address = if add then (base + imm32) else (base - imm32);
        data = MemU[address,4];
        if t == 15 then
            if address<1:0> == '00' then
                LoadWritePC(data);
            else
                UNPREDICTABLE;
        else
            R[t] = data;

__instruction aarch32_ADD_SP_r_A
    __encoding aarch32_ADD_SP_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 100x1101 xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_ADD_SP_r_T1_A
        __instruction_set T16
        __field DM 23 +: 1
        __field Rdm 16 +: 3
        __opcode '01000100 x1101xxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(DM:Rdm);  m = UInt(DM:Rdm);  setflags = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);
            if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_ADD_SP_r_T2_A
        __instruction_set T16
        __field Rm 19 +: 4
        __opcode '01000100 1xxxx101 00000000 00000000'
        __guard TRUE
        __decode
            if Rm == '1101' then SEE "encoding T1";
            d = 13;  m = UInt(Rm);  setflags = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_ADD_SP_r_T3_A
        __instruction_set T32
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 000x1101 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE "CMN (register)";
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(SP, shifted, '0');
        if d == 15 then
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SHA256SU1_A
    __encoding aarch32_SHA256SU1_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x10xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSHA256Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA256SU1_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x10xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveSHA256Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        bits(128) result;
        X = Q[d>>1]; Y = Q[n>>1]; Z = Q[m>>1];
        T0 = Z<31:0> : Y<127:32>;
        
        T1 = Z<127:64>;
        for e = 0 to 1
            elt = Elem[T1, e, 32];
            elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
            elt = elt + Elem[X, e, 32] + Elem[T0, e, 32];
            Elem[result, e, 32] = elt;
        
        T1 = result<63:0>;
        for e = 2 to 3
            elt = Elem[T1, e - 2, 32];
            elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
            elt = elt + Elem[X, e, 32] + Elem[T0, e, 32];
            Elem[result, e, 32] = elt;
        
        Q[d>>1] = result;

__instruction aarch32_VRINTA_asimd_A
    __encoding aarch32_VRINTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0100 0xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0100 0xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_VST2_m_A
    __encoding aarch32_VST2_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx100x xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align == '11' then UNDEFINED;
            if size == '11' then UNDEFINED;
            inc = if type1 == '1001' then 2 else 1;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST2_m_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  inc = 2;
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST2_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx100x xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align == '11' then UNDEFINED;
            if size == '11' then UNDEFINED;
            inc = if type1 == '1001' then 2 else 1;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST2_m_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  inc = 2;
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = TRUE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        for r = 0 to regs-1
            for e = 0 to elements-1
                MemU[address,       ebytes] = Elem[D[d+r], e];
                MemU[address+ebytes,ebytes] = Elem[D[d2+r],e];
                address = address + 2*ebytes;
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 16*regs;

__instruction aarch32_AESD_A
    __encoding aarch32_AESD_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0011 01x0xxxx'
        __guard TRUE
        __decode
            if !HaveAESExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_AESD_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0011 01x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveAESExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        op1 = Q[d>>1]; op2 = Q[m>>1];
        Q[d>>1] = AESInvSubBytes(AESInvShiftRows(op1 EOR op2));

__instruction aarch32_SUB_i_A
    __encoding aarch32_SUB_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 010xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' && S == '0' then SEE "ADR";
            if Rn == '1101' then SEE "SUB (SP minus immediate)";
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_SUB_i_T1_A
        __instruction_set T16
        __field imm3 22 +: 3
        __field Rn 19 +: 3
        __field Rd 16 +: 3
        __opcode '0001111x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm3, 32);

    __encoding aarch32_SUB_i_T2_A
        __instruction_set T16
        __field Rdn 24 +: 3
        __field imm8 16 +: 8
        __opcode '00111xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm8, 32);

    __encoding aarch32_SUB_i_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 101xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE "CMP (immediate)";
            if Rn == '1101' then SEE "SUB (SP minus immediate)";
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_SUB_i_T4_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 1010xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "ADR";
            if Rn == '1101' then SEE "SUB (SP minus immediate)";
            d = UInt(Rd);  n = UInt(Rn);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
            if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_SUB_i_T5_AS
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode '11110011 1101xxxx 10x0xxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            if Rn == '1110' && IsZero(imm8) then SEE "ERET";
            d = 15;  n = UInt(Rn);  setflags = TRUE;  imm32 = ZeroExtend(imm8, 32);
            if n != 14 then UNPREDICTABLE;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        (result, nzcv) = AddWithCarry(R[n], NOT(imm32), '1');
        if d == 15 then
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VSRA_A
    __encoding aarch32_VSRA_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSRA_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                result = Int(Elem[D[m+r],e,esize], unsigned) >> shift_amount;
                Elem[D[d+r],e,esize] = Elem[D[d+r],e,esize] + result;

__instruction aarch32_SBC_r_A
    __encoding aarch32_SBC_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 110xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_SBC_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rdn 16 +: 3
        __opcode '01000001 10xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_SBC_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 011xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], NOT(shifted), PSTATE.C);
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_LDRSH_i_A
    __encoding aarch32_LDRSH_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x1xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE "LDRSH (literal)";
            if P == '0' && W == '1' then SEE "LDRSHT";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRSH_i_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111001 1011xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "LDRSH (literal)";
            if Rt == '1111' then SEE "Related instructions";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_LDRSH_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111001 0011xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "LDRSH (literal)";
            if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE "Related instructions";
            if P == '1' && U == '1' && W == '0' then SEE "LDRSHT";
            if P == '0' && W == '0' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
        address = if index then offset_addr else R[n];
        data = MemU[address,2];
        if wback then R[n] = offset_addr;
        R[t] = SignExtend(data, 32);

__instruction aarch32_AESE_A
    __encoding aarch32_AESE_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0011 00x0xxxx'
        __guard TRUE
        __decode
            if !HaveAESExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_AESE_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0011 00x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveAESExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        op1 = Q[d>>1]; op2 = Q[m>>1];
        Q[d>>1] = AESSubBytes(AESShiftRows(op1 EOR op2));

__instruction aarch32_VCVTA_vfp_A
    __encoding aarch32_VCVTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111100 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __encoding aarch32_VCVTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111100 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __execute
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
            when 32
                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
            when 64
                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_VABS_A
    __encoding aarch32_VABS_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x11 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            advsimd = TRUE;  floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VABS_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110000 xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VABS_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x11 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            advsimd = TRUE;  floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VABS_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110000 xxxx10xx 11x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then  // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if floating_point then
                        Elem[D[d+r],e,esize] = FPAbs(Elem[D[m+r],e,esize]);
                    else
                        result = Abs(SInt(Elem[D[m+r],e,esize]));
                        Elem[D[d+r],e,esize] = result<esize-1:0>;
        else             // VFP instruction
            case esize of
                when 16 S[d] = Zeros(16) : FPAbs(S[m]<15:0>);
                when 32 S[d] = FPAbs(S[m]);
                when 64 D[d] = FPAbs(D[m]);

__instruction aarch32_UXTAH_A
    __encoding aarch32_UXTAH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1111xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE "UXTH";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTAH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0001xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE "UXTH";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d] = R[n] + ZeroExtend(rotated<15:0>, 32);

__instruction aarch32_VCLE_i_A
    __encoding aarch32_VCLE_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x01 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCLE_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x01 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                if floating_point then
                    bits(esize) zero = FPZero('0');
                    test_passed = FPCompareGE(zero, Elem[D[m+r],e,esize], StandardFPSCRValue());
                else
                    test_passed = (SInt(Elem[D[m+r],e,esize]) <= 0);
                Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_VSHL_i_A
    __encoding aarch32_VSHL_i_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if L:imm6 == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSHL_i_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if L:imm6 == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = LSL(Elem[D[m+r],e,esize], shift_amount);

__instruction aarch32_VABD_i_A
    __encoding aarch32_VABD_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0111 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VABD_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0111 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];
                op2 = Elem[Din[m+r],e,esize];
                absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
                if long_destination then
                    Elem[Q[d>>1],e,2*esize] = absdiff<2*esize-1:0>;
                else
                    Elem[D[d+r],e,esize] = absdiff<esize-1:0>;

__instruction aarch32_CMN_i_A
    __encoding aarch32_CMN_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0111xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_CMN_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm8 0 +: 8
        __opcode '11110x01 0001xxxx 0xxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  imm32 = T32ExpandImm(i:imm3:imm8);
            if n == 15 then UNPREDICTABLE;

    __execute __conditional
        (result, nzcv) = AddWithCarry(R[n], imm32, '0');
        PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VCLZ_A
    __encoding aarch32_VCLZ_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0100 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCLZ_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0100 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = CountLeadingZeroBits(Elem[D[m+r],e,esize])<esize-1:0>;

__instruction aarch32_SHA256SU0_A
    __encoding aarch32_SHA256SU0_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0011 11x0xxxx'
        __guard TRUE
        __decode
            if !HaveSHA256Ext() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_SHA256SU0_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0011 11x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveSHA256Ext() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        bits(128) result;
        X = Q[d>>1]; Y = Q[m>>1];
        T = Y<31:0> : X<127:32>;
        for e = 0 to 3
            elt = Elem[T, e, 32];
            elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);
            Elem[result, e, 32] = elt + Elem[X, e, 32];
        Q[d>>1] = result;

__instruction aarch32_MOV_r_A
    __encoding aarch32_MOV_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 101xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_MOV_r_T1_A
        __instruction_set T16
        __field D 23 +: 1
        __field Rm 19 +: 4
        __field Rd 16 +: 3
        __opcode '01000110 xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(D:Rd);  m = UInt(Rm);  setflags = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);
            if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_MOV_r_T2_A
        __instruction_set T16
        __field op 27 +: 2
        __field imm5 22 +: 5
        __field Rm 19 +: 3
        __field Rd 16 +: 3
        __opcode '000xxxxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = DecodeImmShift(op, imm5);
            if op == '00' && imm5 == '00000' && InITBlock() then UNPREDICTABLE;

    __encoding aarch32_MOV_r_T3_A
        __instruction_set T32
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 010x1111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = shifted;
        if d == 15 then
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_SXTB16_A
    __encoding aarch32_SXTB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 10001111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTB16_T1_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 00101111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d]<15:0>  = SignExtend(rotated<7:0>, 16);
        R[d]<31:16> = SignExtend(rotated<23:16>, 16);

__instruction aarch32_VRINTZ_vfp_A
    __encoding aarch32_VRINTZ_vfp_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110110 xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
            exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTZ_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110110 xxxx10xx 11x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
            exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_VMOV_sr_A
    __encoding aarch32_VMOV_sr_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field opc1 21 +: 2
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __field opc2 5 +: 2
        __opcode 'xxxx1110 xxx1xxxx xxxx1011 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            case U:opc1:opc2 of
                when 'x1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1<0>:opc2);
                when 'x0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1<0>:opc2<1>);
                when '00x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1<0>);
                when '10x00'  UNDEFINED;
                when 'x0x10'  UNDEFINED;
            t = UInt(Rt);  n = UInt(N:Vn);  unsigned = (U == '1');
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMOV_sr_T1A1_A
        __instruction_set T32
        __field U 23 +: 1
        __field opc1 21 +: 2
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __field opc2 5 +: 2
        __opcode '11101110 xxx1xxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            case U:opc1:opc2 of
                when 'x1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1<0>:opc2);
                when 'x0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1<0>:opc2<1>);
                when '00x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1<0>);
                when '10x00'  UNDEFINED;
                when 'x0x10'  UNDEFINED;
            t = UInt(Rt);  n = UInt(N:Vn);  unsigned = (U == '1');
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if unsigned then
            R[t] = ZeroExtend(Elem[D[n],index,esize], 32);
        else
            R[t] = SignExtend(Elem[D[n],index,esize], 32);

__instruction aarch32_VCMLA_A
    __encoding aarch32_VCMLA_A1_A
        __instruction_set A32
        __field rot 23 +: 2
        __field D 22 +: 1
        __field S 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111110x xx1xxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveFCADDExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            esize = 16 << UInt(S);
            if !HaveFP16Ext() && esize == 16 then UNDEFINED;
            elements = 64 DIV esize;
            regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCMLA_T1_A
        __instruction_set T32
        __field rot 23 +: 2
        __field D 22 +: 1
        __field S 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111110x xx1xxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveFCADDExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            esize = 16 << UInt(S);
            if !HaveFP16Ext() && esize == 16 then UNDEFINED;
            elements = 64 DIV esize;
            regs = if Q == '0' then 1 else 2;

    __execute
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            operand1 = D[n+r];
            operand2 = D[m+r];
            operand3 = D[d+r];
            for e = 0 to (elements DIV 2)-1
                case rot of
                    when '00'
                       element1 = Elem[operand2,e*2,esize];
                       element2 = Elem[operand1,e*2,esize];
                       element3 = Elem[operand2,e*2+1,esize];
                       element4 = Elem[operand1,e*2,esize];
                    when '01'
                       element1 = FPNeg(Elem[operand2,e*2+1,esize]);
                       element2 = Elem[operand1,e*2+1,esize];
                       element3 = Elem[operand2,e*2,esize];
                       element4 = Elem[operand1,e*2+1,esize];
                    when '10'
                       element1 = FPNeg(Elem[operand2,e*2,esize]);
                       element2 = Elem[operand1,e*2,esize];
                       element3 = FPNeg(Elem[operand2,e*2+1,esize]);
                       element4 = Elem[operand1,e*2,esize];
                    when '11'
                       element1 = Elem[operand2,e*2+1,esize];
                       element2 = Elem[operand1,e*2+1,esize];
                       element3 = FPNeg(Elem[operand2,e*2,esize]);
                       element4 = Elem[operand1,e*2+1,esize];
                result1 = FPMulAdd(Elem[operand3,e*2,esize],element2,element1, StandardFPSCRValue());
                result2 = FPMulAdd(Elem[operand3,e*2+1,esize],element4,element3, StandardFPSCRValue());
                Elem[D[d+r],e*2,esize] = result1;
                Elem[D[d+r],e*2+1,esize] = result2;

__instruction aarch32_BIC_r_A
    __encoding aarch32_BIC_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 110xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_BIC_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rdn 16 +: 3
        __opcode '01000011 10xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_BIC_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 001xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;  // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] AND NOT(shifted);
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_SMULL_A
    __encoding aarch32_SMULL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 110xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_SMULL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1000xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute __conditional
        result = SInt(R[n]) * SInt(R[m]);
        R[dHi] = result<63:32>;
        R[dLo] = result<31:0>;
        if setflags then
            PSTATE.N = result<63>;
            PSTATE.Z = IsZeroBit(result<63:0>);
            // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_VLD3_m_A
    __encoding aarch32_VLD3_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx010x xxxxxxxx'
        __guard TRUE
        __decode
            case type1 of
                when '0100'
                    inc = 1;
                when '0101'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            if size == '11' || align<1> == '1' then UNDEFINED;
            alignment = if align<0> == '0' then 1 else 8;
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx010x xxxxxxxx'
        __guard TRUE
        __decode
            case type1 of
                when '0100'
                    inc = 1;
                when '0101'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            if size == '11' || align<1> == '1' then UNDEFINED;
            alignment = if align<0> == '0' then 1 else 8;
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = FALSE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        for e = 0 to elements-1
            Elem[D[d], e] = MemU[address,ebytes];
            Elem[D[d2],e] = MemU[address+ebytes,ebytes];
            Elem[D[d3],e] = MemU[address+2*ebytes,ebytes];
            address = address + 3*ebytes;
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 24;

__instruction aarch32_LDREXB_A
    __encoding aarch32_LDREXB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1101xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDREXB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 0100xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        address = R[n];
        AArch32.SetExclusiveMonitors(address,1);
        R[t] = ZeroExtend(MemA[address,1], 32);

__instruction aarch32_VNMLA_A
    __encoding aarch32_VNMLA_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x10xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '01' && !HaveFP16Ext() then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            type1 = VFPNegMul_VNMUL;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VNMLA_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x10xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '01' && !HaveFP16Ext() then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            type1 = VFPNegMul_VNMUL;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                product16 = FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);
                case type1 of
                    when VFPNegMul_VNMLA  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), FPNeg(product16), FPSCR);
                    when VFPNegMul_VNMLS  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), product16, FPSCR);
                    when VFPNegMul_VNMUL  S[d] = Zeros(16) : FPNeg(product16);
            when 32
                product32 = FPMul(S[n], S[m], FPSCR);
                case type1 of
                    when VFPNegMul_VNMLA  S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), FPSCR);
                    when VFPNegMul_VNMLS  S[d] = FPAdd(FPNeg(S[d]), product32, FPSCR);
                    when VFPNegMul_VNMUL  S[d] = FPNeg(product32);
            when 64
                product64 = FPMul(D[n], D[m], FPSCR);
                case type1 of
                    when VFPNegMul_VNMLA  D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), FPSCR);
                    when VFPNegMul_VNMLS  D[d] = FPAdd(FPNeg(D[d]), product64, FPSCR);
                    when VFPNegMul_VNMUL  D[d] = FPNeg(product64);

__instruction aarch32_LDRH_r_A
    __encoding aarch32_LDRH_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x1xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if P == '0' && W == '1' then SEE "LDRHT";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = (SRType_LSL, 0);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRH_r_T1_A
        __instruction_set T16
        __field Rm 22 +: 3
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '0101101x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_LDRH_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0011xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "LDRH (literal)";
            if Rt == '1111' then SEE "PLDW (register)";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if index then offset_addr else R[n];
        data = MemU[address,2];
        if wback then R[n] = offset_addr;
        R[t] = ZeroExtend(data, 32);

__instruction aarch32_MLA_A
    __encoding aarch32_MLA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 001xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  setflags = (S == '1');
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

    __encoding aarch32_MLA_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 0000xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE "MUL";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  setflags = FALSE;
            if d == 15 || n == 15 || m  == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results
        operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results
        addend   = SInt(R[a]);  // addend   = UInt(R[a]) produces the same final results
        result = operand1 * operand2 + addend;
        R[d] = result<31:0>;
        if setflags then
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result<31:0>);
            // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_QSAX_A
    __encoding aarch32_QSAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QSAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum  = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);
        diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);
        R[d]<15:0>  = SignedSat(sum, 16);
        R[d]<31:16> = SignedSat(diff, 16);

__instruction aarch32_SHADD8_A
    __encoding aarch32_SHADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);
        sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);
        sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);
        sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);
        R[d]<7:0>   = sum1<8:1>;
        R[d]<15:8>  = sum2<8:1>;
        R[d]<23:16> = sum3<8:1>;
        R[d]<31:24> = sum4<8:1>;

__instruction aarch32_VQRSHL_A
    __encoding aarch32_VQRSHL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRSHL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                shift = SInt(Elem[D[n+r],e,esize]<7:0>);
                round_const = 1 << (-1-shift); // 0 for left shift, 2^(n-1) for right shift
                operand = Int(Elem[D[m+r],e,esize], unsigned);
                (result, sat) = SatQ((operand + round_const) << shift, esize, unsigned);
                Elem[D[d+r],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_VSQRT_A
    __encoding aarch32_VSQRT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110001 xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VSQRT_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110001 xxxx10xx 11x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        case esize of
            when 16 S[d] = Zeros(16) : FPSqrt(S[m]<15:0>, FPSCR);
            when 32 S[d] = FPSqrt(S[m], FPSCR);
            when 64 D[d] = FPSqrt(D[m], FPSCR);

__instruction aarch32_SUB_SP_r_A
    __encoding aarch32_SUB_SP_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 010x1101 xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_SUB_SP_r_T1_A
        __instruction_set T32
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 101x1101 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE "CMP (register)";
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(SP, NOT(shifted), '1');
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SXTAB_A
    __encoding aarch32_SXTAB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1010xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE "SXTB";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTAB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0100xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE "SXTB";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d] = R[n] + SignExtend(rotated<7:0>, 32);

__instruction aarch32_VMUL_s_A
    __encoding aarch32_VMUL_s_A1_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx100x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMUL_s_T1_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx100x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                if floating_point then
                    Elem[D[d+r],e,esize] = FPMul(op1, op2, StandardFPSCRValue());
                else
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = (op1val*op2val)<2*esize-1:0>;
                    else
                        Elem[D[d+r],e,esize] = (op1val*op2val)<esize-1:0>;

__instruction aarch32_LDRSHT_A
    __encoding aarch32_LDRSHT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx0000 x111xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_LDRSHT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0000 x011xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRSHT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111001 0011xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            if Rn == '1111' then SEE "LDRSH (literal)";
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = if register_form then R[m] else imm32;
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if postindex then R[n] else offset_addr;
        data = MemU_unpriv[address,2];
        if postindex then R[n] = offset_addr;
        R[t] = SignExtend(data, 32);

__instruction aarch32_CSDB_A
    __encoding aarch32_CSDB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00010100'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if cond != '1110' then UNPREDICTABLE;      // CSDB must be encoded with AL condition

    __encoding aarch32_CSDB_T1_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00010100'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            if InITBlock() then UNPREDICTABLE;

    __execute __conditional
        
        ConsumptionOfSpeculativeDataBarrier();

__instruction aarch32_AESMC_A
    __encoding aarch32_AESMC_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0011 10x0xxxx'
        __guard TRUE
        __decode
            if !HaveAESExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_AESMC_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0011 10x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveAESExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        Q[d>>1] = AESMixColumns(Q[m>>1]);

__instruction aarch32_VMAXNM_A
    __encoding aarch32_VMAXNM_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAXNM_A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x00xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            advsimd = FALSE;
            maximum = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VMAXNM_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAXNM_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x00xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            advsimd = FALSE;
            maximum = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then             // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[n+r], e, esize]; op2 = Elem[D[m+r], e, esize];
                    if maximum then
                        Elem[D[d+r], e, esize] = FPMaxNum(op1, op2, StandardFPSCRValue());
                    else
                        Elem[D[d+r], e, esize] = FPMinNum(op1, op2, StandardFPSCRValue());
        else                        // VFP instruction
            case esize of
                when 16
                    if maximum then
                        S[d] = Zeros(16) : FPMaxNum(S[n]<15:0>, S[m]<15:0>, FPSCR);
                    else
                        S[d] = Zeros(16) : FPMinNum(S[n]<15:0>, S[m]<15:0>, FPSCR);
                when 32
                    if maximum then
                        S[d] = FPMaxNum(S[n], S[m], FPSCR);
                    else
                        S[d] = FPMinNum(S[n], S[m], FPSCR);
                when 64
                    if maximum then
                        D[d] = FPMaxNum(D[n], D[m], FPSCR);
                    else
                        D[d] = FPMinNum(D[n], D[m], FPSCR);

__instruction aarch32_VMLA_i_A
    __encoding aarch32_VMLA_i_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            add = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __encoding aarch32_VMLA_i_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            add = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);
                addend = if add then product else -product;
                if long_destination then
                    Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                else
                    Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_RBIT_A
    __encoding aarch32_RBIT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1111xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  m = UInt(Rm);
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_RBIT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 1010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
            if m != n || d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        bits(32) result;
        for i = 0 to 31
            result<31-i> = R[m]<i>;
        R[d] = result;

__instruction aarch32_LDRD_i_A
    __encoding aarch32_LDRD_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x0xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE "LDRD (literal)";
            if Rt<0> == '1' then UNPREDICTABLE;
            t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if P == '0' && W == '1' then UNPREDICTABLE;
            if wback && (n == t || n == t2) then UNPREDICTABLE;
            if t2 == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRD_i_T1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __field imm8 0 +: 8
        __opcode '1110100x x1x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && W == '0' then SEE "Related encodings";
            if Rn == '1111' then SEE "LDRD (literal)";
            t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if wback && (n == t || n == t2) then UNPREDICTABLE;
            if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
        address = if index then offset_addr else R[n];
        if address == Align(address, 8) then
            data = MemA[address,8];
            if BigEndian()  then
                R[t] = data<63:32>;
                R[t2] = data<31:0>;
            else
                R[t] = data<31:0>;
                R[t2] = data<63:32>;
        else
            R[t] = MemA[address,4];
            R[t2] = MemA[address+4,4];
        if wback then R[n] = offset_addr;

__instruction aarch32_SMLALBB_A
    __encoding aarch32_SMLALBB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field M 6 +: 1
        __field N 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0100xxxx xxxxxxxx 1xx0xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
            n_high = (N == '1');  m_high = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_SMLALBB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field N 5 +: 1
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 1100xxxx xxxxxxxx 10xxxxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
            n_high = (N == '1');  m_high = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute __conditional
        operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;
        operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
        result = SInt(operand1) * SInt(operand2) + SInt(R[dHi]:R[dLo]);
        R[dHi] = result<63:32>;
        R[dLo] = result<31:0>;

__instruction aarch32_CLZ_A
    __encoding aarch32_CLZ_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0110xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  m = UInt(Rm);
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_CLZ_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1011xxxx 1111xxxx 1000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
            if m != n || d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = CountLeadingZeroBits(R[m]);
        R[d] = result<31:0>;

__instruction aarch32_VCVTA_asimd_A
    __encoding aarch32_VCVTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        CheckAdvSIMDEnabled();
        bits(esize) result;
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,
                                                 StandardFPSCRValue(), rounding);

__instruction aarch32_VPADDL_A
    __encoding aarch32_VPADDL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (op == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VPADDL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (op == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        h = elements DIV 2;
        
        for r = 0 to regs-1
            for e = 0 to h-1
                op1 = Elem[D[m+r],2*e,esize];  op2 = Elem[D[m+r],2*e+1,esize];
                result = Int(op1, unsigned) + Int(op2, unsigned);
                Elem[D[d+r],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_CMP_i_A
    __encoding aarch32_CMP_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0101xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_CMP_i_T1_A
        __instruction_set T16
        __field Rn 24 +: 3
        __field imm8 16 +: 8
        __opcode '00101xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);

    __encoding aarch32_CMP_i_T2_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm8 0 +: 8
        __opcode '11110x01 1011xxxx 0xxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  imm32 = T32ExpandImm(i:imm3:imm8);
            if n == 15 then UNPREDICTABLE;

    __execute __conditional
        (result, nzcv) = AddWithCarry(R[n], NOT(imm32), '1');
        PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VZIP_A
    __encoding aarch32_VZIP_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0001 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || (Q == '0' && size == '10') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            quadword_operation = (Q == '1');  esize = 8 << UInt(size);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VZIP_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0001 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || (Q == '0' && size == '10') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            quadword_operation = (Q == '1');  esize = 8 << UInt(size);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        if quadword_operation then
            if d == m then
                Q[d>>1] = bits(128) UNKNOWN;  Q[m>>1] = bits(128) UNKNOWN;
            else
                bits(256) zipped_q;
                for e = 0 to (128 DIV esize) - 1
                    Elem[zipped_q,2*e,esize] = Elem[Q[d>>1],e,esize];
                    Elem[zipped_q,2*e+1,esize] = Elem[Q[m>>1],e,esize];
                Q[d>>1] = zipped_q<127:0>;  Q[m>>1] = zipped_q<255:128>;
        else
            if d == m then
                D[d] = bits(64) UNKNOWN;  D[m] = bits(64) UNKNOWN;
            else
                bits(128) zipped_d;
                for e = 0 to (64 DIV esize) - 1
                    Elem[zipped_d,2*e,esize] = Elem[D[d],e,esize];
                    Elem[zipped_d,2*e+1,esize] = Elem[D[m],e,esize];
                D[d] = zipped_d<63:0>;  D[m] = zipped_d<127:64>;

__instruction aarch32_VCVT_xs_A
    __encoding aarch32_VCVT_xs_A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx11xx 0xx1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if op<1> == '0' && !HaveFP16Ext() then UNDEFINED;
            if op<1> == '0' && imm6 == '10xxxx' then UNDEFINED;
            if imm6 == '0xxxxx' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            to_fixed = (op<0> == '1');  frac_bits = 64 - UInt(imm6);
            unsigned = (U == '1');
            case op<1> of
                 when '0' esize = 16; elements = 4;
                 when '1' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVT_xs_T1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx11xx 0xx1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if op<1> == '0' && !HaveFP16Ext() then UNDEFINED;
            if op<1> == '0' && imm6 == '10xxxx' then UNDEFINED;
            if imm6 == '0xxxxx' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            to_fixed = (op<0> == '1');  frac_bits = 64 - UInt(imm6);
            unsigned = (U == '1');
            case op<1> of
                 when '0' esize = 16; elements = 4;
                 when '1' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        bits(esize) result;
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                if to_fixed then
                    result = FPToFixed(op1, frac_bits, unsigned, StandardFPSCRValue(),
                                       FPRounding_ZERO);
                else
                    result = FixedToFP(op1, frac_bits, unsigned, StandardFPSCRValue(),
                                       FPRounding_TIEEVEN);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_STREXH_A
    __encoding aarch32_STREXH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1110xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STREXH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 0101xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
            if d == n || d == t then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        if AArch32.ExclusiveMonitorsPass(address,2) then
            MemA[address,2] = R[t]<15:0>;
            R[d] = ZeroExtend('0');
        else
            R[d] = ZeroExtend('1');

__instruction aarch32_VMUL_f_A
    __encoding aarch32_VMUL_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMUL_f_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x10xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE;
            
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VMUL_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMUL_f_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x10xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            advsimd = FALSE;
            
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then  // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
        else             // VFP instruction
            case esize of
                when 16
                    S[d] = Zeros(16) : FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);
                when 32
                    S[d] = FPMul(S[n], S[m], FPSCR);
                when 64
                    D[d] = FPMul(D[n], D[m], FPSCR);

__instruction aarch32_UXTB_A
    __encoding aarch32_UXTB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 11101111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTB_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rd 16 +: 3
        __opcode '10110010 11xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

    __encoding aarch32_UXTB_T2_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 01011111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d] = ZeroExtend(rotated<7:0>, 32);

__instruction aarch32_PSSBB_A
    __encoding aarch32_PSSBB_A1_A
        __instruction_set A32
        __opcode '11110101 0111xxxx xxxxxxxx 01000100'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_PSSBB_T1_A
        __instruction_set T32
        __opcode '11110011 1011xxxx 10x0xxxx 01000100'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            if InITBlock() then UNPREDICTABLE;

    __execute __conditional
        SpeculativeStoreBypassBarrierToPA();

__instruction aarch32_VSTR_A
    __encoding aarch32_VSTR_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode 'xxxx1101 xx00xxxx xxxx10xx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);
            if n == 15 && CurrentInstrSet() != InstrSet_A32 then UNPREDICTABLE;

    __encoding aarch32_VSTR_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode '11101101 xx00xxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);
            if n == 15 && CurrentInstrSet() != InstrSet_A32 then UNPREDICTABLE;

    __execute __conditional
        CheckVFPEnabled(TRUE);
        address = if add then (R[n] + imm32) else (R[n] - imm32);
        case esize of
            when 16
                MemA[address,2] = S[d]<15:0>;
            when 32
                MemA[address,4] = S[d];
            when 64
                // Store as two word-aligned words in the correct order for current endianness.
                MemA[address,4]   = if BigEndian() then D[d]<63:32> else D[d]<31:0>;
                MemA[address+4,4] = if BigEndian() then D[d]<31:0>  else D[d]<63:32>;

__instruction aarch32_TST_i_A
    __encoding aarch32_TST_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0001xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_TST_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm8 0 +: 8
        __opcode '11110x00 0001xxxx 0xxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = R[n] AND imm32;
        PSTATE.N = result<31>;
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged

__instruction aarch32_VMSR_AS
    __encoding aarch32_VMSR_T1A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field reg 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx1110 1110xxxx xxxx1010 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            t = UInt(Rt);
            if reg != '000x' && reg != '1000' then UNPREDICTABLE;
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMSR_T1A1_AS
        __instruction_set T32
        __field reg 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101110 1110xxxx xxxx1010 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            t = UInt(Rt);
            if reg != '000x' && reg != '1000' then UNPREDICTABLE;
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        if reg == '0001' then                 // FPSCR
            CheckVFPEnabled(TRUE);
            FPSCR = R[t];
        elsif PSTATE.EL == EL0 then
            UNDEFINED;                        // Non-FPSCR registers accessible only at PL1 or above
        else
            CheckVFPEnabled(FALSE);           // Non-FPSCR registers are not affected by FPEXC.EN
            case reg of
                when '0000'                   // VMSR access to FPSID is ignored
                when '1000'  FPEXC = R[t];
                otherwise    Unreachable();   // Dealt with above or in encoding-specific pseudocode

__instruction aarch32_LDRB_l_A
    __encoding aarch32_LDRB_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x1x11111 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "LDRBT";
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);
            add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || wback then UNPREDICTABLE;

    __encoding aarch32_LDRB_l_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 x0011111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE "PLD";
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        base = Align(PC,4);
        address = if add then (base + imm32) else (base - imm32);
        R[t] = ZeroExtend(MemU[address,1], 32);

__instruction aarch32_RSB_rr_A
    __encoding aarch32_RSB_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 011xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, '1');
        R[d] = result;
        if setflags then
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_LDAEXH_A
    __encoding aarch32_LDAEXH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1111xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAEXH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1101xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        AArch32.SetExclusiveMonitors(address, 2);
        R[t] = ZeroExtend(MemO[address, 2], 32);

__instruction aarch32_VRINTX_vfp_A
    __encoding aarch32_VRINTX_vfp_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110111 xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            exact = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTX_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110111 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            exact = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        rounding = FPRoundingMode(FPSCR);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_UXTB16_A
    __encoding aarch32_UXTB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 11001111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTB16_T1_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 00111111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d]<15:0>  = ZeroExtend(rotated<7:0>, 16);
        R[d]<31:16> = ZeroExtend(rotated<23:16>, 16);

__instruction aarch32_STRB_r_A
    __encoding aarch32_STRB_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx011x x1x0xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "STRBT";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STRB_r_T1_A
        __instruction_set T16
        __field Rm 22 +: 3
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '0101010x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_STRB_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0000xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if t == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if index then offset_addr else R[n];
        MemU[address,1] = R[t]<7:0>;
        if wback then R[n] = offset_addr;

__instruction aarch32_SHA1M_A
    __encoding aarch32_SHA1M_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x10xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSHA1Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA1M_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x10xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveSHA1Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        X = Q[d>>1];
        Y = Q[n>>1]<31:0>; // Note: 32 bits wide
        W = Q[m>>1];
        for e = 0 to 3
            t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);
            Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
            X<63:32> = ROL(X<63:32>, 30);
            <Y, X> = ROL(Y:X, 32);
        Q[d>>1] = X;

__instruction aarch32_VLD1_m_A
    __encoding aarch32_VLD1_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  if align == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 3;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T4A4_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 4;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  if align == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 3;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T4A4_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 4;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = FALSE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        for r = 0 to regs-1
            for e = 0 to elements-1
                bits(ebytes*8) data;
                if ebytes != 8 then
                    data = MemU[address,ebytes];
                else
                    - = AArch32.CheckAlignment(address, ebytes, AccType_NORMAL, iswrite);
                    data<31:0> = if BigEndian() then MemU[address+4,4] else MemU[address,4];
                    data<63:32> = if BigEndian() then MemU[address,4] else MemU[address+4,4];
                Elem[D[d+r],e] = data;
                address = address + ebytes;
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 8*regs;

__instruction aarch32_SB_A
    __encoding aarch32_SB_A1_A
        __instruction_set A32
        __opcode '11110101 0111xxxx xxxxxxxx 0111xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_SB_T1_A
        __instruction_set T32
        __opcode '11110011 1011xxxx 10x0xxxx 0111xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if InITBlock() then UNPREDICTABLE;

    __execute __conditional
        SpeculationBarrier();

__instruction aarch32_VRINTA_vfp_A
    __encoding aarch32_VRINTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111011 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111011 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_RSB_i_A
    __encoding aarch32_RSB_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 011xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_RSB_i_T1_A
        __instruction_set T16
        __field Rn 19 +: 3
        __field Rd 16 +: 3
        __opcode '01000010 01xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = !InITBlock();  imm32 = Zeros(32); // immediate = #0

    __encoding aarch32_RSB_i_T2_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 110xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (result, nzcv) = AddWithCarry(NOT(R[n]), imm32, '1');
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SHASX_A
    __encoding aarch32_SHASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);
        sum  = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);
        R[d]<15:0>  = diff<16:1>;
        R[d]<31:16> = sum<16:1>;

__instruction aarch32_LDREXD_A
    __encoding aarch32_LDREXD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1011xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  t2 = t + 1;  n = UInt(Rn);
            if Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDREXD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 0111xxxx'
        __guard TRUE
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
            if t == 15 || t2 == 15 || t == t2 || n == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        address = R[n];
        AArch32.SetExclusiveMonitors(address,8);
        value = MemA[address,8];
        // Extract words from 64-bit loaded value such that R[t] is
        // loaded from address and R[t2] from address+4.
        R[t]  = if BigEndian() then value<63:32> else value<31:0>;
        R[t2] = if BigEndian() then value<31:0> else value<63:32>;

__instruction aarch32_VST3_m_A
    __encoding aarch32_VST3_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx010x xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' || align<1> == '1' then UNDEFINED;
            case type1 of
                when '0100'
                    inc = 1;
                when '0101'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            alignment = if align<0> == '0' then 1 else 8;
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx010x xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' || align<1> == '1' then UNDEFINED;
            case type1 of
                when '0100'
                    inc = 1;
                when '0101'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            alignment = if align<0> == '0' then 1 else 8;
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = TRUE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        for e = 0 to elements-1
            MemU[address,         ebytes] = Elem[D[d], e];
            MemU[address+ebytes,  ebytes] = Elem[D[d2],e];
            MemU[address+2*ebytes,ebytes] = Elem[D[d3],e];
            address = address + 3*ebytes;
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 24;

__instruction aarch32_VADD_i_A
    __encoding aarch32_VADD_i_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0xxxxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VADD_i_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0xxxxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = Elem[D[n+r],e,esize] + Elem[D[m+r],e,esize];

__instruction aarch32_VCVTA_asimd_A
    __encoding aarch32_VCVTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx0001 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx0001 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        CheckAdvSIMDEnabled();
        bits(esize) result;
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,
                                                 StandardFPSCRValue(), rounding);

__instruction aarch32_VQRSHRN_A
    __encoding aarch32_VQRSHRN_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx100x 01x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then SEE "VRSHRN";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VQRSHRN_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx100x 01x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then SEE "VRSHRN";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        round_const = 1 << (shift_amount - 1);
        for e = 0 to elements-1
            operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
            (result, sat) = SatQ((operand + round_const) >> shift_amount, esize, dest_unsigned);
            Elem[D[d],e,esize] = result;
            if sat then FPSCR.QC = '1';

__instruction aarch32_SEL_A
    __encoding aarch32_SEL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1000xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SEL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 1000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        R[d]<7:0>   = if PSTATE.GE<0> == '1' then R[n]<7:0>   else R[m]<7:0>;
        R[d]<15:8>  = if PSTATE.GE<1> == '1' then R[n]<15:8>  else R[m]<15:8>;
        R[d]<23:16> = if PSTATE.GE<2> == '1' then R[n]<23:16> else R[m]<23:16>;
        R[d]<31:24> = if PSTATE.GE<3> == '1' then R[n]<31:24> else R[m]<31:24>;

__instruction aarch32_AESIMC_A
    __encoding aarch32_AESIMC_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0011 11x0xxxx'
        __guard TRUE
        __decode
            if !HaveAESExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_AESIMC_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0011 11x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveAESExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        Q[d>>1] = AESInvMixColumns(Q[m>>1]);

__instruction aarch32_VADDHN_A
    __encoding aarch32_VADDHN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx0100 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VADDHN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx0100 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            result = Elem[Qin[n>>1],e,2*esize] + Elem[Qin[m>>1],e,2*esize];
            Elem[D[d],e,esize] = result<2*esize-1:esize>;

__instruction aarch32_MOVT_A
    __encoding aarch32_MOVT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm4 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0100xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  imm16 = imm4:imm12;
            if d == 15 then UNPREDICTABLE;

    __encoding aarch32_MOVT_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm4 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 1100xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  imm16 = imm4:i:imm3:imm8;
            if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        R[d]<31:16> = imm16;
        // R[d]<15:0> unchanged

__instruction aarch32_VCVT_xv_A
    __encoding aarch32_VCVT_xv_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field op 18 +: 1
        __field U 16 +: 1
        __field Vd 12 +: 4
        __field sf 8 +: 2
        __field sx 7 +: 1
        __field i 5 +: 1
        __field imm4 0 +: 4
        __opcode 'xxxx1110 1x111x1x xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if sf == '00' || (sf == '01' && !HaveFP16Ext()) then UNDEFINED;
            if sf == '01' && cond != '1110' then UNPREDICTABLE;
            to_fixed = (op == '1');  unsigned = (U == '1');
            size = if sx == '0' then 16 else 32;
            frac_bits = size - UInt(imm4:i);
            case sf of
                when '01' fp_size = 16; d = UInt(Vd:D);
                when '10' fp_size = 32; d = UInt(Vd:D);
                when '11' fp_size = 64; d = UInt(D:Vd);
            
            if frac_bits < 0 then UNPREDICTABLE;

    __encoding aarch32_VCVT_xv_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 18 +: 1
        __field U 16 +: 1
        __field Vd 12 +: 4
        __field sf 8 +: 2
        __field sx 7 +: 1
        __field i 5 +: 1
        __field imm4 0 +: 4
        __opcode '11101110 1x111x1x xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if sf == '00' || (sf == '01' && !HaveFP16Ext()) then UNDEFINED;
            if sf == '01' && InITBlock() then UNPREDICTABLE;
            to_fixed = (op == '1');  unsigned = (U == '1');
            size = if sx == '0' then 16 else 32;
            frac_bits = size - UInt(imm4:i);
            case sf of
                when '01' fp_size = 16; d = UInt(Vd:D);
                when '10' fp_size = 32; d = UInt(Vd:D);
                when '11' fp_size = 64; d = UInt(D:Vd);
            
            if frac_bits < 0 then UNPREDICTABLE;

    __execute __conditional
        CheckVFPEnabled(TRUE);
        if to_fixed then
            bits(size) result;
            case fp_size of
                when 16
                    result = FPToFixed(S[d]<15:0>, frac_bits, unsigned, FPSCR, FPRounding_ZERO);
                    S[d] = Extend(result, 32, unsigned);
                when 32
                    result = FPToFixed(S[d], frac_bits, unsigned, FPSCR, FPRounding_ZERO);
                    S[d] = Extend(result, 32, unsigned);
                when 64
                    result = FPToFixed(D[d], frac_bits, unsigned, FPSCR, FPRounding_ZERO);
                    D[d] = Extend(result, 64, unsigned);
        else
            case fp_size of
                when 16
                    bits(16) fp16 = FixedToFP(S[d]<size-1:0>, frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);
                    S[d] = Zeros(16):fp16;
                when 32
                    S[d] = FixedToFP(S[d]<size-1:0>, frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);
                when 64
                    D[d] = FixedToFP(D[d]<size-1:0>, frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);

__instruction aarch32_VRHADD_A
    __encoding aarch32_VRHADD_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0001 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRHADD_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0001 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Int(Elem[D[n+r],e,esize], unsigned);
                op2 = Int(Elem[D[m+r],e,esize], unsigned);
                result = op1 + op2 + 1;
                Elem[D[d+r],e,esize] = result<esize:1>;

__instruction aarch32_QSUB16_A
    __encoding aarch32_QSUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QSUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);
        diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);
        R[d]<15:0>  = SignedSat(diff1, 16);
        R[d]<31:16> = SignedSat(diff2, 16);

__instruction aarch32_UQASX_A
    __encoding aarch32_UQASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);
        sum  = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);
        R[d]<15:0>  = UnsignedSat(diff, 16);
        R[d]<31:16> = UnsignedSat(sum, 16);

__instruction aarch32_MSR_r_AS
    __encoding aarch32_MSR_r_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field R 22 +: 1
        __field mask 16 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0x10xxxx xxxxxx0x 0000xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            n = UInt(Rn);  write_spsr = (R == '1');
            if mask == '0000' then UNPREDICTABLE;
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_MSR_r_T1_AS
        __instruction_set T32
        __field R 20 +: 1
        __field Rn 16 +: 4
        __field mask 8 +: 4
        __opcode '11110011 100xxxxx 10x0xxxx xx0xxxxx'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            n = UInt(Rn);  write_spsr = (R == '1');
            if mask == '0000' then UNPREDICTABLE;
            if n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        if write_spsr then
            if PSTATE.M IN {M32_User,M32_System} then
                UNPREDICTABLE;
            else
                SPSRWriteByInstr(R[n], mask);
        else
            // Attempts to change to an illegal mode will invoke the Illegal Execution state mechanism
            CPSRWriteByInstr(R[n], mask);

__instruction aarch32_VTST_A
    __encoding aarch32_VTST_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0xxxxxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VTST_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0xxxxxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                if !IsZero(Elem[D[n+r],e,esize] AND Elem[D[m+r],e,esize]) then
                    Elem[D[d+r],e,esize] = Ones(esize);
                else
                    Elem[D[d+r],e,esize] = Zeros(esize);

__instruction aarch32_WFE_A
    __encoding aarch32_WFE_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000010'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_WFE_T1_A
        __instruction_set T16
        __opcode '10111111 00100000 00000000 00000000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_WFE_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000010'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute __conditional
        if IsEventRegisterSet() then
            ClearEventRegister();
        else
            if PSTATE.EL == EL0 then
                // Check for traps described by the OS which may be EL1 or EL2.
                AArch32.CheckForWFxTrap(EL1, TRUE);
            if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                // Check for traps described by the Hypervisor.
                AArch32.CheckForWFxTrap(EL2, TRUE);
            if HaveEL(EL3) && PSTATE.M != M32_Monitor then
                // Check for traps described by the Secure Monitor.
                AArch32.CheckForWFxTrap(EL3, TRUE);
            WaitForEvent();

__instruction aarch32_VMUL_i_A
    __encoding aarch32_VMUL_i_A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx11x0 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            unsigned = (U == '1'); polynomial = (op == '1'); long_destination = TRUE;
            esize = 8 << UInt(size); elements = 64 DIV esize;
            if polynomial then
                if U == '1' || size == '01' then UNDEFINED;
                if size == '10' then    // .p64
                    if !HaveBit128PMULLExt() then UNDEFINED;
                    esize = 64; elements = 1;
            if Vd<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;

    __encoding aarch32_VMUL_i_T2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx11x0 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            unsigned = (U == '1'); polynomial = (op == '1'); long_destination = TRUE;
            esize = 8 << UInt(size); elements = 64 DIV esize;
            if polynomial then
                if U == '1' || size == '01' then UNDEFINED;
                if size == '10' then    // .p64
                    if InITBlock() then UNPREDICTABLE;
                    if !HaveBit128PMULLExt() then UNDEFINED;
                    esize = 64; elements = 1;
            if Vd<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                op2 = Elem[Din[m+r],e,esize];  op2val = Int(op2, unsigned);
                if polynomial then
                    product = PolynomialMult(op1,op2);
                else
                    product = (op1val*op2val)<2*esize-1:0>;
                if long_destination then
                    Elem[Q[d>>1],e,2*esize] = product;
                else
                    Elem[D[d+r],e,esize] = product<esize-1:0>;

__instruction aarch32_LDRB_i_A
    __encoding aarch32_LDRB_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x1x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE "LDRB (literal)";
            if P == '0' && W == '1' then SEE "LDRBT";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRB_i_T1_A
        __instruction_set T16
        __field imm5 22 +: 5
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '01111xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_LDRB_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1001xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE "PLD";
            if Rn == '1111' then SEE "LDRB (literal)";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_LDRB_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0001xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE "PLD, PLDW (immediate)";
            if Rn == '1111' then SEE "LDRB (literal)";
            if P == '1' && U == '1' && W == '0' then SEE "LDRBT";
            if P == '0' && W == '0' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if  (t == 15 &&  W == '1') || (wback && n == t) then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            R[t] = ZeroExtend(MemU[address,1], 32);
            if wback then R[n] = offset_addr;
        else
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            R[t] = ZeroExtend(MemU[address,1], 32);
            if wback then R[n] = offset_addr;

__instruction aarch32_STLEX_A
    __encoding aarch32_STLEX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1000xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STLEX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1110xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        if AArch32.ExclusiveMonitorsPass(address,4) then
            MemO[address, 4] = R[t];
            R[d] = ZeroExtend('0');
        else
            R[d] = ZeroExtend('1');

__instruction aarch32_ORR_i_A
    __encoding aarch32_ORR_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 100xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_ORR_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 010xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "MOV (immediate)";
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = R[n] OR imm32;
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_VMRS_AS
    __encoding aarch32_VMRS_T1A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field reg 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx1110 1111xxxx xxxx1010 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            t = UInt(Rt);
            if !(reg IN {'000x', '0101', '011x', '1000'}) then UNPREDICTABLE;
            if t == 15 && reg != '0001' then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMRS_T1A1_AS
        __instruction_set T32
        __field reg 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101110 1111xxxx xxxx1010 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            t = UInt(Rt);
            if !(reg IN {'000x', '0101', '011x', '1000'}) then UNPREDICTABLE;
            if t == 15 && reg != '0001' then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        if reg == '0001' then                 // FPSCR
            CheckVFPEnabled(TRUE);
            if t == 15 then
                PSTATE.<N,Z,C,V> = FPSR.<N,Z,C,V>;
            else
                R[t] = FPSCR;
        elsif PSTATE.EL == EL0 then
            UNDEFINED;                        // Non-FPSCR registers accessible only at PL1 or above
        else
            CheckVFPEnabled(FALSE);           // Non-FPSCR registers are not affected by FPEXC.EN
            AArch32.CheckAdvSIMDOrFPRegisterTraps(reg);
            case reg of
                when '0000'  R[t] = FPSID;
                when '0101'  R[t] = MVFR2;
                when '0110'  R[t] = MVFR1;
                when '0111'  R[t] = MVFR0;
                when '1000'  R[t] = FPEXC;
                otherwise    Unreachable();   // Dealt with above or in encoding-specific pseudocode

__instruction aarch32_VSTM_A
    __encoding aarch32_VSTM_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx0xxxx xxxx1011 xxxxxxx1'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VSTR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VSTM_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx0xxxx xxxx1011 xxxxxxx1'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VSTR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __execute __conditional
        CheckVFPEnabled(TRUE);
        address = if add then R[n] else R[n]-imm32;
        for r = 0 to regs-1
            if single_regs then
                MemA[address,4] = S[d+r];  address = address+4;
            else
                // Store as two word-aligned words in the correct order for current endianness.
                MemA[address,4] = if BigEndian() then D[d+r]<63:32> else D[d+r]<31:0>;
                MemA[address+4,4] = if BigEndian() then D[d+r]<31:0> else D[d+r]<63:32>;
                address = address+8;
        if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;

__instruction aarch32_VMLA_f_A
    __encoding aarch32_VMLA_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;  add = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_f_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x00xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE; add = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VMLA_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE;  add = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_f_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x00xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE; add = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then  // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    product = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
                    addend = if add then product else FPNeg(product);
                    Elem[D[d+r],e,esize] = FPAdd(Elem[D[d+r],e,esize], addend, StandardFPSCRValue());
        else             // VFP instruction
            case esize of
                when 16
                    addend16 = if add then FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR) else FPNeg(FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR));
                    S[d] = Zeros(16) : FPAdd(S[d]<15:0>, addend16, FPSCR);
                when 32
                    addend32 = if add then FPMul(S[n], S[m], FPSCR) else FPNeg(FPMul(S[n], S[m], FPSCR));
                    S[d] = FPAdd(S[d], addend32, FPSCR);
                when 64
                    addend64 = if add then FPMul(D[n], D[m], FPSCR) else FPNeg(FPMul(D[n], D[m], FPSCR));
                    D[d] = FPAdd(D[d], addend64, FPSCR);

__instruction aarch32_QADD8_A
    __encoding aarch32_QADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);
        sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);
        sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);
        sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);
        R[d]<7:0>   = SignedSat(sum1, 8);
        R[d]<15:8>  = SignedSat(sum2, 8);
        R[d]<23:16> = SignedSat(sum3, 8);
        R[d]<31:24> = SignedSat(sum4, 8);

__instruction aarch32_LDM_A
    __encoding aarch32_LDM_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1000 10x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;

    __encoding aarch32_LDM_T1_A
        __instruction_set T16
        __field Rn 24 +: 3
        __field register_list 16 +: 8
        __opcode '11001xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            n = UInt(Rn);  registers = '00000000':register_list;  wback = (registers<n> == '0');
            if BitCount(registers) < 1 then UNPREDICTABLE;

    __encoding aarch32_LDM_T2_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field P 15 +: 1
        __field M 14 +: 1
        __field register_list 0 +: 14
        __opcode '11101000 10x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 2 || (P == '1' && M == '1') then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;
            if registers<13> == '1' then UNPREDICTABLE;
            if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        for i = 0 to 14
            if registers<i> == '1' then
                R[i] = MemA[address,4];  address = address + 4;
        if registers<15> == '1' then
            LoadWritePC(MemA[address,4]);
        if wback && registers<n> == '0' then R[n] = R[n] + 4*BitCount(registers);
        if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;

__instruction aarch32_SHA1H_A
    __encoding aarch32_SHA1H_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0010 11x0xxxx'
        __guard TRUE
        __decode
            if !HaveSHA1Ext() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_SHA1H_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0010 11x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveSHA1Ext() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        Q[d>>1] = ZeroExtend(ROL(Q[m>>1]<31:0>, 30), 128);

__instruction aarch32_VABA_A
    __encoding aarch32_VABA_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0101 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __encoding aarch32_VABA_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0101 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];
                op2 = Elem[Din[m+r],e,esize];
                absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
                if long_destination then
                    Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + absdiff;
                else
                    Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + absdiff;

__instruction aarch32_LDAH_A
    __encoding aarch32_LDAH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1111xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1001xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        R[t] = ZeroExtend(MemO[address, 2], 32);

__instruction aarch32_SRS_AS
    __encoding aarch32_SRS_A1_AS
        __instruction_set A32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field mode 0 +: 5
        __opcode '1111100x x1x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            wback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);

    __encoding aarch32_SRS_T1_AS
        __instruction_set T32
        __field W 21 +: 1
        __field mode 0 +: 5
        __opcode '11101000 00x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            wback = (W == '1');  increment = FALSE;  wordhigher = FALSE;

    __encoding aarch32_SRS_T2_AS
        __instruction_set T32
        __field W 21 +: 1
        __field mode 0 +: 5
        __opcode '11101001 10x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            wback = (W == '1');  increment = TRUE;  wordhigher = FALSE;

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if PSTATE.EL == EL2 then          // UNDEFINED at EL2
                UNDEFINED;
            
            // Check for UNPREDICTABLE cases. The definition of UNPREDICTABLE does not permit these
            // to be security holes
            if PSTATE.M IN {M32_User,M32_System} then
                UNPREDICTABLE;
            elsif mode == M32_Hyp then        // Check for attempt to access Hyp mode SP
                UNPREDICTABLE;
            elsif mode == M32_Monitor then    // Check for attempt to access Monitor mode SP
                if !HaveEL(EL3) || !IsSecure()  then
                    UNPREDICTABLE;
                elsif !ELUsingAArch32(EL3) then
                    AArch64.MonitorModeTrap();
            elsif BadMode(mode) then
                UNPREDICTABLE;
            
            base = Rmode[13,mode];
            address = if increment then base else base-8;
            if wordhigher then address = address+4;
            MemA[address,4]   = LR;
            MemA[address+4,4] = SPSR[];
            if wback then Rmode[13,mode] = if increment then base+8 else base-8;
        else
            if PSTATE.EL == EL2 then          // UNDEFINED at EL2
                UNDEFINED;
            
            // Check for UNPREDICTABLE cases. The definition of UNPREDICTABLE does not permit these
            // to be security holes
            if PSTATE.M IN {M32_User,M32_System} then
                UNPREDICTABLE;
            elsif mode == M32_Hyp then        // Check for attempt to access Hyp mode SP
                UNPREDICTABLE;
            elsif mode == M32_Monitor then    // Check for attempt to access Monitor mode SP
                if !HaveEL(EL3) || !IsSecure()  then
                    UNPREDICTABLE;
                elsif !ELUsingAArch32(EL3) then
                    AArch64.MonitorModeTrap();
            elsif BadMode(mode) then
                UNPREDICTABLE;
            
            base = Rmode[13,mode];
            address = if increment then base else base-8;
            if wordhigher then address = address+4;
            MemA[address,4]   = LR;
            MemA[address+4,4] = SPSR[];
            if wback then Rmode[13,mode] = if increment then base+8 else base-8;

__instruction aarch32_AND_rr_A
    __encoding aarch32_AND_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 000xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] AND shifted;
        R[d] = result;
        if setflags then
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_SMLAL_A
    __encoding aarch32_SMLAL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 111xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_SMLAL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1100xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute __conditional
        result = SInt(R[n]) * SInt(R[m]) + SInt(R[dHi]:R[dLo]);
        R[dHi] = result<63:32>;
        R[dLo] = result<31:0>;
        if setflags then
            PSTATE.N = result<63>;
            PSTATE.Z = IsZeroBit(result<63:0>);
            // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_SSAX_A
    __encoding aarch32_SSAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SSAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum  = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);
        diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);
        R[d]<15:0>  = sum<15:0>;
        R[d]<31:16> = diff<15:0>;
        PSTATE.GE<1:0> = if sum  >= 0 then '11' else '00';
        PSTATE.GE<3:2> = if diff >= 0 then '11' else '00';

__instruction aarch32_MLS_A
    __encoding aarch32_MLS_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 0110xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

    __encoding aarch32_MLS_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 0000xxxx xxxxxxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results
        operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results
        addend   = SInt(R[a]);  // addend   = UInt(R[a]) produces the same final results
        result = addend - operand1 * operand2;
        R[d] = result<31:0>;

__instruction aarch32_UMAAL_A
    __encoding aarch32_UMAAL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 0100xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_UMAAL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1110xxxx xxxxxxxx 0110xxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute __conditional
        result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]) + UInt(R[dLo]);
        R[dHi] = result<63:32>;
        R[dLo] = result<31:0>;

__instruction aarch32_VCVT_iv_A
    __encoding aarch32_VCVT_iv_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x111000 xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __encoding aarch32_VCVT_iv_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x111000 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        if to_integer then
            case esize of
                when 16
                    S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
                when 32
                    S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
                when 64
                    S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);
        else
            case esize of
                when 16
                    bits(16) fp16 = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                    S[d] = Zeros(16):fp16;
                when 32
                    S[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                when 64
                    D[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_VMLA_s_A
    __encoding aarch32_VMLA_s_A1_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx000x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            add = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMLA_s_T1_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx000x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            add = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                if floating_point then
                    fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));
                    Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());
                else
                    addend = if add then op1val*op2val else -op1val*op2val;
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                    else
                        Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_ADD_i_A
    __encoding aarch32_ADD_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 100xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' && S == '0' then SEE "ADR";
            if Rn == '1101' then SEE "ADD (SP plus immediate)";
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_ADD_i_T1_A
        __instruction_set T16
        __field imm3 22 +: 3
        __field Rn 19 +: 3
        __field Rd 16 +: 3
        __opcode '0001110x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm3, 32);

    __encoding aarch32_ADD_i_T2_A
        __instruction_set T16
        __field Rdn 24 +: 3
        __field imm8 16 +: 8
        __opcode '00110xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm8, 32);

    __encoding aarch32_ADD_i_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 000xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE "CMN (immediate)";
            if Rn == '1101' then SEE "ADD (SP plus immediate)";
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_ADD_i_T4_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 0000xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "ADR";
            if Rn == '1101' then SEE "ADD (SP plus immediate)";
            d = UInt(Rd);  n = UInt(Rn);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
            if d == 15 then UNPREDICTABLE;   // Armv8-A removes UNPREDICTABLE for R13

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            (result, nzcv) = AddWithCarry(R[n], imm32, '0');
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;
        else
            (result, nzcv) = AddWithCarry(R[n], imm32, '0');
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_STRH_i_A
    __encoding aarch32_STRH_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x0xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "STRHT";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STRH_i_T1_A
        __instruction_set T16
        __field imm5 22 +: 5
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '10000xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'0', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_STRH_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1010xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_STRH_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0010xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '1' && U == '1' && W == '0' then SEE "STRHT";
            if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            MemU[address,2] = R[t]<15:0>;
            if wback then R[n] = offset_addr;
        else
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            MemU[address,2] = R[t]<15:0>;
            if wback then R[n] = offset_addr;

__instruction aarch32_SSAT16_A
    __encoding aarch32_SSAT16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sat_imm 16 +: 4
        __field Rd 12 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0110 1010xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_SSAT16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field sat_imm 0 +: 4
        __opcode '11110x11 0010xxxx 0000xxxx 00xxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
            if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (result1, sat1) = SignedSatQ(SInt(R[n]<15:0>), saturate_to);
        (result2, sat2) = SignedSatQ(SInt(R[n]<31:16>), saturate_to);
        R[d]<15:0> = SignExtend(result1, 16);
        R[d]<31:16> = SignExtend(result2, 16);
        if sat1 || sat2 then
            PSTATE.Q = '1';

__instruction aarch32_ERET_AS
    __encoding aarch32_ERET_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0001 0110xxxx xxxxxxxx 0110xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_ERET_T1_A
        __instruction_set T32
        __opcode '11110011 11011110 10x0xxxx 00000000'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        if PSTATE.M IN {M32_User,M32_System} then
            UNPREDICTABLE;                        // UNDEFINED or NOP
        else
            new_pc_value = if PSTATE.EL == EL2 then ELR_hyp else R[14];
            AArch32.ExceptionReturn(new_pc_value, SPSR[]);

__instruction aarch32_MOV_rr_A
    __encoding aarch32_MOV_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 101xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __encoding aarch32_MOV_rr_T1_A
        __instruction_set T16
        __field op 22 +: 4
        __field Rs 19 +: 3
        __field Rdm 16 +: 3
        __opcode '0100000x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            if !(op IN {'0010', '0011', '0100', '0111'}) then SEE "Related encodings";
            d = UInt(Rdm);  m = UInt(Rdm);  s = UInt(Rs);
            setflags = !InITBlock();  shift_t = DecodeRegShift(op<2>:op<0>);

    __encoding aarch32_MOV_rr_T2_A
        __instruction_set T32
        __field type1 21 +: 2
        __field S 20 +: 1
        __field Rm 16 +: 4
        __field Rd 8 +: 4
        __field Rs 0 +: 4
        __opcode '11111010 0xxxxxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || m == 15 || s == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        (result, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        R[d] = result;
        if setflags then
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_VRSHRN_A
    __encoding aarch32_VRSHRN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1000 01x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VRSHRN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1000 01x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        round_const = 1 << (shift_amount-1);
        for e = 0 to elements-1
            result = LSR(Elem[Qin[m>>1],e,2*esize] + round_const, shift_amount);
            Elem[D[d],e,esize] = result<esize-1:0>;

__instruction aarch32_USUB8_A
    __encoding aarch32_USUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_USUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);
        diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);
        diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);
        diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);
        R[d]<7:0>   = diff1<7:0>;
        R[d]<15:8>  = diff2<7:0>;
        R[d]<23:16> = diff3<7:0>;
        R[d]<31:24> = diff4<7:0>;
        PSTATE.GE<0>  = if diff1 >= 0 then '1' else '0';
        PSTATE.GE<1>  = if diff2 >= 0 then '1' else '0';
        PSTATE.GE<2>  = if diff3 >= 0 then '1' else '0';
        PSTATE.GE<3>  = if diff4 >= 0 then '1' else '0';

__instruction aarch32_STRD_r_A
    __encoding aarch32_STRD_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x0xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rt<0> == '1' then UNPREDICTABLE;
            t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if P == '0' && W == '1' then UNPREDICTABLE;
            if t2 == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;

    __execute __conditional
        offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);
        address = if index then offset_addr else R[n];
        if address == Align(address, 8) then
            bits(64) data;
            if BigEndian() then
                data<63:32> = R[t];
                data<31:0> = R[t2];
            else
                data<31:0> = R[t];
                data<63:32> = R[t2];
            MemA[address,8] = data;
        else
            MemA[address,4] = R[t];
            MemA[address+4,4] = R[t2];
        if wback then R[n] = offset_addr;

__instruction aarch32_VPADD_i_A
    __encoding aarch32_VPADD_i_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0xxxxxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPADD_i_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0xxxxxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        bits(64) dest;
        h = elements DIV 2;
        
        for e = 0 to h-1
            Elem[dest,e,esize]   = Elem[D[n],2*e,esize] + Elem[D[n],2*e+1,esize];
            Elem[dest,e+h,esize] = Elem[D[m],2*e,esize] + Elem[D[m],2*e+1,esize];
        
        D[d] = dest;

__instruction aarch32_BFI_A
    __encoding aarch32_BFI_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field msb 16 +: 5
        __field Rd 12 +: 4
        __field lsb 7 +: 5
        __field Rn 0 +: 4
        __opcode 'xxxx0111 110xxxxx xxxxxxxx x001xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE "BFC";
            d = UInt(Rd);  n = UInt(Rn);  msbit = UInt(msb);  lsbit = UInt(lsb);
            if d == 15 then UNPREDICTABLE;

    __encoding aarch32_BFI_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field msb 0 +: 5
        __opcode '11110x11 0110xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            if Rn == '1111' then SEE "BFC";
            d = UInt(Rd);  n = UInt(Rn);  msbit = UInt(msb);  lsbit = UInt(imm3:imm2);
            if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        if msbit >= lsbit then
            R[d]<msbit:lsbit> = R[n]<(msbit-lsbit):0>;
            // Other bits of R[d] are unchanged
        else
            UNPREDICTABLE;

__instruction aarch32_VFMAL_A
    __encoding aarch32_VFMAL_A1_A
        __instruction_set A32
        __field S 23 +: 1
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111100 1x10xxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            
            integer d = UInt(D:Vd);
            integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
            integer m = if Q == '1' then UInt(M:Vm) else UInt(Vm:M);
            integer esize = 32;
            integer regs = if Q=='1' then 2 else 1;
            integer datasize = if Q=='1' then 64 else 32;
            boolean sub_op = S=='1';

    __encoding aarch32_VFMAL_T1_A
        __instruction_set T32
        __field S 23 +: 1
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111100 1x10xxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            
            integer d = UInt(D:Vd);
            integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
            integer m = if Q == '1' then UInt(M:Vm) else UInt(Vm:M);
            integer esize = 32;
            integer regs = if Q=='1' then 2 else 1;
            integer datasize = if Q=='1' then 64 else 32;
            boolean sub_op = S=='1';

    __execute
        CheckAdvSIMDEnabled();
        bits(datasize) operand1 ;
        bits(datasize) operand2 ;
        bits(64) operand3;
        bits(64) result;
        bits(esize DIV 2) element1;
        bits(esize DIV 2) element2;
        
        if Q=='0' then
            operand1 = S[n]<datasize-1:0>;
            operand2 = S[m]<datasize-1:0>;
        else
            operand1 = D[n]<datasize-1:0>;
            operand2 = D[m]<datasize-1:0>;
        for r = 0 to regs-1
            operand3 = D[d+r];
            for e = 0 to 1
                element1 = Elem[operand1, 2*r+e, esize DIV 2];
                element2 = Elem[operand2, 2*r+e, esize DIV 2];
                if sub_op then element1 = FPNeg(element1);
                Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, StandardFPSCRValue());
            D[d+r] = result;

__instruction aarch32_PLI_i_A
    __encoding aarch32_PLI_i_A1_A
        __instruction_set A32
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode '11110100 x101xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

    __encoding aarch32_PLI_i_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode '11111001 1001xxxx 1111xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "encoding T3";
            n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = TRUE;

    __encoding aarch32_PLI_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode '11111001 0001xxxx 11111100 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "encoding T3";
            n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);  add = FALSE;

    __encoding aarch32_PLI_i_T3_A
        __instruction_set T32
        __field U 23 +: 1
        __field imm12 0 +: 12
        __opcode '11111001 x0011111 1111xxxx xxxxxxxx'
        __guard TRUE
        __decode
            n = 15;  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

    __execute __conditional
        base = if n == 15 then Align(PC,4) else R[n];
        address = if add then (base + imm32) else (base - imm32);
        Hint_PreloadInstr(address);

__instruction aarch32_VQRDMLSH_A
    __encoding aarch32_VQRDMLSH_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            add = FALSE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMLSH_A2_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1111 x1x0xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            add = FALSE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQRDMLSH_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            add = FALSE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMLSH_T2_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1111 x1x0xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            add = FALSE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        CheckAdvSIMDEnabled();
        round_const = 1 << (esize-1);
        if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = SInt(Elem[D[n+r],e,esize]);
                op3 = SInt(Elem[D[d+r],e,esize]) << esize;
                if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
                (result, sat) = SignedSatQ((op3 - 2*(op1*op2) + round_const) >> esize, esize);
                Elem[D[d+r],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_VRINTZ_asimd_A
    __encoding aarch32_VRINTZ_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0101 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPRounding_ZERO;  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTZ_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0101 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPRounding_ZERO;  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_VQDMLAL_A
    __encoding aarch32_VQDMLAL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1011 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMLAL_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx0111 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQDMLAL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1011 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMLAL_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx0111 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
        for e = 0 to elements-1
            if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
            op1 = SInt(Elem[Din[n],e,esize]);
            // The following only saturates if both op1 and op2 equal -(2^(esize-1))
            (product, sat1) = SignedSatQ(2*op1*op2, 2*esize);
            if add then
                result = SInt(Elem[Qin[d>>1],e,2*esize]) + SInt(product);
            else
                result = SInt(Elem[Qin[d>>1],e,2*esize]) - SInt(product);
            (Elem[Q[d>>1],e,2*esize], sat2) = SignedSatQ(result, 2*esize);
            if sat1 || sat2 then FPSCR.QC = '1';

__instruction aarch32_VCADD_A
    __encoding aarch32_VCADD_A1_A
        __instruction_set A32
        __field rot 24 +: 1
        __field D 22 +: 1
        __field S 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111110x 1x0xxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveFCADDExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 16 << UInt(S);
            if !HaveFP16Ext() && esize == 16 then UNDEFINED;
            elements = 64 DIV esize;
            regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCADD_T1_A
        __instruction_set T32
        __field rot 24 +: 1
        __field D 22 +: 1
        __field S 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111110x 1x0xxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveFCADDExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 16 << UInt(S);
            if !HaveFP16Ext() && esize == 16 then UNDEFINED;
            elements = 64 DIV esize;
            regs = if Q == '0' then 1 else 2;

    __execute
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            operand1 = D[n+r];
            operand2 = D[m+r];
            operand3 = D[d+r];
            for e = 0 to (elements DIV 2)-1
                case rot of
                    when '0'
                        element1 = FPNeg(Elem[operand2,e*2+1,esize]);
                        element3 = Elem[operand2,e*2,esize];
                    when '1'
                        element1 = Elem[operand2,e*2+1,esize];
                        element3 = FPNeg(Elem[operand2,e*2,esize]);
                result1 = FPAdd(Elem[operand1,e*2,esize],element1,StandardFPSCRValue());
                result2 = FPAdd(Elem[operand1,e*2+1,esize],element3,StandardFPSCRValue());
                Elem[D[d+r],e*2,esize] = result1;
                Elem[D[d+r],e*2+1,esize] = result2;

__instruction aarch32_VQABS_A
    __encoding aarch32_VQABS_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0111 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQABS_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0111 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                result = Abs(SInt(Elem[D[m+r],e,esize]));
                (Elem[D[d+r],e,esize], sat) = SignedSatQ(result, esize);
                if sat then FPSCR.QC = '1';

__instruction aarch32_SSBB_A
    __encoding aarch32_SSBB_A1_A
        __instruction_set A32
        __opcode '11110101 0111xxxx xxxxxxxx 01000000'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_SSBB_T1_A
        __instruction_set T32
        __opcode '11110011 1011xxxx 10x0xxxx 01000000'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            if InITBlock() then UNPREDICTABLE;

    __execute __conditional
        SpeculativeStoreBypassBarrierToVA();

__instruction aarch32_VDOT_A
    __encoding aarch32_VDOT_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field U 4 +: 1
        __field Vm 0 +: 4
        __opcode '11111100 0x10xxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveDOTPExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            boolean signed = U=='0';
            integer d = UInt(D:Vd);
            integer n = UInt(N:Vn);
            integer m = UInt(M:Vm);
            integer esize = 32;
            integer regs = if Q == '1' then 2 else 1;

    __encoding aarch32_VDOT_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field U 4 +: 1
        __field Vm 0 +: 4
        __opcode '11111100 0x10xxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveDOTPExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            boolean signed = U=='0';
            integer d = UInt(D:Vd);
            integer n = UInt(N:Vn);
            integer m = UInt(M:Vm);
            integer esize = 32;
            integer regs = if Q == '1' then 2 else 1;

    __execute
        bits(64) operand1;
        bits(64) operand2;
        bits(64) result;
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            operand1 = D[n+r];
            operand2 = D[m+r];
            result = D[d+r];
            integer element1, element2;
            for e = 0 to 1
                integer res = 0;
                for i = 0 to 3
                    if signed then
                        element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                        element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);
                    else
                        element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                        element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);
                    res = res + element1 * element2;
                Elem[result, e, esize] = Elem[result, e, esize] + res;
            D[d+r] = result;

__instruction aarch32_VRINTA_vfp_A
    __encoding aarch32_VRINTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111010 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111010 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_VORR_i_A
    __encoding aarch32_VORR_i_T1A1_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx0xx1 0x01xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "VMOV (immediate)";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VORR_i_T2A2_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx10x1 0x01xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "VMOV (immediate)";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VORR_i_T1A1_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx0xx1 0x01xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "VMOV (immediate)";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VORR_i_T2A2_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx10x1 0x01xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "VMOV (immediate)";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            D[d+r] = D[d+r] OR imm64;

__instruction aarch32_VCEQ_i_A
    __encoding aarch32_VCEQ_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x01 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCEQ_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x01 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                if floating_point then
                    bits(esize) zero = FPZero('0');
                    test_passed = FPCompareEQ(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());
                else
                    test_passed = (Elem[D[m+r],e,esize] == Zeros(esize));
                Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_VST1_m_A
    __encoding aarch32_VST1_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  if align == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 3;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T4A4_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 4;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  if align == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 3;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T4A4_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 4;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = TRUE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        for r = 0 to regs-1
            for e = 0 to elements-1
                if ebytes != 8 then
                    MemU[address,ebytes] = Elem[D[d+r],e];
                else
                    - = AArch32.CheckAlignment(address, ebytes, AccType_NORMAL, iswrite);
                    bits(64) data = Elem[D[d+r],e];
                    MemU[address,4] = if BigEndian() then data<63:32> else data<31:0>;
                    MemU[address+4,4] = if BigEndian() then data<31:0> else data<63:32>;
                address = address + ebytes;
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 8*regs;

__instruction aarch32_LDRD_l_A
    __encoding aarch32_LDRD_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x01111 xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 24 == '1'
        __unpredictable_unless 21 == '0'
        __decode
            if Rt<0> == '1' then UNPREDICTABLE;
            t = UInt(Rt);  t2 = t+1;  imm32 = ZeroExtend(imm4H:imm4L, 32);  add = (U == '1');
            if t2 == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRD_l_T1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __field imm8 0 +: 8
        __opcode '1110100x x1x11111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && W == '0' then SEE "Related encodings";
            t = UInt(Rt);  t2 = UInt(Rt2);
            imm32 = ZeroExtend(imm8:'00', 32);  add = (U == '1');
            if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
            if W == '1' then UNPREDICTABLE;

    __execute __conditional
        address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
        if address == Align(address, 8) then
            data = MemA[address,8];
            if BigEndian() then
                R[t] = data<63:32>;
                R[t2] = data<31:0>;
            else
                R[t] = data<31:0>;
                R[t2] = data<63:32>;
        else
            R[t] = MemA[address,4];
            R[t2] = MemA[address+4,4];

__instruction aarch32_VADD_f_A
    __encoding aarch32_VADD_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VADD_f_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x11xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VADD_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VADD_f_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x11xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then  // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = FPAdd(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize],
                                                 StandardFPSCRValue());
        else             // VFP instruction
            case esize of
                when 16
                    S[d] = Zeros(16) : FPAdd(S[n]<15:0>, S[m]<15:0>, FPSCR);
                when 32
                    S[d] = FPAdd(S[n], S[m], FPSCR);
                when 64
                    D[d] = FPAdd(D[n], D[m], FPSCR);

__instruction aarch32_SMLSLD_A
    __encoding aarch32_SMLSLD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0100xxxx xxxxxxxx 01x1xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_SMLSLD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 1101xxxx xxxxxxxx 110xxxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute __conditional
        operand2 = if m_swap then ROR(R[m],16) else R[m];
        product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
        product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
        result = product1 - product2 + SInt(R[dHi]:R[dLo]);
        R[dHi] = result<63:32>;
        R[dLo] = result<31:0>;

__instruction aarch32_BIC_rr_A
    __encoding aarch32_BIC_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 110xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] AND NOT(shifted);
        R[d] = result;
        if setflags then
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_CMP_rr_A
    __encoding aarch32_CMP_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0101xxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            shift_t = DecodeRegShift(type1);
            if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
        PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SSAT_A
    __encoding aarch32_SSAT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sat_imm 16 +: 5
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field sh 6 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0110 101xxxxx xxxxxxxx xx01xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
            (shift_t, shift_n) = DecodeImmShift(sh:'0', imm5);
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_SSAT_T1_A
        __instruction_set T32
        __field sh 21 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field sat_imm 0 +: 5
        __opcode '11110x11 00x0xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            if sh == '1' && (imm3:imm2) == '00000' then SEE "SSAT16";
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
            (shift_t, shift_n) = DecodeImmShift(sh:'0', imm3:imm2);
            if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand = Shift(R[n], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored
        (result, sat) = SignedSatQ(SInt(operand), saturate_to);
        R[d] = SignExtend(result, 32);
        if sat then
            PSTATE.Q = '1';

__instruction aarch32_VCVTA_vfp_A
    __encoding aarch32_VCVTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111101 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __encoding aarch32_VCVTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111101 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __execute
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
            when 32
                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
            when 64
                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_SASX_A
    __encoding aarch32_SASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);
        sum  = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);
        R[d]<15:0>  = diff<15:0>;
        R[d]<31:16> = sum<15:0>;
        PSTATE.GE<1:0> = if diff >= 0 then '11' else '00';
        PSTATE.GE<3:2> = if sum  >= 0 then '11' else '00';

__instruction aarch32_LDRH_l_A
    __encoding aarch32_LDRH_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x11111 xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "LDRHT";
            t = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || wback then UNPREDICTABLE;

    __encoding aarch32_LDRH_l_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 x0111111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE "PLD (literal)";
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        base = Align(PC,4);
        address = if add then (base + imm32) else (base - imm32);
        data = MemU[address,2];
        R[t] = ZeroExtend(data, 32);

__instruction aarch32_VDOT_s_A
    __encoding aarch32_VDOT_s_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field U 4 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0x10xxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveDOTPExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            boolean signed = (U=='0');
            integer d = UInt(D:Vd);
            integer n = UInt(N:Vn);
            integer m = UInt(Vm<3:0>);
            integer index = UInt(M);
            integer esize = 32;
            integer regs = if Q == '1' then 2 else 1;

    __encoding aarch32_VDOT_s_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field U 4 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0x10xxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveDOTPExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            boolean signed = (U=='0');
            integer d = UInt(D:Vd);
            integer n = UInt(N:Vn);
            integer m = UInt(Vm<3:0>);
            integer index = UInt(M);
            integer esize = 32;
            integer regs = if Q == '1' then 2 else 1;

    __execute
        bits(64) operand1;
        bits(64) operand2 = D[m];
        bits(64) result;
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            operand1 = D[n+r];
            result = D[d+r];
            integer element1, element2;
            for e = 0 to 1
                integer res = 0;
                for i = 0 to 3
                    if signed then
                        element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                        element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);
                    else
                        element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                        element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);
                    res = res + element1 * element2;
                Elem[result, e, esize] = Elem[result, e, esize] + res;
            D[d+r] = result;

__instruction aarch32_STREXB_A
    __encoding aarch32_STREXB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1100xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STREXB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 0100xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
            if d == n || d == t then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        if AArch32.ExclusiveMonitorsPass(address,1) then
            MemA[address,1] = R[t]<7:0>;
            R[d] = ZeroExtend('0');
        else
            R[d] = ZeroExtend('1');

__instruction aarch32_ADD_r_A
    __encoding aarch32_ADD_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 100xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1101' then SEE "ADD (SP plus register)";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_ADD_r_T1_A
        __instruction_set T16
        __field Rm 22 +: 3
        __field Rn 19 +: 3
        __field Rd 16 +: 3
        __opcode '0001100x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_ADD_r_T2_A
        __instruction_set T16
        __field DN 23 +: 1
        __field Rm 19 +: 4
        __field Rdn 16 +: 3
        __opcode '01000100 xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            if (DN:Rdn) == '1101' || Rm == '1101' then SEE "ADD (SP plus register)";
            d = UInt(DN:Rdn);  n = d;  m = UInt(Rm);  setflags = FALSE;  (shift_t, shift_n) = (SRType_LSL, 0);
            if n == 15 && m == 15 then UNPREDICTABLE;
            if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_ADD_r_T3_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 000xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE "CMN (register)";
            if Rn == '1101' then SEE "ADD (SP plus register)";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], shifted, '0');
        if d == 15 then
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_UXTH_A
    __encoding aarch32_UXTH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 11111111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTH_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rd 16 +: 3
        __opcode '10110010 10xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

    __encoding aarch32_UXTH_T2_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 00011111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d] = ZeroExtend(rotated<15:0>, 32);

__instruction aarch32_STRH_r_A
    __encoding aarch32_STRH_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x0xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if P == '0' && W == '1' then SEE "STRHT";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = (SRType_LSL, 0);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STRH_r_T1_A
        __instruction_set T16
        __field Rm 22 +: 3
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '0101001x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_STRH_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0010xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if t == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if index then offset_addr else R[n];
        MemU[address,2] = R[t]<15:0>;
        if wback then R[n] = offset_addr;

__instruction aarch32_ORR_rr_A
    __encoding aarch32_ORR_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 100xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] OR shifted;
        R[d] = result;
        if setflags then
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_VACGE_A
    __encoding aarch32_VACGE_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x1xxxxx xxxx1110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            or_equal = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VACGE_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x1xxxxx xxxx1110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            or_equal = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = FPAbs(Elem[D[n+r],e,esize]);  op2 = FPAbs(Elem[D[m+r],e,esize]);
                if or_equal then
                    test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());
                else
                    test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());
                Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_QSUB_A
    __encoding aarch32_QSUB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QSUB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 1010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (R[d], sat) = SignedSatQ(SInt(R[m]) - SInt(R[n]), 32);
        if sat then
            PSTATE.Q = '1';

__instruction aarch32_CRC32_A
    __encoding aarch32_CRC32_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sz 21 +: 2
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field C 9 +: 1
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0xx0xxxx xxxxxx0x 0100xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if ! HaveCRCExt() then UNDEFINED;
            d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
            size = 8 << UInt(sz);
            crc32c = (C == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if size == 64 then UNPREDICTABLE;
            if cond != '1110' then UNPREDICTABLE;

    __encoding aarch32_CRC32_T1_A
        __instruction_set T32
        __field C 20 +: 1
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field sz 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 10xxxxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if ! HaveCRCExt() then UNDEFINED;
            d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
            size = 8 << UInt(sz);
            crc32c = (C == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if size == 64 then UNPREDICTABLE;

    __execute __conditional
        
        acc = R[n];             // accumulator
        val = R[m]<size-1:0>;   // input value
        poly = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;
        tempacc = BitReverse(acc):Zeros(size);
        tempval = BitReverse(val):Zeros(32);
        // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
        R[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));

__instruction aarch32_VMLA_i_A
    __encoding aarch32_VMLA_i_T1A1_A
        __instruction_set A32
        __field op 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0xxxxxxx xxxx1001 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            add = (op == '0');  long_destination = FALSE;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_i_T1A1_A
        __instruction_set T32
        __field op 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0xxxxxxx xxxx1001 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            add = (op == '0');  long_destination = FALSE;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);
                addend = if add then product else -product;
                if long_destination then
                    Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                else
                    Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_PLI_r_A
    __encoding aarch32_PLI_r_A1_A
        __instruction_set A32
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode '11110110 x101xxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  add = (U == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if m == 15 then UNPREDICTABLE;

    __encoding aarch32_PLI_r_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0001xxxx 11110000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "PLI (immediate, literal)";
            n = UInt(Rn);  m = UInt(Rm);  add = TRUE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
        address = if add then (R[n] + offset) else (R[n] - offset);
        Hint_PreloadInstr(address);

__instruction aarch32_VSLI_A
    __encoding aarch32_VSLI_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSLI_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        mask = LSL(Ones(esize), shift_amount);
        for r = 0 to regs-1
            for e = 0 to elements-1
                shifted_op = LSL(Elem[D[m+r],e,esize], shift_amount);
                Elem[D[d+r],e,esize] = (Elem[D[d+r],e,esize] AND NOT(mask)) OR shifted_op;

__instruction aarch32_UHSUB16_A
    __encoding aarch32_UHSUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHSUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);
        diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);
        R[d]<15:0>  = diff1<16:1>;
        R[d]<31:16> = diff2<16:1>;

__instruction aarch32_STRD_i_A
    __encoding aarch32_STRD_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x0xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __decode
            if Rt<0> == '1' then UNPREDICTABLE;
            t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if P == '0' && W == '1' then UNPREDICTABLE;
            if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;
            if t2 == 15 then UNPREDICTABLE;

    __encoding aarch32_STRD_i_T1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __field imm8 0 +: 8
        __opcode '1110100x x1x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && W == '0' then SEE "Related encodings";
            t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if wback && (n == t || n == t2) then UNPREDICTABLE;
            if n == 15 || t == 15 || t2 == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
        address = if index then offset_addr else R[n];
        if address == Align(address, 8) then
            bits(64) data;
            if BigEndian() then
                data<63:32> = R[t];
                data<31:0> = R[t2];
            else
                data<31:0> = R[t];
                data<63:32> = R[t2];
            MemA[address,8] = data;
        else
            MemA[address,4] = R[t];
            MemA[address+4,4] = R[t2];
        if wback then R[n] = offset_addr;

__instruction aarch32_LDAEXB_A
    __encoding aarch32_LDAEXB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1101xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAEXB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1100xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        AArch32.SetExclusiveMonitors(address, 1);
        R[t] = ZeroExtend(MemO[address, 1], 32);

__instruction aarch32_VFNMA_A
    __encoding aarch32_VFNMA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x01xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VFNMA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x01xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;
                S[d] = Zeros(16) : FPMulAdd(FPNeg(S[d]<15:0>), op16, S[m]<15:0>, FPSCR);
            when 32
                op32 = if op1_neg then FPNeg(S[n]) else S[n];
                S[d] = FPMulAdd(FPNeg(S[d]), op32, S[m], FPSCR);
            when 64
                op64 = if op1_neg then FPNeg(D[n]) else D[n];
                D[d] = FPMulAdd(FPNeg(D[d]), op64, D[m], FPSCR);

__instruction aarch32_VRSUBHN_A
    __encoding aarch32_VRSUBHN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1xxxxxxx xxxx0110 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VRSUBHN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1xxxxxxx xxxx0110 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        round_const = 1 << (esize-1);
        for e = 0 to elements-1
            result = Elem[Qin[n>>1],e,2*esize] - Elem[Qin[m>>1],e,2*esize] + round_const;
            Elem[D[d],e,esize] = result<2*esize-1:esize>;

__instruction aarch32_SHA1P_A
    __encoding aarch32_SHA1P_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x01xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSHA1Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA1P_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x01xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveSHA1Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        X = Q[d>>1];
        Y = Q[n>>1]<31:0>; // Note: 32 bits wide
        W = Q[m>>1];
        for e = 0 to 3
            t = SHAparity(X<63:32>, X<95:64>, X<127:96>);
            Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
            X<63:32> = ROL(X<63:32>, 30);
            <Y, X> = ROL(Y:X, 32);
        Q[d>>1] = X;

__instruction aarch32_VLD1_1_A
    __encoding aarch32_VLD1_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD1 (single element to all lanes)";
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  alignment = 1;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VLD1_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD1 (single element to all lanes)";
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VLD1_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD1 (single element to all lanes)";
            if index_align<2> != '0' then UNDEFINED;
            if index_align<1:0> != '00' && index_align<1:0> != '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            alignment = if index_align<1:0> == '00' then 1 else 4;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VLD1_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD1 (single element to all lanes)";
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  alignment = 1;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VLD1_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD1 (single element to all lanes)";
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VLD1_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD1 (single element to all lanes)";
            if index_align<2> != '0' then UNDEFINED;
            if index_align<1:0> != '00' && index_align<1:0> != '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            alignment = if index_align<1:0> == '00' then 1 else 4;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = FALSE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        Elem[D[d],index] = MemU[address,ebytes];
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + ebytes;

__instruction aarch32_VORR_r_A
    __encoding aarch32_VORR_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x10xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VORR_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x10xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            D[d+r] = D[n+r] OR D[m+r];

__instruction aarch32_VCEQ_r_A
    __encoding aarch32_VCEQ_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            int_operation = TRUE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCEQ_r_A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            int_operation = FALSE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCEQ_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            int_operation = TRUE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCEQ_r_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            int_operation = FALSE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                if int_operation then
                    test_passed = (op1 == op2);
                else
                    test_passed = FPCompareEQ(op1, op2, StandardFPSCRValue());
                Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_VMAXNM_A
    __encoding aarch32_VMAXNM_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x1xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAXNM_A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x00xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            advsimd = FALSE;
            maximum = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VMAXNM_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x1xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAXNM_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x00xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            advsimd = FALSE;
            maximum = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then             // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[n+r], e, esize]; op2 = Elem[D[m+r], e, esize];
                    if maximum then
                        Elem[D[d+r], e, esize] = FPMaxNum(op1, op2, StandardFPSCRValue());
                    else
                        Elem[D[d+r], e, esize] = FPMinNum(op1, op2, StandardFPSCRValue());
        else                        // VFP instruction
            case esize of
                when 16
                    if maximum then
                        S[d] = Zeros(16) : FPMaxNum(S[n]<15:0>, S[m]<15:0>, FPSCR);
                    else
                        S[d] = Zeros(16) : FPMinNum(S[n]<15:0>, S[m]<15:0>, FPSCR);
                when 32
                    if maximum then
                        S[d] = FPMaxNum(S[n], S[m], FPSCR);
                    else
                        S[d] = FPMinNum(S[n], S[m], FPSCR);
                when 64
                    if maximum then
                        D[d] = FPMaxNum(D[n], D[m], FPSCR);
                    else
                        D[d] = FPMinNum(D[n], D[m], FPSCR);

__instruction aarch32_DSB_A
    __encoding aarch32_DSB_A1_A
        __instruction_set A32
        __field option 0 +: 4
        __opcode '11110101 0111xxxx xxxxxxxx 0100xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_DSB_T1_A
        __instruction_set T32
        __field option 0 +: 4
        __opcode '11110011 1011xxxx 10x0xxxx 0100xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            // No additional decoding required

    __execute __conditional
        case option of
            when '0001'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Reads;
            when '0010'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Writes;
            when '0011'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_All;
            when '0101'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Reads;
            when '0110'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Writes;
            when '0111'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_All;
            when '1001'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Reads;
            when '1010'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Writes;
            when '1011'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_All;
            when '1101'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Reads;
            when '1110'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Writes;
            otherwise
                if       option == '0000' then SEE "SSBB";
                elsif    option == '0100' then SEE "PSSBB";
                else     domain = MBReqDomain_FullSystem;      types = MBReqTypes_All;
        
        if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then
            if HCR.BSU == '11' then
                domain = MBReqDomain_FullSystem;
            if HCR.BSU == '10' && domain != MBReqDomain_FullSystem then
                domain = MBReqDomain_OuterShareable;
            if HCR.BSU == '01' && domain == MBReqDomain_Nonshareable then
                domain = MBReqDomain_InnerShareable;
        
        DataSynchronizationBarrier(domain, types);

__instruction aarch32_LDREXH_A
    __encoding aarch32_LDREXH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1111xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDREXH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 0101xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        address = R[n];
        AArch32.SetExclusiveMonitors(address,2);
        R[t] = ZeroExtend(MemA[address,2], 32);

__instruction aarch32_VLD3_1_A
    __encoding aarch32_VLD3_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD3 (single 3-element structure to all lanes)";
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD3 (single 3-element structure to all lanes)";
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD3 (single 3-element structure to all lanes)";
            if index_align<1:0> != '00' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD3 (single 3-element structure to all lanes)";
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD3 (single 3-element structure to all lanes)";
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD3 (single 3-element structure to all lanes)";
            if index_align<1:0> != '00' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];
        Elem[D[d], index] = MemU[address,ebytes];
        Elem[D[d2],index] = MemU[address+ebytes,ebytes];
        Elem[D[d3],index] = MemU[address+2*ebytes,ebytes];
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 3*ebytes;

__instruction aarch32_VNMLA_A
    __encoding aarch32_VNMLA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x01xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            type1 = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VNMLA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x01xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            type1 = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                product16 = FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);
                case type1 of
                    when VFPNegMul_VNMLA  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), FPNeg(product16), FPSCR);
                    when VFPNegMul_VNMLS  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), product16, FPSCR);
                    when VFPNegMul_VNMUL  S[d] = Zeros(16) : FPNeg(product16);
            when 32
                product32 = FPMul(S[n], S[m], FPSCR);
                case type1 of
                    when VFPNegMul_VNMLA  S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), FPSCR);
                    when VFPNegMul_VNMLS  S[d] = FPAdd(FPNeg(S[d]), product32, FPSCR);
                    when VFPNegMul_VNMUL  S[d] = FPNeg(product32);
            when 64
                product64 = FPMul(D[n], D[m], FPSCR);
                case type1 of
                    when VFPNegMul_VNMLA  D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), FPSCR);
                    when VFPNegMul_VNMLS  D[d] = FPAdd(FPNeg(D[d]), product64, FPSCR);
                    when VFPNegMul_VNMUL  D[d] = FPNeg(product64);

__instruction aarch32_UQADD16_A
    __encoding aarch32_UQADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);
        sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);
        R[d]<15:0>  = UnsignedSat(sum1, 16);
        R[d]<31:16> = UnsignedSat(sum2, 16);

__instruction aarch32_TBB_A
    __encoding aarch32_TBB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field H 4 +: 1
        __field Rm 0 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  is_tbh = (H == '1');
            if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        if is_tbh then
            halfwords = UInt(MemU[R[n]+LSL(R[m],1), 2]);
        else
            halfwords = UInt(MemU[R[n]+R[m], 1]);
        BranchWritePC(PC + 2*halfwords, BranchType_INDIR);

__instruction aarch32_SADD16_A
    __encoding aarch32_SADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);
        sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);
        R[d]<15:0>  = sum1<15:0>;
        R[d]<31:16> = sum2<15:0>;
        PSTATE.GE<1:0> = if sum1 >= 0 then '11' else '00';
        PSTATE.GE<3:2> = if sum2 >= 0 then '11' else '00';

__instruction aarch32_VMUL_s_A
    __encoding aarch32_VMUL_s_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1010 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;  floating_point = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMUL_s_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1010 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;  floating_point = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                if floating_point then
                    Elem[D[d+r],e,esize] = FPMul(op1, op2, StandardFPSCRValue());
                else
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = (op1val*op2val)<2*esize-1:0>;
                    else
                        Elem[D[d+r],e,esize] = (op1val*op2val)<esize-1:0>;

__instruction aarch32_VFMAL_i_A
    __encoding aarch32_VFMAL_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field S 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0x01xxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            
            integer d = UInt(D:Vd);
            integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
            integer m = if Q == '1' then UInt(Vm<2:0>) else UInt(Vm<2:0>:M);
            
            integer index = if Q == '1' then UInt(M:Vm<3>) else UInt(Vm<3>);
            integer esize = 32;
            integer regs = if Q=='1' then 2 else 1;
            integer datasize = if Q=='1' then 64 else 32;
            boolean sub_op = S=='1';

    __encoding aarch32_VFMAL_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field S 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0x01xxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            
            integer d = UInt(D:Vd);
            integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
            integer m = if Q == '1' then UInt(Vm<2:0>) else UInt(Vm<2:0>:M);
            
            integer index = if Q == '1' then UInt(M:Vm<3>) else UInt(Vm<3>);
            integer esize = 32;
            integer regs = if Q=='1' then 2 else 1;
            integer datasize = if Q=='1' then 64 else 32;
            boolean sub_op = S=='1';

    __execute
        CheckAdvSIMDEnabled();
        bits(datasize) operand1 ;
        bits(datasize) operand2 ;
        bits(64) operand3;
        bits(64) result;
        bits(esize DIV 2) element1;
        bits(esize DIV 2) element2;
        
        if Q=='0' then
            operand1 = S[n]<datasize-1:0>;
            operand2 = S[m]<datasize-1:0>;
        else
            operand1 = D[n]<datasize-1:0>;
            operand2 = D[m]<datasize-1:0>;
        element2 = Elem[operand2, index, esize DIV 2];
        for r = 0 to regs-1
            operand3 = D[d+r];
            for e = 0 to 1
                element1 = Elem[operand1, 2*r+e, esize DIV 2];
                if sub_op then element1 = FPNeg(element1);
                Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, StandardFPSCRValue());
            D[d+r] = result;

__instruction aarch32_VQMOVN_A
    __encoding aarch32_VQMOVN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 6 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if op == '00' then SEE "VMOVN";
            if size == '11' || Vm<0> == '1' then UNDEFINED;
            src_unsigned = (op == '11');  dest_unsigned = (op<0> == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VQMOVN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 6 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if op == '00' then SEE "VMOVN";
            if size == '11' || Vm<0> == '1' then UNDEFINED;
            src_unsigned = (op == '11');  dest_unsigned = (op<0> == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
            (Elem[D[d],e,esize], sat) = SatQ(operand, esize, dest_unsigned);
            if sat then FPSCR.QC = '1';

__instruction aarch32_UQSAX_A
    __encoding aarch32_UQSAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQSAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum  = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);
        diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);
        R[d]<15:0>  = UnsignedSat(sum, 16);
        R[d]<31:16> = UnsignedSat(diff, 16);

__instruction aarch32_SXTAH_A
    __encoding aarch32_SXTAH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1011xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE "SXTH";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTAH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0000xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE "SXTH";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d] = R[n] + SignExtend(rotated<15:0>, 32);

__instruction aarch32_VSTM_A
    __encoding aarch32_VSTM_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx0xxxx xxxx1011 xxxxxxx0'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VSTR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VSTM_T2A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx0xxxx xxxx1010 xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VSTR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = TRUE;  add = (U == '1');  wback = (W == '1');  d = UInt(Vd:D);  n = UInt(Rn);
            imm32 = ZeroExtend(imm8:'00', 32);  regs = UInt(imm8);
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;

    __encoding aarch32_VSTM_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx0xxxx xxxx1011 xxxxxxx0'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VSTR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VSTM_T2A2_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx0xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE "VSTR";
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = TRUE;  add = (U == '1');  wback = (W == '1');  d = UInt(Vd:D);  n = UInt(Rn);
            imm32 = ZeroExtend(imm8:'00', 32);  regs = UInt(imm8);
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;

    __execute __conditional
        CheckVFPEnabled(TRUE);
        address = if add then R[n] else R[n]-imm32;
        for r = 0 to regs-1
            if single_regs then
                MemA[address,4] = S[d+r];  address = address+4;
            else
                // Store as two word-aligned words in the correct order for current endianness.
                MemA[address,4] = if BigEndian() then D[d+r]<63:32> else D[d+r]<31:0>;
                MemA[address+4,4] = if BigEndian() then D[d+r]<31:0> else D[d+r]<63:32>;
                address = address+8;
        if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;

__instruction aarch32_MSR_i_AS
    __encoding aarch32_MSR_i_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field R 22 +: 1
        __field mask 16 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0x10xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            if mask == '0000' && R == '0' then SEE "Related encodings";
            imm32 = A32ExpandImm(imm12);  write_spsr = (R == '1');
            if mask == '0000' then UNPREDICTABLE;

    __execute __conditional
        if write_spsr then
            if PSTATE.M IN {M32_User,M32_System} then
                UNPREDICTABLE;
            else
                SPSRWriteByInstr(imm32, mask);
        else
            // Attempts to change to an illegal mode will invoke the Illegal Execution state mechanism
            CPSRWriteByInstr(imm32, mask);

__instruction aarch32_VREV16_A
    __encoding aarch32_VREV16_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0000 0xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VREV16_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0000 0xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        
        bits(64) result;
        integer element;
        integer rev_element;
        for r = 0 to regs-1
            element = 0;
            for c = 0 to containers-1
                rev_element = element + elements_per_container - 1;
                for e = 0 to elements_per_container-1
                    Elem[result, rev_element, esize] = Elem[D[m+r], element, esize];
                    element = element + 1;
                    rev_element = rev_element - 1;
            D[d+r] = result;

__instruction aarch32_VFMA_A
    __encoding aarch32_VFMA_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE; op1_neg = (op == '1');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VFMA_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x10xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE; op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VFMA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE; op1_neg = (op == '1');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VFMA_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x10xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE; op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    bits(esize) op1 = Elem[D[n+r],e,esize];
                    if op1_neg then op1 = FPNeg(op1);
                    Elem[D[d+r],e,esize] = FPMulAdd(Elem[D[d+r],e,esize],
                                           op1, Elem[D[m+r],e,esize], StandardFPSCRValue());
        
        else // VFP instruction
            case esize of
                when 16
                    op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;
                    S[d] = Zeros(16) : FPMulAdd(S[d]<15:0>, op16, S[m]<15:0>, FPSCR);
                when 32
                    op32 = if op1_neg then FPNeg(S[n]) else S[n];
                    S[d] = FPMulAdd(S[d], op32, S[m], FPSCR);
                when 64
                    op64 = if op1_neg then FPNeg(D[n]) else D[n];
                    D[d] = FPMulAdd(D[d], op64, D[m], FPSCR);

__instruction aarch32_STRBT_A
    __encoding aarch32_STRBT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0100 x110xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_STRBT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 x110xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_STRBT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0000xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if postindex then R[n] else offset_addr;
        MemU_unpriv[address,1] = R[t]<7:0>;
        if postindex then R[n] = offset_addr;

__instruction aarch32_WFI_A
    __encoding aarch32_WFI_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000011'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_WFI_T1_A
        __instruction_set T16
        __opcode '10111111 00110000 00000000 00000000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_WFI_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000011'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute __conditional
        if !InterruptPending() then
            if PSTATE.EL == EL0 then
                // Check for traps described by the OS which may be EL1 or EL2.
                AArch32.CheckForWFxTrap(EL1, FALSE);
            if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                // Check for traps described by the Hypervisor.
                AArch32.CheckForWFxTrap(EL2, FALSE);
            if HaveEL(EL3) && PSTATE.M != M32_Monitor then
                // Check for traps described by the Secure Monitor.
                AArch32.CheckForWFxTrap(EL3, FALSE);
            WaitForInterrupt();

__instruction aarch32_ORR_r_A
    __encoding aarch32_ORR_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 100xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_ORR_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rdn 16 +: 3
        __opcode '01000011 00xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_ORR_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 010xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rn == '1111' then SEE "Related encodings";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] OR shifted;
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_LDRB_r_A
    __encoding aarch32_LDRB_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx011x x1x1xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "LDRBT";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRB_r_T1_A
        __instruction_set T16
        __field Rm 22 +: 3
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '0101110x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_LDRB_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0001xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE "PLD";
            if Rn == '1111' then SEE "LDRB (literal)";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if index then offset_addr else R[n];
        R[t] = ZeroExtend(MemU[address,1],32);
        if wback then R[n] = offset_addr;

__instruction aarch32_VPADD_f_A
    __encoding aarch32_VPADD_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPADD_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        bits(64) dest;
        h = elements DIV 2;
        
        for e = 0 to h-1
            Elem[dest,e,esize]   = FPAdd(Elem[D[n],2*e,esize], Elem[D[n],2*e+1,esize], StandardFPSCRValue());
            Elem[dest,e+h,esize] = FPAdd(Elem[D[m],2*e,esize], Elem[D[m],2*e+1,esize], StandardFPSCRValue());
        
        D[d] = dest;

__instruction aarch32_VHADD_A
    __encoding aarch32_VHADD_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            add = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VHADD_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            add = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Int(Elem[D[n+r],e,esize], unsigned);
                op2 = Int(Elem[D[m+r],e,esize], unsigned);
                result = if add then op1+op2 else op1-op2;
                Elem[D[d+r],e,esize] = result<esize:1>;

__instruction aarch32_LDA_A
    __encoding aarch32_LDA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1001xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDA_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1010xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        R[t] = MemO[address, 4];

__instruction aarch32_SEV_A
    __encoding aarch32_SEV_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000100'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_SEV_T1_A
        __instruction_set T16
        __opcode '10111111 01000000 00000000 00000000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_SEV_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000100'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute __conditional
        SendEvent();

__instruction aarch32_USAD8_A
    __encoding aarch32_USAD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0111 1000xxxx 1111xxxx 0001xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_USAD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 0111xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        absdiff1 = Abs(UInt(R[n]<7:0>)   - UInt(R[m]<7:0>));
        absdiff2 = Abs(UInt(R[n]<15:8>)  - UInt(R[m]<15:8>));
        absdiff3 = Abs(UInt(R[n]<23:16>) - UInt(R[m]<23:16>));
        absdiff4 = Abs(UInt(R[n]<31:24>) - UInt(R[m]<31:24>));
        result = absdiff1 + absdiff2 + absdiff3 + absdiff4;
        R[d] = result<31:0>;

__instruction aarch32_MCR_A
    __encoding aarch32_MCR_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field opc1 21 +: 3
        __field CRn 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc2 5 +: 3
        __field CRm 0 +: 4
        __opcode 'xxxx1110 xxx0xxxx xxxx111x xxx1xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15  then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_MCR_T1A1_A
        __instruction_set T32
        __field opc1 21 +: 3
        __field CRn 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc2 5 +: 3
        __field CRm 0 +: 4
        __opcode '11101110 xxx0xxxx xxxx111x xxx1xxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15  then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        AArch32.SysRegWrite(cp, ThisInstr(), R[t]);

__instruction aarch32_MVN_rr_A
    __encoding aarch32_MVN_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 111xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = NOT(shifted);
        R[d] = result;
        if setflags then
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_SHSUB8_A
    __encoding aarch32_SHSUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHSUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);
        diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);
        diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);
        diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);
        R[d]<7:0>   = diff1<8:1>;
        R[d]<15:8>  = diff2<8:1>;
        R[d]<23:16> = diff3<8:1>;
        R[d]<31:24> = diff4<8:1>;

__instruction aarch32_UBFX_A
    __encoding aarch32_UBFX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field widthm1 16 +: 5
        __field Rd 12 +: 4
        __field lsb 7 +: 5
        __field Rn 0 +: 4
        __opcode 'xxxx0111 111xxxxx xxxxxxxx x101xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);
            lsbit = UInt(lsb);  widthminus1 = UInt(widthm1);
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_UBFX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field widthm1 0 +: 5
        __opcode '11110x11 1100xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);
            lsbit = UInt(imm3:imm2);  widthminus1 = UInt(widthm1);
            if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        msbit = lsbit + widthminus1;
        if msbit <= 31 then
            R[d] = ZeroExtend(R[n]<msbit:lsbit>, 32);
        else
            UNPREDICTABLE;

__instruction aarch32_SHSUB16_A
    __encoding aarch32_SHSUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHSUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);
        diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);
        R[d]<15:0>  = diff1<16:1>;
        R[d]<31:16> = diff2<16:1>;

__instruction aarch32_TEQ_rr_A
    __encoding aarch32_TEQ_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0011xxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            shift_t = DecodeRegShift(type1);
            if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] EOR shifted;
        PSTATE.N = result<31>;
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged

__instruction aarch32_UADD8_A
    __encoding aarch32_UADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m  == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);
        sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);
        sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);
        sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);
        R[d]<7:0>   = sum1<7:0>;
        R[d]<15:8>  = sum2<7:0>;
        R[d]<23:16> = sum3<7:0>;
        R[d]<31:24> = sum4<7:0>;
        PSTATE.GE<0>  = if sum1 >= 0x100 then '1' else '0';
        PSTATE.GE<1>  = if sum2 >= 0x100 then '1' else '0';
        PSTATE.GE<2>  = if sum3 >= 0x100 then '1' else '0';
        PSTATE.GE<3>  = if sum4 >= 0x100 then '1' else '0';

__instruction aarch32_SMUAD_A
    __encoding aarch32_SMUAD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0000xxxx 1111xxxx 00x1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMUAD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0010xxxx 1111xxxx 000xxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand2 = if m_swap then ROR(R[m],16) else R[m];
        product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
        product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
        result = product1 + product2;
        R[d] = result<31:0>;
        if result != SInt(result<31:0>) then  // Signed overflow
            PSTATE.Q = '1';

__instruction aarch32_MUL_A
    __encoding aarch32_MUL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 000xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_MUL_T1_A
        __instruction_set T16
        __field Rn 19 +: 3
        __field Rdm 16 +: 3
        __opcode '01000011 01xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rdm);  n = UInt(Rn);  m = UInt(Rdm);  setflags = !InITBlock();

    __encoding aarch32_MUL_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 0000xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results
        operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results
        result = operand1 * operand2;
        R[d] = result<31:0>;
        if setflags then
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result<31:0>);
            // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_VNMLA_A
    __encoding aarch32_VNMLA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x01xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            type1 = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VNMLA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x01xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            type1 = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                product16 = FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);
                case type1 of
                    when VFPNegMul_VNMLA  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), FPNeg(product16), FPSCR);
                    when VFPNegMul_VNMLS  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), product16, FPSCR);
                    when VFPNegMul_VNMUL  S[d] = Zeros(16) : FPNeg(product16);
            when 32
                product32 = FPMul(S[n], S[m], FPSCR);
                case type1 of
                    when VFPNegMul_VNMLA  S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), FPSCR);
                    when VFPNegMul_VNMLS  S[d] = FPAdd(FPNeg(S[d]), product32, FPSCR);
                    when VFPNegMul_VNMUL  S[d] = FPNeg(product32);
            when 64
                product64 = FPMul(D[n], D[m], FPSCR);
                case type1 of
                    when VFPNegMul_VNMLA  D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), FPSCR);
                    when VFPNegMul_VNMLS  D[d] = FPAdd(FPNeg(D[d]), product64, FPSCR);
                    when VFPNegMul_VNMUL  D[d] = FPNeg(product64);

__instruction aarch32_CMP_r_A
    __encoding aarch32_CMP_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0101xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_CMP_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rn 16 +: 3
        __opcode '01000010 10xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_CMP_r_T2_A
        __instruction_set T16
        __field N 23 +: 1
        __field Rm 19 +: 4
        __field Rn 16 +: 3
        __opcode '01000101 xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            n = UInt(N:Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, 0);
            if n < 8 && m < 8 then UNPREDICTABLE;
            if n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_CMP_r_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 1011xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
        PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_BKPT_A
    __encoding aarch32_BKPT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm12 8 +: 12
        __field imm4 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __decode
            imm16 = imm12:imm4;
            if cond != '1110' then UNPREDICTABLE;  // BKPT must be encoded with AL condition

    __encoding aarch32_BKPT_T1_A
        __instruction_set T16
        __field imm8 16 +: 8
        __opcode '10111110 xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            imm16 = ZeroExtend(imm8, 16);

    __execute
        AArch32.SoftwareBreakpoint(imm16);

__instruction aarch32_SHA1SU1_A
    __encoding aarch32_SHA1SU1_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0011 10x0xxxx'
        __guard TRUE
        __decode
            if !HaveSHA1Ext() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_SHA1SU1_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0011 10x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveSHA1Ext() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        X = Q[d>>1]; Y = Q[m>>1];
        T = X EOR LSR(Y, 32);
        W0 = ROL(T<31:0>, 1);
        W1 = ROL(T<63:32>, 1);
        W2 = ROL(T<95:64>, 1);
        W3 = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);
        Q[d>>1] = W3:W2:W1:W0;

__instruction aarch32_STREXD_A
    __encoding aarch32_STREXD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1010xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);
            if d == 15 || Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t || d == t2 then UNPREDICTABLE;

    __encoding aarch32_STREXD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 0111xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
            if d == 15 || t == 15 || t2 == 15 || n == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13
            if d == n || d == t || d == t2 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        // Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.
        value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];
        if AArch32.ExclusiveMonitorsPass(address,8) then
            MemA[address,8] = value;  R[d] = ZeroExtend('0');
        else
            R[d] = ZeroExtend('1');

__instruction aarch32_VSHRN_A
    __encoding aarch32_VSHRN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1000 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VSHRN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1000 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            result = LSR(Elem[Qin[m>>1],e,2*esize], shift_amount);
            Elem[D[d],e,esize] = result<esize-1:0>;

__instruction aarch32_VTRN_A
    __encoding aarch32_VTRN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0000 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VTRN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0000 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        h = elements DIV 2;
        
        for r = 0 to regs-1
            if d == m then
                D[d+r] = bits(64) UNKNOWN;
            else
                for e = 0 to h-1
                    Elem[D[d+r],2*e+1,esize] = Elem[Din[m+r],2*e,esize];
                    Elem[D[m+r],2*e,esize] = Elem[Din[d+r],2*e+1,esize];

__instruction aarch32_VFMA_A
    __encoding aarch32_VFMA_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x1xxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE; op1_neg = (op == '1');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VFMA_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x10xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE; op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VFMA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x1xxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE; op1_neg = (op == '1');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VFMA_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x10xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE; op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    bits(esize) op1 = Elem[D[n+r],e,esize];
                    if op1_neg then op1 = FPNeg(op1);
                    Elem[D[d+r],e,esize] = FPMulAdd(Elem[D[d+r],e,esize],
                                           op1, Elem[D[m+r],e,esize], StandardFPSCRValue());
        
        else // VFP instruction
            case esize of
                when 16
                    op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;
                    S[d] = Zeros(16) : FPMulAdd(S[d]<15:0>, op16, S[m]<15:0>, FPSCR);
                when 32
                    op32 = if op1_neg then FPNeg(S[n]) else S[n];
                    S[d] = FPMulAdd(S[d], op32, S[m], FPSCR);
                when 64
                    op64 = if op1_neg then FPNeg(D[n]) else D[n];
                    D[d] = FPMulAdd(D[d], op64, D[m], FPSCR);

__instruction aarch32_VACGE_A
    __encoding aarch32_VACGE_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            or_equal = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VACGE_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            or_equal = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = FPAbs(Elem[D[n+r],e,esize]);  op2 = FPAbs(Elem[D[m+r],e,esize]);
                if or_equal then
                    test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());
                else
                    test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());
                Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_MSR_br_AS
    __encoding aarch32_MSR_br_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field R 22 +: 1
        __field M1 16 +: 4
        __field M 8 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0x10xxxx xxxxxx1x 0000xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __decode
            n = UInt(Rn);  write_spsr = (R == '1');
            if n == 15 then UNPREDICTABLE;
            SYSm = M:M1;

    __encoding aarch32_MSR_br_T1_AS
        __instruction_set T32
        __field R 20 +: 1
        __field Rn 16 +: 4
        __field M1 8 +: 4
        __field M 4 +: 1
        __opcode '11110011 100xxxxx 10x0xxxx xx1xxxxx'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            n = UInt(Rn);  write_spsr = (R == '1');
            if n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
            SYSm = M:M1;

    __execute __conditional
        if PSTATE.EL == EL0 then
            UNPREDICTABLE;
        else
            mode = PSTATE.M;
            if write_spsr then
                SPSRaccessValid(SYSm, mode);             // Check for UNPREDICTABLE cases
                case SYSm of
                    when '01110'  SPSR_fiq = R[n];
                    when '10000'  SPSR_irq = R[n];
                    when '10010'  SPSR_svc = R[n];
                    when '10100'  SPSR_abt = R[n];
                    when '10110'  SPSR_und = R[n];
                    when '11100'
                        if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                        SPSR_mon = R[n];
                    when '11110'  SPSR_hyp = R[n];
            else
                BankedRegisterAccessValid(SYSm, mode);  // Check for UNPREDICTABLE cases
                case SYSm of
                    when '00xxx'                       // Access the User mode registers
                        m = UInt(SYSm<2:0>) + 8;
                        Rmode[m,M32_User] = R[n];
                    when '01xxx'                       // Access the FIQ mode registers
                        m = UInt(SYSm<2:0>) + 8;
                        Rmode[m,M32_FIQ] = R[n];
                    when '1000x'                       // Access the IRQ mode registers
                        m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                        Rmode[m,M32_IRQ] = R[n];
                    when '1001x'                       // Access the Supervisor mode registers
                        m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                        Rmode[m,M32_Svc] = R[n];
                    when '1010x'                       // Access the Abort mode registers
                        m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                        Rmode[m,M32_Abort] = R[n];
                    when '1011x'                       // Access the Undefined mode registers
                        m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                        Rmode[m,M32_Undef] = R[n];
                    when '1110x'                       // Access Monitor registers
                        if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                        m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                        Rmode[m,M32_Monitor] = R[n];
                    when '11110'                       // Access ELR_hyp register
                        ELR_hyp = R[n];
                    when '11111'                       // Access SP_hyp register
                        Rmode[13,M32_Hyp] = R[n];

__instruction aarch32_QADD_A
    __encoding aarch32_QADD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0000xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QADD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 1000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (R[d], sat) = SignedSatQ(SInt(R[m]) + SInt(R[n]), 32);
        if sat then
            PSTATE.Q = '1';

__instruction aarch32_TST_r_A
    __encoding aarch32_TST_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0001xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_TST_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rn 16 +: 3
        __opcode '01000010 00xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_TST_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 0001xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] AND shifted;
        PSTATE.N = result<31>;
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged

__instruction aarch32_SHA1SU0_A
    __encoding aarch32_SHA1SU0_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x11xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSHA1Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA1SU0_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x11xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveSHA1Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        op1 = Q[d>>1]; op2 = Q[n>>1]; op3 = Q[m>>1];
        op2 = op2<63:0> : op1<127:64>;
        Q[d>>1] = op1 EOR op2 EOR op3;

__instruction aarch32_UDF_A
    __encoding aarch32_UDF_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm12 8 +: 12
        __field imm4 0 +: 4
        __opcode '11100111 1111xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __decode
            imm32 = ZeroExtend(imm12:imm4, 32);
            // imm32 is for assembly and disassembly only, and is ignored by hardware.

    __encoding aarch32_UDF_T1_A
        __instruction_set T16
        __field imm8 16 +: 8
        __opcode '11011110 xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            imm32 = ZeroExtend(imm8, 32);
            // imm32 is for assembly and disassembly only, and is ignored by hardware.

    __encoding aarch32_UDF_T2_A
        __instruction_set T32
        __field imm4 16 +: 4
        __field imm12 0 +: 12
        __opcode '11110111 1111xxxx 1010xxxx xxxxxxxx'
        __guard TRUE
        __decode
            imm32 = ZeroExtend(imm4:imm12, 32);
            // imm32 is for assembly and disassembly only, and is ignored by hardware.

    __execute __conditional
        UNDEFINED;

__instruction aarch32_BFC_A
    __encoding aarch32_BFC_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field msb 16 +: 5
        __field Rd 12 +: 4
        __field lsb 7 +: 5
        __opcode 'xxxx0111 110xxxxx xxxxxxxx x0011111'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  msbit = UInt(msb);  lsbit = UInt(lsb);
            if d == 15 then UNPREDICTABLE;

    __encoding aarch32_BFC_T1_A
        __instruction_set T32
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field msb 0 +: 5
        __opcode '11110x11 01101111 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            d = UInt(Rd);  msbit = UInt(msb);  lsbit = UInt(imm3:imm2);
            if d == 15 then UNPREDICTABLE;  // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        if msbit >= lsbit then
            R[d]<msbit:lsbit> = Replicate('0', msbit-lsbit+1);
            // Other bits of R[d] are unchanged
        else
            UNPREDICTABLE;

__instruction aarch32_LDAEXD_A
    __encoding aarch32_LDAEXD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1011xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  t2 = t + 1;  n = UInt(Rn);
            if Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAEXD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1111xxxx'
        __guard TRUE
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
            if t == 15 || t2 == 15 || t == t2 || n == 15 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        AArch32.SetExclusiveMonitors(address, 8);
        value = MemO[address, 8];
        // Extract words from 64-bit loaded value such that R[t] is
        // loaded from address and R[t2] from address+4.
        R[t]  = if BigEndian() then value<63:32> else value<31:0>;
        R[t2] = if BigEndian() then value<31:0>  else value<63:32>;

__instruction aarch32_STRB_i_A
    __encoding aarch32_STRB_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x1x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "STRBT";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STRB_i_T1_A
        __instruction_set T16
        __field imm5 22 +: 5
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '01110xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_STRB_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1000xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_STRB_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0000xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '1' && U == '1' && W == '0' then SEE "STRBT";
            if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            MemU[address,1] = R[t]<7:0>;
            if wback then R[n] = offset_addr;
        else
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            MemU[address,1] = R[t]<7:0>;
            if wback then R[n] = offset_addr;

__instruction aarch32_VLD1_a_A
    __encoding aarch32_VLD1_a_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' || (size == '00' && a == '1') then UNDEFINED;
            ebytes = 1 << UInt(size);  regs = if T == '0' then 1 else 2;
            alignment = if a == '0' then 1 else ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_a_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' || (size == '00' && a == '1') then UNDEFINED;
            ebytes = 1 << UInt(size);  regs = if T == '0' then 1 else 2;
            alignment = if a == '0' then 1 else ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = FALSE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        bits(64) replicated_element = Replicate(MemU[address,ebytes]);
        for r = 0 to regs-1
            D[d+r] = replicated_element;
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + ebytes;

__instruction aarch32_VST1_1_A
    __encoding aarch32_VST1_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  alignment = 1;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VST1_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VST1_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx1000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<2> != '0' then UNDEFINED;
            if index_align<1:0> != '00' && index_align<1:0> != '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            alignment = if index_align<1:0> == '00' then 1 else 4;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VST1_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  alignment = 1;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VST1_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VST1_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx1000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<2> != '0' then UNDEFINED;
            if index_align<1:0> != '00' && index_align<1:0> != '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            alignment = if index_align<1:0> == '00' then 1 else 4;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = TRUE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        MemU[address,ebytes] = Elem[D[d],index];
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + ebytes;

__instruction aarch32_VRINTA_asimd_A
    __encoding aarch32_VRINTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0101 0xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0101 0xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_SHSAX_A
    __encoding aarch32_SHSAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHSAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum  = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);
        diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);
        R[d]<15:0>  = sum<16:1>;
        R[d]<31:16> = diff<16:1>;

__instruction aarch32_RSB_r_A
    __encoding aarch32_RSB_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 011xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_RSB_r_T1_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 110xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, '1');
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VCVTA_asimd_A
    __encoding aarch32_VCVTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx0011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx0011 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        CheckAdvSIMDEnabled();
        bits(esize) result;
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,
                                                 StandardFPSCRValue(), rounding);

__instruction aarch32_STRT_A
    __encoding aarch32_STRT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0100 x010xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
            if n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_STRT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 x010xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_STRT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0100xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if postindex then R[n] else offset_addr;
        if t == 15 then  // Only possible for encodings A1 and A2
            data = PCStoreValue();
        else
            data = R[t];
        MemU_unpriv[address,4] = data;
        if postindex then R[n] = offset_addr;

__instruction aarch32_VST3_1_A
    __encoding aarch32_VST3_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1:0> != '00' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1:0> != '00' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];
        MemU[address,         ebytes] = Elem[D[d], index];
        MemU[address+ebytes,  ebytes] = Elem[D[d2],index];
        MemU[address+2*ebytes,ebytes] = Elem[D[d3],index];
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 3*ebytes;

__instruction aarch32_VLD3_a_A
    __encoding aarch32_VLD3_a_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || a == '1' then UNDEFINED;
            ebytes = 1 << UInt(size);
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_a_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || a == '1' then UNDEFINED;
            ebytes = 1 << UInt(size);
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];
        D[d] = Replicate(MemU[address,ebytes]);
        D[d2] = Replicate(MemU[address+ebytes,ebytes]);
        D[d3] = Replicate(MemU[address+2*ebytes,ebytes]);
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 3*ebytes;

__instruction aarch32_QSUB8_A
    __encoding aarch32_QSUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QSUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);
        diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);
        diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);
        diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);
        R[d]<7:0>   = SignedSat(diff1, 8);
        R[d]<15:8>  = SignedSat(diff2, 8);
        R[d]<23:16> = SignedSat(diff3, 8);
        R[d]<31:24> = SignedSat(diff4, 8);

__instruction aarch32_VRINTA_vfp_A
    __encoding aarch32_VRINTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111000 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111000 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_SHA1C_A
    __encoding aarch32_SHA1C_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x00xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSHA1Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA1C_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x00xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveSHA1Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        X = Q[d>>1];
        Y = Q[n>>1]<31:0>; // Note: 32 bits wide
        W = Q[m>>1];
        for e = 0 to 3
            t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);
            Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
            X<63:32> = ROL(X<63:32>, 30);
            <Y, X> = ROL(Y:X, 32);
        Q[d>>1] = X;

__instruction aarch32_EOR_rr_A
    __encoding aarch32_EOR_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 001xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] EOR shifted;
        R[d] = result;
        if setflags then
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_LDRH_i_A
    __encoding aarch32_LDRH_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x1xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE "LDRH (literal)";
            if P == '0' && W == '1' then SEE "LDRHT";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRH_i_T1_A
        __instruction_set T16
        __field imm5 22 +: 5
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '10001xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'0', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_LDRH_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1011xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE "PLD (immediate)";
            if Rn == '1111' then SEE "LDRH (literal)";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_LDRH_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0011xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "LDRH (literal)";
            if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE "PLDW (immediate)";
            if P == '1' && U == '1' && W == '0' then SEE "LDRHT";
            if P == '0' && W == '0' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            data = MemU[address,2];
            if wback then R[n] = offset_addr;
            R[t] = ZeroExtend(data, 32);
        else
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            data = MemU[address,2];
            if wback then R[n] = offset_addr;
            R[t] = ZeroExtend(data, 32);

__instruction aarch32_VMLA_s_A
    __encoding aarch32_VMLA_s_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0110 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMLA_s_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0110 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                if floating_point then
                    fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));
                    Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());
                else
                    addend = if add then op1val*op2val else -op1val*op2val;
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                    else
                        Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_VQNEG_A
    __encoding aarch32_VQNEG_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0111 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQNEG_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0111 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                result = -SInt(Elem[D[m+r],e,esize]);
                (Elem[D[d+r],e,esize], sat) = SignedSatQ(result, esize);
                if sat then FPSCR.QC = '1';

__instruction aarch32_QASX_A
    __encoding aarch32_QASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);
        sum  = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);
        R[d]<15:0>  = SignedSat(diff, 16);
        R[d]<31:16> = SignedSat(sum, 16);

__instruction aarch32_PUSH_A
    __encoding aarch32_PUSH_T1_A
        __instruction_set T16
        __field M 24 +: 1
        __field register_list 16 +: 8
        __opcode '1011010x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            registers = '0':M:'000000':register_list;  UnalignedAllowed = FALSE;
            if BitCount(registers) < 1 then UNPREDICTABLE;

    __execute __conditional
        address = SP - 4*BitCount(registers);
        for i = 0 to 14
            if registers<i> == '1' then
                if i == 13 && i != LowestSetBit(registers) then  // Only possible for encoding A1
                    MemA[address,4] = bits(32) UNKNOWN;
                else
                    if UnalignedAllowed then
                        MemU[address,4] = R[i];
                    else
                        MemA[address,4] = R[i];
                address = address + 4;
        if registers<15> == '1' then  // Only possible for encoding A1 or A2
            if UnalignedAllowed then
                MemU[address,4] = PCStoreValue();
            else
                MemA[address,4] = PCStoreValue();
        SP = SP - 4*BitCount(registers);

__instruction aarch32_SUB_SP_i_A
    __encoding aarch32_SUB_SP_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 010x1101 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_SUB_SP_i_T1_A
        __instruction_set T16
        __field imm7 16 +: 7
        __opcode '10110000 1xxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = 13;  setflags = FALSE;  imm32 = ZeroExtend(imm7:'00', 32);

    __encoding aarch32_SUB_SP_i_T2_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 101x1101 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE "CMP (immediate)";
            d = UInt(Rd);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if d == 15 && !setflags then UNPREDICTABLE;

    __encoding aarch32_SUB_SP_i_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 10101101 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
            if d == 15 then UNPREDICTABLE;

    __execute __conditional
        (result, nzcv) = AddWithCarry(SP, NOT(imm32), '1');
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VMUL_i_A
    __encoding aarch32_VMUL_i_T1A1_A
        __instruction_set A32
        __field op 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx1001 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' || (op == '1' && size != '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            polynomial = (op == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMUL_i_T1A1_A
        __instruction_set T32
        __field op 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx1001 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' || (op == '1' && size != '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            polynomial = (op == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                op2 = Elem[Din[m+r],e,esize];  op2val = Int(op2, unsigned);
                if polynomial then
                    product = PolynomialMult(op1,op2);
                else
                    product = (op1val*op2val)<2*esize-1:0>;
                if long_destination then
                    Elem[Q[d>>1],e,2*esize] = product;
                else
                    Elem[D[d+r],e,esize] = product<esize-1:0>;

__instruction aarch32_USUB16_A
    __encoding aarch32_USUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_USUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);
        diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);
        R[d]<15:0>  = diff1<15:0>;
        R[d]<31:16> = diff2<15:0>;
        PSTATE.GE<1:0> = if diff1 >= 0 then '11' else '00';
        PSTATE.GE<3:2> = if diff2 >= 0 then '11' else '00';

__instruction aarch32_POP_A
    __encoding aarch32_POP_T1_A
        __instruction_set T16
        __field P 24 +: 1
        __field register_list 16 +: 8
        __opcode '1011110x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            registers = P:'0000000':register_list;   UnalignedAllowed = FALSE;
            if BitCount(registers) < 1 then UNPREDICTABLE;
            if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        address = SP;
        for i = 0 to 14
            if registers<i> == '1' then
                R[i] = if UnalignedAllowed then MemU[address,4] else MemA[address,4];
                address = address + 4;
        if registers<15> == '1' then
            if UnalignedAllowed then
                if address<1:0> == '00' then
                    LoadWritePC(MemU[address,4]);
                else
                    UNPREDICTABLE;
            else
                LoadWritePC(MemA[address,4]);
        if registers<13> == '0' then SP = SP + 4*BitCount(registers);
        if registers<13> == '1' then SP = bits(32) UNKNOWN;

__instruction aarch32_UDIV_A
    __encoding aarch32_UDIV_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0011xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE;

    __encoding aarch32_UDIV_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1011xxxx xxxxxxxx 1111xxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        if UInt(R[m]) == 0 then
            result = 0;
        else
            result = RoundTowardsZero(Real(UInt(R[n])) / Real(UInt(R[m])));
        R[d] = result<31:0>;

__instruction aarch32_VSWP_A
    __encoding aarch32_VSWP_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x110010 xxxx0000 0xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSWP_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x110010 xxxx0000 0xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            if d == m then
                D[d+r] = bits(64) UNKNOWN;
            else
                D[d+r] = Din[m+r];
                D[m+r] = Din[d+r];

__instruction aarch32_LDRBT_A
    __encoding aarch32_LDRBT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0100 x111xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_LDRBT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 x111xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRBT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0001xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            if Rn == '1111' then SEE "LDRB (literal)";
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if postindex then R[n] else offset_addr;
        R[t] = ZeroExtend(MemU_unpriv[address,1],32);
        if postindex then R[n] = offset_addr;

__instruction aarch32_VHADD_A
    __encoding aarch32_VHADD_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            add = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VHADD_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            add = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Int(Elem[D[n+r],e,esize], unsigned);
                op2 = Int(Elem[D[m+r],e,esize], unsigned);
                result = if add then op1+op2 else op1-op2;
                Elem[D[d+r],e,esize] = result<esize:1>;

__instruction aarch32_VFNMA_A
    __encoding aarch32_VFNMA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x01xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VFNMA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x01xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;
                S[d] = Zeros(16) : FPMulAdd(FPNeg(S[d]<15:0>), op16, S[m]<15:0>, FPSCR);
            when 32
                op32 = if op1_neg then FPNeg(S[n]) else S[n];
                S[d] = FPMulAdd(FPNeg(S[d]), op32, S[m], FPSCR);
            when 64
                op64 = if op1_neg then FPNeg(D[n]) else D[n];
                D[d] = FPMulAdd(FPNeg(D[d]), op64, D[m], FPSCR);

__instruction aarch32_VCMP_A
    __encoding aarch32_VCMP_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110100 xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VCMP_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __opcode 'xxxx1110 1x110101 xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D);
                when '10' esize = 32; d = UInt(Vd:D);
                when '11' esize = 64; d = UInt(D:Vd);

    __encoding aarch32_VCMP_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110100 xxxx10xx 11x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VCMP_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __opcode '11101110 1x110101 xxxx10xx 11x0xxxx'
        __guard TRUE
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D);
                when '10' esize = 32; d = UInt(Vd:D);
                when '11' esize = 64; d = UInt(D:Vd);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        bits(4) nzcv;
        case esize of
            when 16
                bits(16) op16 = if with_zero then FPZero('0') else S[m]<15:0>;
                nzcv = FPCompare(S[d]<15:0>, op16, quiet_nan_exc, FPSCR);
            when 32
                bits(32) op32 = if with_zero then FPZero('0') else S[m];
                nzcv = FPCompare(S[d], op32, quiet_nan_exc, FPSCR);
            when 64
                bits(64) op64 = if with_zero then FPZero('0') else D[m];
                nzcv = FPCompare(D[d], op64, quiet_nan_exc, FPSCR);
        
        FPSCR.<N,Z,C,V> = nzcv;

__instruction aarch32_VUZP_A
    __encoding aarch32_VUZP_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0001 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || (Q == '0' && size == '10') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            quadword_operation = (Q == '1');  esize = 8 << UInt(size);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VUZP_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0001 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || (Q == '0' && size == '10') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            quadword_operation = (Q == '1');  esize = 8 << UInt(size);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        if quadword_operation then
            if d == m then
                Q[d>>1] = bits(128) UNKNOWN;  Q[m>>1] = bits(128) UNKNOWN;
            else
                zipped_q = Q[m>>1]:Q[d>>1];
                for e = 0 to (128 DIV esize) - 1
                    Elem[Q[d>>1],e,esize] = Elem[zipped_q,2*e,esize];
                    Elem[Q[m>>1],e,esize] = Elem[zipped_q,2*e+1,esize];
        else
            if d == m then
                D[d] = bits(64) UNKNOWN;  D[m] = bits(64) UNKNOWN;
            else
                zipped_d = D[m]:D[d];
                for e = 0 to (64 DIV esize) - 1
                    Elem[D[d],e,esize] = Elem[zipped_d,2*e,esize];
                    Elem[D[m],e,esize] = Elem[zipped_d,2*e+1,esize];

__instruction aarch32_IT_A
    __encoding aarch32_IT_T1_A
        __instruction_set T16
        __field firstcond 20 +: 4
        __field mask 16 +: 4
        __opcode '10111111 xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            if mask == '0000' then SEE "Related encodings";
            if firstcond == '1111' || (firstcond == '1110' && BitCount(mask) != 1) then UNPREDICTABLE;
            if InITBlock() then UNPREDICTABLE;

    __execute
        AArch32.CheckITEnabled(mask);
        PSTATE.IT<7:0> = firstcond:mask;
        ShouldAdvanceIT = FALSE;

__instruction aarch32_SMLAD_A
    __encoding aarch32_SMLAD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0000xxxx xxxxxxxx 00x1xxxx'
        __guard cond != '1111'
        __decode
            if Ra == '1111' then SEE "SMUAD";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMLAD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0010xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE "SMUAD";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand2 = if m_swap then ROR(R[m],16) else R[m];
        product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
        product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
        result = product1 + product2 + SInt(R[a]);
        R[d] = result<31:0>;
        if result != SInt(result<31:0>) then  // Signed overflow
            PSTATE.Q = '1';

__instruction aarch32_LDAB_A
    __encoding aarch32_LDAB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1101xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1000xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        R[t] = ZeroExtend(MemO[address, 1], 32);

__instruction aarch32_LDRD_r_A
    __encoding aarch32_LDRD_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x0xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rt<0> == '1' then UNPREDICTABLE;
            t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if P == '0' && W == '1' then UNPREDICTABLE;
            if t2 == 15 || m == 15 || m == t || m == t2 then UNPREDICTABLE;
            if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;

    __execute __conditional
        offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);
        address = if index then offset_addr else R[n];
        if address == Align(address, 8) then
            data = MemA[address,8];
            if BigEndian() then
                R[t] = data<63:32>;
                R[t2] = data<31:0>;
            else
                R[t] = data<31:0>;
                R[t2] = data<63:32>;
        else
            R[t] = MemA[address,4];
            R[t2] = MemA[address+4,4];
        
        if wback then R[n] = offset_addr;

__instruction aarch32_VEXT_A
    __encoding aarch32_VEXT_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field imm4 8 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1x11xxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if Q == '0' && imm4<3> == '1' then UNDEFINED;
            quadword_operation = (Q == '1');  position = 8 * UInt(imm4);
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VEXT_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field imm4 8 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1x11xxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if Q == '0' && imm4<3> == '1' then UNDEFINED;
            quadword_operation = (Q == '1');  position = 8 * UInt(imm4);
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        if quadword_operation then
            Q[d>>1] = (Q[m>>1]:Q[n>>1])<position+127:position>;
        else
            D[d] = (D[m]:D[n])<position+63:position>;

__instruction aarch32_VLD4_a_A
    __encoding aarch32_VLD4_a_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' && a == '0' then UNDEFINED;
            if size == '11' then
                ebytes = 4;  alignment = 16;
            else
                ebytes = 1 << UInt(size);
                if size == '10' then
                    alignment = if a == '0' then 1 else 8;
                else
                    alignment = if a == '0' then 1 else 4*ebytes;
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_a_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' && a == '0' then UNDEFINED;
            if size == '11' then
                ebytes = 4;  alignment = 16;
            else
                ebytes = 1 << UInt(size);
                if size == '10' then
                    alignment = if a == '0' then 1 else 8;
                else
                    alignment = if a == '0' then 1 else 4*ebytes;
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = FALSE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        D[d] = Replicate(MemU[address,ebytes]);
        D[d2] = Replicate(MemU[address+ebytes,ebytes]);
        D[d3] = Replicate(MemU[address+2*ebytes,ebytes]);
        D[d4] = Replicate(MemU[address+3*ebytes,ebytes]);
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 4*ebytes;

__instruction aarch32_RSC_rr_A
    __encoding aarch32_RSC_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 111xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, PSTATE.C);
        R[d] = result;
        if setflags then
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VST4_1_A
    __encoding aarch32_VST4_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '00' then SEE "Related encodings";
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '01' then SEE "Related encodings";
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx1011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '00' then SEE "Related encodings";
            if index_align<1:0> == '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<1:0> == '00' then 1 else 4 << UInt(index_align<1:0>);
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '00' then SEE "Related encodings";
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '01' then SEE "Related encodings";
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx1011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '00' then SEE "Related encodings";
            if index_align<1:0> == '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<1:0> == '00' then 1 else 4 << UInt(index_align<1:0>);
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = TRUE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        MemU[address,         ebytes] = Elem[D[d], index];
        MemU[address+ebytes,  ebytes] = Elem[D[d2],index];
        MemU[address+2*ebytes,ebytes] = Elem[D[d3],index];
        MemU[address+3*ebytes,ebytes] = Elem[D[d4],index];
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 4*ebytes;

__instruction aarch32_VSUBL_A
    __encoding aarch32_VSUBL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0011 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VSUBL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0011 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            if is_vsubw then
                op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
            else
                op1 = Int(Elem[Din[n],e,esize], unsigned);
            result = op1 - Int(Elem[Din[m],e,esize], unsigned);
            Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_B_A
    __encoding aarch32_B_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm24 0 +: 24
        __opcode 'xxxx1010 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            imm32 = SignExtend(imm24:'00', 32);

    __encoding aarch32_B_T1_A
        __instruction_set T16
        __field cond 24 +: 4
        __field imm8 16 +: 8
        __opcode '1101xxxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            if cond == '1110' then SEE "UDF";
            if cond == '1111' then SEE "SVC";
            imm32 = SignExtend(imm8:'0', 32);
            if InITBlock() then UNPREDICTABLE;

    __encoding aarch32_B_T2_A
        __instruction_set T16
        __field imm11 16 +: 11
        __opcode '11100xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            imm32 = SignExtend(imm11:'0', 32);
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_B_T3_A
        __instruction_set T32
        __field S 26 +: 1
        __field cond 22 +: 4
        __field imm6 16 +: 6
        __field J1 13 +: 1
        __field J2 11 +: 1
        __field imm11 0 +: 11
        __opcode '11110xxx xxxxxxxx 10x0xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if cond<3:1> == '111' then SEE "Related encodings";
            imm32 = SignExtend(S:J2:J1:imm6:imm11:'0', 32);
            if InITBlock() then UNPREDICTABLE;

    __encoding aarch32_B_T4_A
        __instruction_set T32
        __field S 26 +: 1
        __field imm10 16 +: 10
        __field J1 13 +: 1
        __field J2 11 +: 1
        __field imm11 0 +: 11
        __opcode '11110xxx xxxxxxxx 10x1xxxx xxxxxxxx'
        __guard TRUE
        __decode
            I1 = NOT(J1 EOR S);  I2 = NOT(J2 EOR S);  imm32 = SignExtend(S:I1:I2:imm10:imm11:'0', 32);
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        BranchWritePC(PC + imm32, BranchType_DIR);

__instruction aarch32_SMUSD_A
    __encoding aarch32_SMUSD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0000xxxx 1111xxxx 01x1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMUSD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0100xxxx 1111xxxx 000xxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand2 = if m_swap then ROR(R[m],16) else R[m];
        product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
        product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
        result = product1 - product2;
        R[d] = result<31:0>;
        // Signed overflow cannot occur

__instruction aarch32_VSUB_f_A
    __encoding aarch32_VSUB_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x1xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSUB_f_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x11xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VSUB_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x1xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSUB_f_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x11xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then  // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = FPSub(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
        else             // VFP instruction
            case esize of
                when 16
                    S[d] = Zeros(16) : FPSub(S[n]<15:0>, S[m]<15:0>, FPSCR);
                when 32
                    S[d] = FPSub(S[n], S[m], FPSCR);
                when 64
                    D[d] = FPSub(D[n], D[m], FPSCR);

__instruction aarch32_ADD_SP_i_A
    __encoding aarch32_ADD_SP_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 100x1101 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_ADD_SP_i_T1_A
        __instruction_set T16
        __field Rd 24 +: 3
        __field imm8 16 +: 8
        __opcode '10101xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(imm8:'00', 32);

    __encoding aarch32_ADD_SP_i_T2_A
        __instruction_set T16
        __field imm7 16 +: 7
        __opcode '10110000 0xxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = 13;  setflags = FALSE;  imm32 = ZeroExtend(imm7:'00', 32);

    __encoding aarch32_ADD_SP_i_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 000x1101 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE "CMN (immediate)";
            d = UInt(Rd);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if d == 15 && !setflags then UNPREDICTABLE;

    __encoding aarch32_ADD_SP_i_T4_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 00001101 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
            if d == 15 then UNPREDICTABLE;

    __execute __conditional
        (result, nzcv) = AddWithCarry(SP, imm32, '0');
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SBFX_A
    __encoding aarch32_SBFX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field widthm1 16 +: 5
        __field Rd 12 +: 4
        __field lsb 7 +: 5
        __field Rn 0 +: 4
        __opcode 'xxxx0111 101xxxxx xxxxxxxx x101xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);
            lsbit = UInt(lsb);  widthminus1 = UInt(widthm1);
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_SBFX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field widthm1 0 +: 5
        __opcode '11110x11 0100xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);
            lsbit = UInt(imm3:imm2);  widthminus1 = UInt(widthm1);
            if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        msbit = lsbit + widthminus1;
        if msbit <= 31 then
            R[d] = SignExtend(R[n]<msbit:lsbit>, 32);
        else
            UNPREDICTABLE;

__instruction aarch32_STM_u_AS
    __encoding aarch32_STM_u_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx100x x1x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 21 == '0'
        __decode
            n = UInt(Rn);  registers = register_list;  increment = (U == '1');  wordhigher = (P == U);
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __execute __conditional
        if PSTATE.EL == EL2 then
            UNDEFINED;
        elsif PSTATE.M IN {M32_User,M32_System} then
            UNPREDICTABLE;
        else
            length = 4*BitCount(registers);
            address = if increment then R[n] else R[n]-length;
            if wordhigher then address = address+4;
            for i = 0 to 14
                if registers<i> == '1' then  // Store User mode register
                    MemA[address,4] = Rmode[i, M32_User];
                    address = address + 4;
            if registers<15> == '1' then
                MemA[address,4] = PCStoreValue();

__instruction aarch32_VCVT_is_A
    __encoding aarch32_VCVT_is_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx011x xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            to_integer = (op<1> == '1');  unsigned = (op<0> == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVT_is_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx011x xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            to_integer = (op<1> == '1');  unsigned = (op<0> == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        bits(esize) result;
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                if to_integer then
                    result = FPToFixed(op1, 0, unsigned, StandardFPSCRValue(), FPRounding_ZERO);
                else
                    result = FixedToFP(op1, 0, unsigned, StandardFPSCRValue(), FPRounding_TIEEVEN);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_VLD2_1_A
    __encoding aarch32_VLD2_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD2 (single 2-element structure to all lanes)";
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD2 (single 2-element structure to all lanes)";
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD2 (single 2-element structure to all lanes)";
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD2 (single 2-element structure to all lanes)";
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD2 (single 2-element structure to all lanes)";
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD2 (single 2-element structure to all lanes)";
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = FALSE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        Elem[D[d], index] = MemU[address,ebytes];
        Elem[D[d2],index] = MemU[address+ebytes,ebytes];
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 2*ebytes;

__instruction aarch32_VFMAL_i_A
    __encoding aarch32_VFMAL_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field S 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0x00xxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            
            integer d = UInt(D:Vd);
            integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
            integer m = if Q == '1' then UInt(Vm<2:0>) else UInt(Vm<2:0>:M);
            
            integer index = if Q == '1' then UInt(M:Vm<3>) else UInt(Vm<3>);
            integer esize = 32;
            integer regs = if Q=='1' then 2 else 1;
            integer datasize = if Q=='1' then 64 else 32;
            boolean sub_op = S=='1';

    __encoding aarch32_VFMAL_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field S 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0x00xxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            
            integer d = UInt(D:Vd);
            integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
            integer m = if Q == '1' then UInt(Vm<2:0>) else UInt(Vm<2:0>:M);
            
            integer index = if Q == '1' then UInt(M:Vm<3>) else UInt(Vm<3>);
            integer esize = 32;
            integer regs = if Q=='1' then 2 else 1;
            integer datasize = if Q=='1' then 64 else 32;
            boolean sub_op = S=='1';

    __execute
        CheckAdvSIMDEnabled();
        bits(datasize) operand1 ;
        bits(datasize) operand2 ;
        bits(64) operand3;
        bits(64) result;
        bits(esize DIV 2) element1;
        bits(esize DIV 2) element2;
        
        if Q=='0' then
            operand1 = S[n]<datasize-1:0>;
            operand2 = S[m]<datasize-1:0>;
        else
            operand1 = D[n]<datasize-1:0>;
            operand2 = D[m]<datasize-1:0>;
        element2 = Elem[operand2, index, esize DIV 2];
        for r = 0 to regs-1
            operand3 = D[d+r];
            for e = 0 to 1
                element1 = Elem[operand1, 2*r+e, esize DIV 2];
                if sub_op then element1 = FPNeg(element1);
                Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, StandardFPSCRValue());
            D[d+r] = result;

__instruction aarch32_LDRSH_r_A
    __encoding aarch32_LDRSH_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x1xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if P == '0' && W == '1' then SEE "LDRSHT";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = (SRType_LSL, 0);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRSH_r_T1_A
        __instruction_set T16
        __field Rm 22 +: 3
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '0101111x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_LDRSH_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0011xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "LDRSH (literal)";
            if Rt == '1111' then SEE "Related instructions";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if index then offset_addr else R[n];
        data = MemU[address,2];
        if wback then R[n] = offset_addr;
        R[t] = SignExtend(data, 32);

__instruction aarch32_SBC_i_A
    __encoding aarch32_SBC_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 110xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_SBC_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 011xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (result, nzcv) = AddWithCarry(R[n], NOT(imm32), PSTATE.C);
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SUB_r_A
    __encoding aarch32_SUB_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 010xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1101' then SEE "SUB (SP minus register)";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_SUB_r_T1_A
        __instruction_set T16
        __field Rm 22 +: 3
        __field Rn 19 +: 3
        __field Rd 16 +: 3
        __opcode '0001101x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_SUB_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 101xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE "CMP (register)";
            if Rn == '1101' then SEE "SUB (SP minus register)";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SMMLS_A
    __encoding aarch32_SMMLS_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field R 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0101xxxx xxxxxxxx 11x1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

    __encoding aarch32_SMMLS_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field R 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0110xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = (SInt(R[a]) << 32) - SInt(R[n]) * SInt(R[m]);
        if round then result = result + 0x80000000;
        R[d] = result<63:32>;

__instruction aarch32_UHADD16_A
    __encoding aarch32_UHADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);
        sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);
        R[d]<15:0>  = sum1<16:1>;
        R[d]<31:16> = sum2<16:1>;

__instruction aarch32_VSHL_r_A
    __encoding aarch32_VSHL_r_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0100 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSHL_r_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0100 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                shift = SInt(Elem[D[n+r],e,esize]<7:0>);
                result = Int(Elem[D[m+r],e,esize], unsigned) << shift;
                Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_PKH_A
    __encoding aarch32_PKH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field tb 6 +: 1
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1000xxxx xxxxxxxx xx01xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  tbform = (tb == '1');
            (shift_t, shift_n) = DecodeImmShift(tb:'0', imm5);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_PKH_T1_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field tb 5 +: 1
        __field T 4 +: 1
        __field Rm 0 +: 4
        __opcode '11101010 1100xxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if S == '1' || T == '1' then UNDEFINED;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  tbform = (tb == '1');
            (shift_t, shift_n) = DecodeImmShift(tb:'0', imm3:imm2);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand2 = Shift(R[m], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored
        R[d]<15:0>  = if tbform then operand2<15:0> else R[n]<15:0>;
        R[d]<31:16> = if tbform then R[n]<31:16>    else operand2<31:16>;

__instruction aarch32_CMN_r_A
    __encoding aarch32_CMN_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0111xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_CMN_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rn 16 +: 3
        __opcode '01000010 11xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_CMN_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 0001xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], shifted, '0');
        PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VSHLL_A
    __encoding aarch32_VSHLL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1010 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
            if shift_amount == 0 then SEE "VMOVL";
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VSHLL_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0011 00x0xxxx'
        __guard TRUE
        __decode
            if size == '11' || Vd<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;  shift_amount = esize;
            unsigned = FALSE;  // Or TRUE without change of functionality
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VSHLL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1010 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
            if shift_amount == 0 then SEE "VMOVL";
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VSHLL_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0011 00x0xxxx'
        __guard TRUE
        __decode
            if size == '11' || Vd<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;  shift_amount = esize;
            unsigned = FALSE;  // Or TRUE without change of functionality
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            result = Int(Elem[Din[m],e,esize], unsigned) << shift_amount;
            Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_BLX_r_A
    __encoding aarch32_BLX_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            m = UInt(Rm);
            if m == 15 then UNPREDICTABLE;

    __encoding aarch32_BLX_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 4
        __opcode '01000111 1xxxxxxx 00000000 00000000'
        __guard TRUE
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            m = UInt(Rm);
            if m == 15 then UNPREDICTABLE;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        target = R[m];
        if CurrentInstrSet() == InstrSet_A32 then
            next_instr_addr = PC - 4;
            LR = next_instr_addr;
        else
            next_instr_addr = PC - 2;
            LR = next_instr_addr<31:1> : '1';
        BXWritePC(target, BranchType_INDCALL);

__instruction aarch32_REV_A
    __encoding aarch32_REV_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1011xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  m = UInt(Rm);
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_REV_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rd 16 +: 3
        __opcode '10111010 00xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);

    __encoding aarch32_REV_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 1000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
            if m != n || d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        bits(32) result;
        result<31:24> = R[m]<7:0>;
        result<23:16> = R[m]<15:8>;
        result<15:8>  = R[m]<23:16>;
        result<7:0>   = R[m]<31:24>;
        R[d] = result;

__instruction aarch32_SXTAB16_A
    __encoding aarch32_SXTAB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1000xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE "SXTB16";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTAB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0010xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE "SXTB16";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d]<15:0>  = R[n]<15:0> + SignExtend(rotated<7:0>, 16);
        R[d]<31:16> = R[n]<31:16> + SignExtend(rotated<23:16>, 16);

__instruction aarch32_VMAX_i_A
    __encoding aarch32_VMAX_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAX_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Int(Elem[D[n+r],e,esize], unsigned);
                op2 = Int(Elem[D[m+r],e,esize], unsigned);
                result = if maximum then Max(op1,op2) else Min(op1,op2);
                Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_LDM_e_AS
    __encoding aarch32_LDM_e_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 15
        __opcode 'xxxx100x x1x1xxxx 1xxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;
            wback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);
            if n == 15 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;

    __execute __conditional
        if PSTATE.EL == EL2 then
            UNDEFINED;
        elsif PSTATE.M IN {M32_User,M32_System} then
            UNPREDICTABLE;                        // UNDEFINED or NOP
        else
            length = 4*BitCount(registers) + 4;
            address = if increment then R[n] else R[n]-length;
            if wordhigher then address = address+4;
        
            for i = 0 to 14
                if registers<i> == '1' then
                    R[i] = MemA[address,4];  address = address + 4;
            new_pc_value = MemA[address,4];
        
            if wback && registers<n> == '0' then R[n] = if increment then R[n]+length else R[n]-length;
            if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;
        
            AArch32.ExceptionReturn(new_pc_value, SPSR[]);

__instruction aarch32_VAND_r_A
    __encoding aarch32_VAND_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x00xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VAND_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x00xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            D[d+r] = D[n+r] AND D[m+r];

__instruction aarch32_SETEND_A
    __encoding aarch32_SETEND_A1_A
        __instruction_set A32
        __field E 9 +: 1
        __opcode '11110001 0000xxx1 xxxxxxxx 0000xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            set_bigend = (E == '1');

    __encoding aarch32_SETEND_T1_A
        __instruction_set T16
        __field E 19 +: 1
        __opcode '10110110 010xxxxx 00000000 00000000'
        __guard TRUE
        __unpredictable_unless 20 == '1'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            set_bigend = (E == '1');
            if InITBlock() then UNPREDICTABLE;

    __execute
        AArch32.CheckSETENDEnabled();
        PSTATE.E = if set_bigend then '1' else '0';

__instruction aarch32_MOV_i_A
    __encoding aarch32_MOV_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 101xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  setflags = (S == '1');  (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_MOV_i_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm4 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0000xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(imm4:imm12, 32);
            if d == 15 then UNPREDICTABLE;

    __encoding aarch32_MOV_i_T1_A
        __instruction_set T16
        __field Rd 24 +: 3
        __field imm8 16 +: 8
        __opcode '00100xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = !InITBlock();  imm32 = ZeroExtend(imm8, 32);  carry = PSTATE.C;

    __encoding aarch32_MOV_i_T2_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 010x1111 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = (S == '1');  (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_MOV_i_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm4 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 0100xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(imm4:i:imm3:imm8, 32);
            if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = imm32;
        if d == 15 then          // Can only occur for encoding A1
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_VRSHL_A
    __encoding aarch32_VRSHL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRSHL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                shift = SInt(Elem[D[n+r],e,esize]<7:0>);
                round_const = 1 << (-shift-1); // 0 for left shift, 2^(n-1) for right shift
                result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) << shift;
                Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_UQADD8_A
    __encoding aarch32_UQADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);
        sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);
        sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);
        sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);
        R[d]<7:0>   = UnsignedSat(sum1, 8);
        R[d]<15:8>  = UnsignedSat(sum2, 8);
        R[d]<23:16> = UnsignedSat(sum3, 8);
        R[d]<31:24> = UnsignedSat(sum4, 8);

__instruction aarch32_VRADDHN_A
    __encoding aarch32_VRADDHN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1xxxxxxx xxxx0100 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VRADDHN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1xxxxxxx xxxx0100 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        round_const = 1 << (esize-1);
        for e = 0 to elements-1
            result = Elem[Qin[n>>1],e,2*esize] + Elem[Qin[m>>1],e,2*esize] + round_const;
            Elem[D[d],e,esize] = result<2*esize-1:esize>;

__instruction aarch32_LDMDA_A
    __encoding aarch32_LDMDA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1000 00x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;

    __execute __conditional
        address = R[n] - 4*BitCount(registers) + 4;
        for i = 0 to 14
            if registers<i> == '1' then
                R[i] = MemA[address,4];  address = address + 4;
        if registers<15> == '1' then
            LoadWritePC(MemA[address,4]);
        if wback && registers<n> == '0' then R[n] = R[n] - 4*BitCount(registers);
        if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;

__instruction aarch32_BIC_i_A
    __encoding aarch32_BIC_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 110xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_BIC_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 001xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if d == 15 || n == 15 then UNPREDICTABLE;  // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = R[n] AND NOT(imm32);
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_PLD_i_A
    __encoding aarch32_PLD_i_A1_A
        __instruction_set A32
        __field U 23 +: 1
        __field R 22 +: 1
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode '11110101 xx01xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            if Rn == '1111' then SEE "PLD (literal)";
            n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');  is_pldw = (R == '0');

    __encoding aarch32_PLD_i_T1_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 10x1xxxx 1111xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "PLD (literal)";
            n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = TRUE;  is_pldw = (W == '1');

    __encoding aarch32_PLD_i_T2_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 00x1xxxx 11111100 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "PLD (literal)";
            n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);  add = FALSE;  is_pldw = (W == '1');

    __execute __conditional
        address = if add then (R[n] + imm32) else (R[n] - imm32);
        if is_pldw then
            Hint_PreloadDataForWrite(address);
        else
            Hint_PreloadData(address);

__instruction aarch32_VPMAX_i_A
    __encoding aarch32_VPMAX_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx1010 x0x1xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPMAX_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx1010 x0x1xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        bits(64) dest;
        h = elements DIV 2;
        
        for e = 0 to h-1
            op1 = Int(Elem[D[n],2*e,esize], unsigned);
            op2 = Int(Elem[D[n],2*e+1,esize], unsigned);
            result = if maximum then Max(op1,op2) else Min(op1,op2);
            Elem[dest,e,esize] = result<esize-1:0>;
            op1 = Int(Elem[D[m],2*e,esize], unsigned);
            op2 = Int(Elem[D[m],2*e+1,esize], unsigned);
            result = if maximum then Max(op1,op2) else Min(op1,op2);
            Elem[dest,e+h,esize] = result<esize-1:0>;
        
        D[d] = dest;

__instruction aarch32_EOR_i_A
    __encoding aarch32_EOR_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 001xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_EOR_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 100xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE "TEQ (immediate)";
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = R[n] EOR imm32;
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_UQSUB16_A
    __encoding aarch32_UQSUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQSUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);
        diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);
        R[d]<15:0>  = UnsignedSat(diff1, 16);
        R[d]<31:16> = UnsignedSat(diff2, 16);

__instruction aarch32_SMULBB_A
    __encoding aarch32_SMULBB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field M 6 +: 1
        __field N 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0110xxxx xxxxxxxx 1xx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            n_high = (N == '1');  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMULBB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field N 5 +: 1
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0001xxxx 1111xxxx 00xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            n_high = (N == '1');  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;
        operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
        result = SInt(operand1) * SInt(operand2);
        R[d] = result<31:0>;
        // Signed overflow cannot occur

__instruction aarch32_STMIB_A
    __encoding aarch32_STMIB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1001 10x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __execute __conditional
        address = R[n] + 4;
        for i = 0 to 14
            if registers<i> == '1' then
                if i == n && wback && i != LowestSetBit(registers) then
                    MemA[address,4] = bits(32) UNKNOWN;
                else
                    MemA[address,4] = R[i];
                address = address + 4;
        if registers<15> == '1' then
            MemA[address,4] = PCStoreValue();
        if wback then R[n] = R[n] + 4*BitCount(registers);

__instruction aarch32_VQSHL_r_A
    __encoding aarch32_VQSHL_r_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQSHL_r_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                shift = SInt(Elem[D[n+r],e,esize]<7:0>);
                operand = Int(Elem[D[m+r],e,esize], unsigned);
                (result,sat) = SatQ(operand << shift, esize, unsigned);
                Elem[D[d+r],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_STR_r_A
    __encoding aarch32_STR_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx011x x0x0xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "STRT";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STR_r_T1_A
        __instruction_set T16
        __field Rm 22 +: 3
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '0101000x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_STR_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0100xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if t == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if index then offset_addr else R[n];
        if t == 15 then  // Only possible for encoding A1
            data = PCStoreValue();
        else
            data = R[t];
        MemU[address,4] = data;
        if wback then R[n] = offset_addr;

__instruction aarch32_STLEXB_A
    __encoding aarch32_STLEXB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1100xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STLEXB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1100xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        if AArch32.ExclusiveMonitorsPass(address,1) then
            MemO[address, 1] = R[t]<7:0>;
            R[d] = ZeroExtend('0');
        else
            R[d] = ZeroExtend('1');

__instruction aarch32_STLB_A
    __encoding aarch32_STLB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1100xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_STLB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1000xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        MemO[address, 1] = R[t]<7:0>;

__instruction aarch32_SHA256H_A
    __encoding aarch32_SHA256H_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x00xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSHA256Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA256H_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x00xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveSHA256Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        X = Q[d>>1]; Y = Q[n>>1]; W = Q[m>>1]; part1 = TRUE;
        Q[d>>1] = SHA256hash(X, Y, W, part1);

__instruction aarch32_VCVTA_vfp_A
    __encoding aarch32_VCVTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111111 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __encoding aarch32_VCVTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111111 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __execute
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
            when 32
                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
            when 64
                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_CMN_rr_A
    __encoding aarch32_CMN_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0111xxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            shift_t = DecodeRegShift(type1);
            if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], shifted, '0');
        PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SSUB16_A
    __encoding aarch32_SSUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SSUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);
        diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);
        R[d]<15:0>  = diff1<15:0>;
        R[d]<31:16> = diff2<15:0>;
        PSTATE.GE<1:0> = if diff1 >= 0 then '11' else '00';
        PSTATE.GE<3:2> = if diff2 >= 0 then '11' else '00';

__instruction aarch32_VCMP_A
    __encoding aarch32_VCMP_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110100 xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VCMP_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __opcode 'xxxx1110 1x110101 xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D);
                when '10' esize = 32; d = UInt(Vd:D);
                when '11' esize = 64; d = UInt(D:Vd);

    __encoding aarch32_VCMP_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110100 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VCMP_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __opcode '11101110 1x110101 xxxx10xx 01x0xxxx'
        __guard TRUE
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D);
                when '10' esize = 32; d = UInt(Vd:D);
                when '11' esize = 64; d = UInt(D:Vd);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        bits(4) nzcv;
        case esize of
            when 16
                bits(16) op16 = if with_zero then FPZero('0') else S[m]<15:0>;
                nzcv = FPCompare(S[d]<15:0>, op16, quiet_nan_exc, FPSCR);
            when 32
                bits(32) op32 = if with_zero then FPZero('0') else S[m];
                nzcv = FPCompare(S[d], op32, quiet_nan_exc, FPSCR);
            when 64
                bits(64) op64 = if with_zero then FPZero('0') else D[m];
                nzcv = FPCompare(D[d], op64, quiet_nan_exc, FPSCR);
        
        FPSCR.<N,Z,C,V> = nzcv;

__instruction aarch32_VRECPS_A
    __encoding aarch32_VRECPS_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRECPS_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = FPRecipStep(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize]);

__instruction aarch32_VCGT_r_A
    __encoding aarch32_VCGT_r_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            type1 = if U == '1' then VCGTtype_unsigned else VCGTtype_signed;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGT_r_A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x1xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            type1 = VCGTtype_fp;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGT_r_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            type1 = if U == '1' then VCGTtype_unsigned else VCGTtype_signed;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGT_r_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x1xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            type1 = VCGTtype_fp;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                case type1 of
                    when VCGTtype_signed    test_passed = (SInt(op1) > SInt(op2));
                    when VCGTtype_unsigned  test_passed = (UInt(op1) > UInt(op2));
                    when VCGTtype_fp        test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());
                Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_VMOV_h_A
    __encoding aarch32_VMOV_h_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field op 20 +: 1
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __opcode 'xxxx1110 000xxxxx xxxx1001 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            if cond != '1110' then UNPREDICTABLE;
            to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMOV_h_T1_A
        __instruction_set T32
        __field op 20 +: 1
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __opcode '11101110 000xxxxx xxxx1001 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        CheckVFPEnabled(TRUE);
        if to_arm_register then
            R[t] = Zeros(16) : S[n]<15:0>;
        else
            S[n] = Zeros(16) : R[t]<15:0>;

__instruction aarch32_SSUB8_A
    __encoding aarch32_SSUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SSUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);
        diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);
        diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);
        diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);
        R[d]<7:0>   = diff1<7:0>;
        R[d]<15:8>  = diff2<7:0>;
        R[d]<23:16> = diff3<7:0>;
        R[d]<31:24> = diff4<7:0>;
        PSTATE.GE<0>  = if diff1 >= 0 then '1' else '0';
        PSTATE.GE<1>  = if diff2 >= 0 then '1' else '0';
        PSTATE.GE<2>  = if diff3 >= 0 then '1' else '0';
        PSTATE.GE<3>  = if diff4 >= 0 then '1' else '0';

__instruction aarch32_NOP_A
    __encoding aarch32_NOP_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000000'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_NOP_T1_A
        __instruction_set T16
        __opcode '10111111 00000000 00000000 00000000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_NOP_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000000'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute __conditional
        // Do nothing

__instruction aarch32_AND_r_A
    __encoding aarch32_AND_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 000xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_AND_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rdn 16 +: 3
        __opcode '01000000 00xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_AND_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 000xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE "TST (register)";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] AND shifted;
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_VMOV_i_A
    __encoding aarch32_VMOV_i_T1A1_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx0xx0 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE "VORR (immediate)";
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field imm4H 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm4L 0 +: 4
        __opcode 'xxxx1110 1x11xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            single_register = (size != '11'); advsimd = FALSE;
            bits(16) imm16;
            bits(32) imm32;
            bits(64) imm64;
            case size of
                when '01' d = UInt(Vd:D);  imm16 = VFPExpandImm(imm4H:imm4L); imm32 = Zeros(16) : imm16;
                when '10' d = UInt(Vd:D);  imm32 = VFPExpandImm(imm4H:imm4L);
                when '11' d = UInt(D:Vd);  imm64 = VFPExpandImm(imm4H:imm4L);  regs = 1;

    __encoding aarch32_VMOV_i_T3A3_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx10x0 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE "VORR (immediate)";
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T4A4_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx11xx 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE "VORR (immediate)";
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T5A5_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx1110 0x11xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE "VORR (immediate)";
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T1A1_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx0xx0 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE "VORR (immediate)";
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm4H 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm4L 0 +: 4
        __opcode '11101110 1x11xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            single_register = (size != '11'); advsimd = FALSE;
            bits(16) imm16;
            bits(32) imm32;
            bits(64) imm64;
            case size of
                when '01' d = UInt(Vd:D);  imm16 = VFPExpandImm(imm4H:imm4L); imm32 = Zeros(16) : imm16;
                when '10' d = UInt(Vd:D);  imm32 = VFPExpandImm(imm4H:imm4L);
                when '11' d = UInt(D:Vd);  imm64 = VFPExpandImm(imm4H:imm4L);  regs = 1;

    __encoding aarch32_VMOV_i_T3A3_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx10x0 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE "VORR (immediate)";
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T4A4_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx11xx 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE "VORR (immediate)";
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T5A5_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx1110 0x11xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE "VORR (immediate)";
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if single_register then
            S[d] = imm32;
        else
            for r = 0 to regs-1
                D[d+r] = imm64;

__instruction aarch32_UASX_A
    __encoding aarch32_UASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);
        sum  = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);
        R[d]<15:0>  = diff<15:0>;
        R[d]<31:16> = sum<15:0>;
        PSTATE.GE<1:0> = if diff >= 0 then '11' else '00';
        PSTATE.GE<3:2> = if sum  >= 0x10000 then '11' else '00';

__instruction aarch32_USAT_A
    __encoding aarch32_USAT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sat_imm 16 +: 5
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field sh 6 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0110 111xxxxx xxxxxxxx xx01xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
            (shift_t, shift_n) = DecodeImmShift(sh:'0', imm5);
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_USAT_T1_A
        __instruction_set T32
        __field sh 21 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field sat_imm 0 +: 5
        __opcode '11110x11 10x0xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            if sh == '1' && (imm3:imm2) == '00000' then SEE "USAT16";
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
            (shift_t, shift_n) = DecodeImmShift(sh:'0', imm3:imm2);
            if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand = Shift(R[n], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored
        (result, sat) = UnsignedSatQ(SInt(operand), saturate_to);
        R[d] = ZeroExtend(result, 32);
        if sat then
            PSTATE.Q = '1';

__instruction aarch32_ESB_A
    __encoding aarch32_ESB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00010000'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if !HaveRASExt() then EndOfInstruction();  // Instruction executes as NOP
            if cond != '1110' then UNPREDICTABLE;      // ESB must be encoded with AL condition

    __encoding aarch32_ESB_T1_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00010000'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            if !HaveRASExt() then EndOfInstruction();  // Instruction executes as NOP
            if InITBlock() then UNPREDICTABLE;

    __execute __conditional
        
        SynchronizeErrors();
        AArch32.ESBOperation();
        if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch32.vESBOperation();
        TakeUnmaskedSErrorInterrupts();

__instruction aarch32_STRHT_A
    __encoding aarch32_STRHT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx0000 x110xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_STRHT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0000 x010xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_STRHT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0010xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = if register_form then R[m] else imm32;
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if postindex then R[n] else offset_addr;
        MemU_unpriv[address,2] = R[t]<15:0>;
        if postindex then R[n] = offset_addr;

__instruction aarch32_VRECPE_A
    __encoding aarch32_VRECPE_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx010x 0xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            floating_point = (F == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRECPE_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx010x 0xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            floating_point = (F == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                if floating_point then
                    Elem[D[d+r],e,esize] = FPRecipEstimate(Elem[D[m+r],e,esize], StandardFPSCRValue());
                else
                    Elem[D[d+r],e,esize] = UnsignedRecipEstimate(Elem[D[m+r],e,esize]);

__instruction aarch32_VABD_f_A
    __encoding aarch32_VABD_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x1xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VABD_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x1xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                Elem[D[d+r],e,esize] = FPAbs(FPSub(op1,op2,StandardFPSCRValue()));

__instruction aarch32_LDC_i_A
    __encoding aarch32_LDC_i_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x x0x1xxxx 01011110 xxxxxxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE "LDC (literal)";
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            n = UInt(Rn);  cp = 14;
            imm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');

    __encoding aarch32_LDC_i_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x x0x1xxxx 01011110 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "LDC (literal)";
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            n = UInt(Rn);  cp = 14;
            imm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');

    __execute __conditional
        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
        address = if index then offset_addr else R[n];
        
        // System register write to DBGDTRTXint.
        DBGDTR_EL0[] = MemA[address,4];
        
        if wback then R[n] = offset_addr;

__instruction aarch32_VBIC_i_A
    __encoding aarch32_VBIC_i_T1A1_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx0xx1 0x11xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIC_i_T2A2_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx10x1 0x11xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIC_i_T1A1_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx0xx1 0x11xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIC_i_T2A2_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx10x1 0x11xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            D[d+r] = D[d+r] AND NOT(imm64);

__instruction aarch32_HVC_AS
    __encoding aarch32_HVC_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm12 8 +: 12
        __field imm4 0 +: 4
        __opcode 'xxxx0001 0100xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __decode
            if cond != '1110' then UNPREDICTABLE;
            imm16 = imm12:imm4;

    __encoding aarch32_HVC_T1_A
        __instruction_set T32
        __field imm4 16 +: 4
        __field imm12 0 +: 12
        __opcode '11110111 1110xxxx 1000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            imm16 = imm4:imm12;
            if InITBlock() then UNPREDICTABLE;

    __execute
        if !HaveEL(EL2) || PSTATE.EL == EL0 || (IsSecure() && !IsSecureEL2Enabled()) then
            UNDEFINED;
        
        if HaveEL(EL3) then
            if ELUsingAArch32(EL3) && SCR.HCE == '0' && PSTATE.EL == EL2 then
                UNPREDICTABLE;
            else
                hvc_enable = SCR_GEN[].HCE;
        else
            hvc_enable = if ELUsingAArch32(EL2) then NOT(HCR.HCD) else NOT(HCR_EL2.HCD);
        
        if hvc_enable == '0' then
            UNDEFINED;
        else
            AArch32.CallHypervisor(imm16);

__instruction aarch32_SMLSD_A
    __encoding aarch32_SMLSD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0000xxxx xxxxxxxx 01x1xxxx'
        __guard cond != '1111'
        __decode
            if Ra == '1111' then SEE "SMUSD";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMLSD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0100xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE "SMUSD";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand2 = if m_swap then ROR(R[m],16) else R[m];
        product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
        product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
        result = product1 - product2 + SInt(R[a]);
        R[d] = result<31:0>;
        if result != SInt(result<31:0>) then  // Signed overflow
            PSTATE.Q = '1';

__instruction aarch32_VJCVT_A
    __encoding aarch32_VJCVT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x111001 xxxx1011 11x0xxxx'
        __guard cond != '1111'
        __decode
            if !HaveFJCVTZSExt() then UNDEFINED;
            if cond != '1110' then UNPREDICTABLE;
            d = UInt(Vd:D);  m = UInt(M:Vm);

    __encoding aarch32_VJCVT_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x111001 xxxx1011 11x0xxxx'
        __guard TRUE
        __decode
            if !HaveFJCVTZSExt() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            d = UInt(Vd:D);  m = UInt(M:Vm);

    __execute
        CheckVFPEnabled(TRUE);
        bits(64) fltval = D[m];
        bits(32) intval = FPToFixedJS(fltval, FPSCR, FALSE);
        S[d] = intval;

__instruction aarch32_LDRSB_l_A
    __encoding aarch32_LDRSB_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x11111 xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "LDRSBT";
            t = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || wback then UNPREDICTABLE;

    __encoding aarch32_LDRSB_l_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111001 x0011111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE "PLI";
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        base = Align(PC,4);
        address = if add then (base + imm32) else (base - imm32);
        R[t] = SignExtend(MemU[address,1], 32);

__instruction aarch32_SMULWB_A
    __encoding aarch32_SMULWB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field M 6 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 1x10xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMULWB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0011xxxx 1111xxxx 000xxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
        product = SInt(R[n]) * SInt(operand2);
        R[d] = product<47:16>;
        // Signed overflow cannot occur

__instruction aarch32_SXTH_A
    __encoding aarch32_SXTH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 10111111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTH_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rd 16 +: 3
        __opcode '10110010 00xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

    __encoding aarch32_SXTH_T2_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 00001111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d] = SignExtend(rotated<15:0>, 32);

__instruction aarch32_UMLAL_A
    __encoding aarch32_UMLAL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 101xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_UMLAL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1110xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute __conditional
        result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]:R[dLo]);
        R[dHi] = result<63:32>;
        R[dLo] = result<31:0>;
        if setflags then
            PSTATE.N = result<63>;
            PSTATE.Z = IsZeroBit(result<63:0>);
            // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_MRRC_A
    __encoding aarch32_MRRC_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc1 4 +: 4
        __field CRm 0 +: 4
        __opcode 'xxxx1100 0101xxxx xxxx111x xxxxxxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_MRRC_T1A1_A
        __instruction_set T32
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc1 4 +: 4
        __field CRm 0 +: 4
        __opcode '11101100 0101xxxx xxxx111x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        value = AArch32.SysRegRead64(cp, ThisInstr());
        R[t] = value<31:0>;
        R[t2] = value<63:32>;

__instruction aarch32_LDMDB_A
    __encoding aarch32_LDMDB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1001 00x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;

    __encoding aarch32_LDMDB_T1_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field P 15 +: 1
        __field M 14 +: 1
        __field register_list 0 +: 14
        __opcode '11101001 00x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 2 || (P == '1' && M == '1') then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;
            if registers<13> == '1' then UNPREDICTABLE;
            if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute __conditional
        address = R[n] - 4*BitCount(registers);
        for i = 0 to 14
            if registers<i> == '1' then
                R[i] = MemA[address,4];  address = address + 4;
        if registers<15> == '1' then
            LoadWritePC(MemA[address,4]);
        if wback && registers<n> == '0' then R[n] = R[n] - 4*BitCount(registers);
        if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;

__instruction aarch32_SVC_A
    __encoding aarch32_SVC_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm24 0 +: 24
        __opcode 'xxxx1111 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            imm32 = ZeroExtend(imm24, 32);

    __encoding aarch32_SVC_T1_A
        __instruction_set T16
        __field imm8 16 +: 8
        __opcode '11011111 xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            imm32 = ZeroExtend(imm8, 32);

    __execute __conditional
        AArch32.CallSupervisor(imm32<15:0>);

__instruction aarch32_VRSRA_A
    __encoding aarch32_VRSRA_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0011 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRSRA_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0011 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        round_const = 1 << (shift_amount - 1);
        for r = 0 to regs-1
            for e = 0 to elements-1
                result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) >> shift_amount;
                Elem[D[d+r],e,esize] = Elem[D[d+r],e,esize] + result;

__instruction aarch32_VLD4_1_A
    __encoding aarch32_VLD4_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD4 (single 4-element structure to all lanes)";
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD4 (single 4-element structure to all lanes)";
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD4 (single 4-element structure to all lanes)";
            if index_align<1:0> == '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<1:0> == '00' then 1 else 4 << UInt(index_align<1:0>);
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD4 (single 4-element structure to all lanes)";
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD4 (single 4-element structure to all lanes)";
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "VLD4 (single 4-element structure to all lanes)";
            if index_align<1:0> == '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<1:0> == '00' then 1 else 4 << UInt(index_align<1:0>);
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = FALSE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        Elem[D[d], index] = MemU[address,ebytes];
        Elem[D[d2],index] = MemU[address+ebytes,ebytes];
        Elem[D[d3],index] = MemU[address+2*ebytes,ebytes];
        Elem[D[d4],index] = MemU[address+3*ebytes,ebytes];
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 4*ebytes;

__instruction aarch32_VCLT_i_A
    __encoding aarch32_VCLT_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x10 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCLT_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x10 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                if floating_point then
                    bits(esize) zero = FPZero('0');
                    test_passed = FPCompareGT(zero, Elem[D[m+r],e,esize], StandardFPSCRValue());
                else
                    test_passed = (SInt(Elem[D[m+r],e,esize]) < 0);
                Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_UXTAB16_A
    __encoding aarch32_UXTAB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1100xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE "UXTB16";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTAB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0011xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE "UXTB16";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d]<15:0>  = R[n]<15:0> + ZeroExtend(rotated<7:0>, 16);
        R[d]<31:16> = R[n]<31:16> + ZeroExtend(rotated<23:16>, 16);

__instruction aarch32_PLD_l_A
    __encoding aarch32_PLD_l_A1_A
        __instruction_set A32
        __field U 23 +: 1
        __field imm12 0 +: 12
        __opcode '11110101 xx011111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 22 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

    __encoding aarch32_PLD_l_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field imm12 0 +: 12
        __opcode '11111000 x0x11111 1111xxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 21 == '0'
        __decode
            imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

    __execute __conditional
        address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
        Hint_PreloadData(address);

__instruction aarch32_SMLAWB_A
    __encoding aarch32_SMLAWB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field M 6 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 1x00xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

    __encoding aarch32_SMLAWB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0011xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE "SMULWB, SMULWT";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
        result = SInt(R[n]) * SInt(operand2) + (SInt(R[a]) << 16);
        R[d] = result<47:16>;
        if (result >> 16) != SInt(R[d]) then  // Signed overflow
            PSTATE.Q = '1';

__instruction aarch32_MVN_r_A
    __encoding aarch32_MVN_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 111xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_MVN_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rd 16 +: 3
        __opcode '01000011 11xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_MVN_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 011x1111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = NOT(shifted);
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_SHADD16_A
    __encoding aarch32_SHADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);
        sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);
        R[d]<15:0>  = sum1<16:1>;
        R[d]<31:16> = sum2<16:1>;

__instruction aarch32_VMLA_s_A
    __encoding aarch32_VMLA_s_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0010 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMLA_s_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0010 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                if floating_point then
                    fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));
                    Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());
                else
                    addend = if add then op1val*op2val else -op1val*op2val;
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                    else
                        Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_LDAEX_A
    __encoding aarch32_LDAEX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1001xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAEX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1110xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        AArch32.SetExclusiveMonitors(address, 4);
        R[t] = MemO[address, 4];

__instruction aarch32_LDM_u_AS
    __encoding aarch32_LDM_u_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 15
        __opcode 'xxxx100x x1x1xxxx 0xxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 21 == '0'
        __decode
            n = UInt(Rn);  registers = register_list;  increment = (U == '1');  wordhigher = (P == U);
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __execute __conditional
        if PSTATE.EL == EL2 then UNDEFINED;
        elsif PSTATE.M IN {M32_User,M32_System} then UNPREDICTABLE;
        else
            length = 4*BitCount(registers);
            address = if increment then R[n] else R[n]-length;
            if wordhigher then address = address+4;
            for i = 0 to 14
                if registers<i> == '1' then  // Load User mode register
                    Rmode[i, M32_User] = MemA[address,4];  address = address + 4;

__instruction aarch32_VSHR_A
    __encoding aarch32_VSHR_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0000 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSHR_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0000 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                result = Int(Elem[D[m+r],e,esize], unsigned) >> shift_amount;
                Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_VST2_1_A
    __encoding aarch32_VST2_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST2_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST2_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx1001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST2_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST2_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST2_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx1001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = TRUE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        MemU[address,       ebytes] = Elem[D[d], index];
        MemU[address+ebytes,ebytes] = Elem[D[d2],index];
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 2*ebytes;

__instruction aarch32_VDOT_s_A
    __encoding aarch32_VDOT_s_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field U 4 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0x10xxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveDOTPExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            boolean signed = (U=='0');
            integer d = UInt(D:Vd);
            integer n = UInt(N:Vn);
            integer m = UInt(Vm<3:0>);
            integer index = UInt(M);
            integer esize = 32;
            integer regs = if Q == '1' then 2 else 1;

    __encoding aarch32_VDOT_s_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field U 4 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0x10xxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveDOTPExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            boolean signed = (U=='0');
            integer d = UInt(D:Vd);
            integer n = UInt(N:Vn);
            integer m = UInt(Vm<3:0>);
            integer index = UInt(M);
            integer esize = 32;
            integer regs = if Q == '1' then 2 else 1;

    __execute
        bits(64) operand1;
        bits(64) operand2 = D[m];
        bits(64) result;
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            operand1 = D[n+r];
            result = D[d+r];
            integer element1, element2;
            for e = 0 to 1
                integer res = 0;
                for i = 0 to 3
                    if signed then
                        element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                        element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);
                    else
                        element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                        element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);
                    res = res + element1 * element2;
                Elem[result, e, esize] = Elem[result, e, esize] + res;
            D[d+r] = result;

__instruction aarch32_VLD2_a_A
    __encoding aarch32_VLD2_a_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 1 << UInt(size);
            alignment = if a == '0' then 1 else 2*ebytes;
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_a_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 1 << UInt(size);
            alignment = if a == '0' then 1 else 2*ebytes;
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __execute __conditional
        CheckAdvSIMDEnabled();
        address = R[n];  iswrite = FALSE;
        - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
        D[d] = Replicate(MemU[address,ebytes]);
        D[d2] = Replicate(MemU[address+ebytes,ebytes]);
        if wback then
            if register_index then
                R[n] = R[n] + R[m];
            else
                R[n] = R[n] + 2*ebytes;

__instruction aarch32_VMLA_s_A
    __encoding aarch32_VMLA_s_A1_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx010x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            add = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMLA_s_T1_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx010x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            add = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute __conditional
        CheckAdvSIMDEnabled();
        op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                if floating_point then
                    fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));
                    Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());
                else
                    addend = if add then op1val*op2val else -op1val*op2val;
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                    else
                        Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_VREV16_A
    __encoding aarch32_VREV16_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0001 0xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VREV16_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0001 0xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        
        bits(64) result;
        integer element;
        integer rev_element;
        for r = 0 to regs-1
            element = 0;
            for c = 0 to containers-1
                rev_element = element + elements_per_container - 1;
                for e = 0 to elements_per_container-1
                    Elem[result, rev_element, esize] = Elem[D[m+r], element, esize];
                    element = element + 1;
                    rev_element = rev_element - 1;
            D[d+r] = result;

__instruction aarch32_VCVT_ds_A
    __encoding aarch32_VCVT_ds_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110111 xxxx101x 11x0xxxx'
        __guard cond != '1111'
        __decode
            double_to_single = (size == '11');
            d = if double_to_single then UInt(Vd:D) else UInt(D:Vd);
            m = if double_to_single then UInt(M:Vm) else UInt(Vm:M);

    __encoding aarch32_VCVT_ds_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110111 xxxx101x 11x0xxxx'
        __guard TRUE
        __decode
            double_to_single = (size == '11');
            d = if double_to_single then UInt(Vd:D) else UInt(D:Vd);
            m = if double_to_single then UInt(M:Vm) else UInt(Vm:M);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        if double_to_single then
            S[d] = FPConvert(D[m], FPSCR);
        else
            D[d] = FPConvert(S[m], FPSCR);

__instruction aarch32_VADDL_A
    __encoding aarch32_VADDL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0000 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VADDL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0000 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            if is_vaddw then
                op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
            else
                op1 = Int(Elem[Din[n],e,esize], unsigned);
            result = op1 + Int(Elem[Din[m],e,esize],unsigned);
            Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_VMAX_f_A
    __encoding aarch32_VMAX_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1111 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAX_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1111 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                if maximum then
                    Elem[D[d+r],e,esize] = FPMax(op1, op2, StandardFPSCRValue());
                else
                    Elem[D[d+r],e,esize] = FPMin(op1, op2, StandardFPSCRValue());

__instruction aarch32_UXTAB_A
    __encoding aarch32_UXTAB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1110xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE "UXTB";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTAB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0101xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE "UXTB";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        rotated = ROR(R[m], rotation);
        R[d] = R[n] + ZeroExtend(rotated<7:0>, 32);

__instruction aarch32_LDC_l_A
    __encoding aarch32_LDC_l_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field imm8 0 +: 8
        __opcode 'xxxx110x x0x11111 01011110 xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            index = (P == '1');  add = (U == '1');  cp = 14;  imm32 = ZeroExtend(imm8:'00', 32);
            if W == '1' || (P == '0' && CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;

    __encoding aarch32_LDC_l_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field imm8 0 +: 8
        __opcode '1110110x x0x11111 01011110 xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            index = (P == '1');  add = (U == '1');  cp = 14;  imm32 = ZeroExtend(imm8:'00', 32);
            if W == '1' || (P == '0' && CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;

    __execute __conditional
        offset_addr = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
        address = if index then offset_addr else Align(PC,4);
        
        // System register write to DBGDTRTXint.
        DBGDTR_EL0[] = MemA[address,4];

__instruction aarch32_ORN_r_A
    __encoding aarch32_ORN_r_T1_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 011xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rn == '1111' then SEE "MVN (register)";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] OR NOT(shifted);
        R[d] = result;
        if setflags then
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_LDRT_A
    __encoding aarch32_LDRT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0100 x011xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_LDRT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 x011xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0101xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            if Rn == '1111' then SEE "LDR (literal)";
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if postindex then R[n] else offset_addr;
        data = MemU_unpriv[address,4];
        if postindex then R[n] = offset_addr;
        R[t] = data;

__instruction aarch32_ADC_rr_A
    __encoding aarch32_ADC_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 101xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);
        R[d] = result;
        if setflags then
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SDIV_A
    __encoding aarch32_SDIV_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0001xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE;

    __encoding aarch32_SDIV_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1001xxxx xxxxxxxx 1111xxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        if SInt(R[m]) == 0 then
            result = 0;
        else
            result = RoundTowardsZero(Real(SInt(R[n])) / Real(SInt(R[m])));
        R[d] = result<31:0>;

__instruction aarch32_LDRSB_i_A
    __encoding aarch32_LDRSB_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x1xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE "LDRSB (literal)";
            if P == '0' && W == '1' then SEE "LDRSBT";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRSB_i_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111001 1001xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE "PLI";
            if Rn == '1111' then SEE "LDRSB (literal)";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            // Armv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_LDRSB_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111001 0001xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE "PLI";
            if Rn == '1111' then SEE "LDRSB (literal)";
            if P == '1' && U == '1' && W == '0' then SEE "LDRSBT";
            if P == '0' && W == '0' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
        address = if index then offset_addr else R[n];
        R[t] = SignExtend(MemU[address,1], 32);
        if wback then R[n] = offset_addr;

__instruction aarch32_SMLABB_A
    __encoding aarch32_SMLABB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field M 6 +: 1
        __field N 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0000xxxx xxxxxxxx 1xx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            n_high = (N == '1');  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

    __encoding aarch32_SMLABB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field N 5 +: 1
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0001xxxx xxxxxxxx 00xxxxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE "SMULBB, SMULBT, SMULTB, SMULTT";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            n_high = (N == '1');  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;
        operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
        result = SInt(operand1) * SInt(operand2) + SInt(R[a]);
        R[d] = result<31:0>;
        if result != SInt(result<31:0>) then  // Signed overflow
            PSTATE.Q = '1';

__instruction aarch32_UMULL_A
    __encoding aarch32_UMULL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 100xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_UMULL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1010xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // Armv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute __conditional
        result = UInt(R[n]) * UInt(R[m]);
        R[dHi] = result<63:32>;
        R[dLo] = result<31:0>;
        if setflags then
            PSTATE.N = result<63>;
            PSTATE.Z = IsZeroBit(result<63:0>);
            // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_VINS_A
    __encoding aarch32_VINS_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x110000 xxxx1010 11x0xxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            d = UInt(Vd:D); m = UInt(Vm:M);

    __encoding aarch32_VINS_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x110000 xxxx1010 11x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveFP16Ext() then UNDEFINED;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            d = UInt(Vd:D); m = UInt(Vm:M);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        S[d] = S[m]<15:0> : S[d]<15:0>;

__instruction aarch32_STMDA_A
    __encoding aarch32_STMDA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1000 00x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __execute __conditional
        address = R[n] - 4*BitCount(registers) + 4;
        for i = 0 to 14
            if registers<i> == '1' then
                if i == n && wback && i != LowestSetBit(registers) then
                    MemA[address,4] = bits(32) UNKNOWN;
                else
                    MemA[address,4] = R[i];
                address = address + 4;
        if registers<15> == '1' then
            MemA[address,4] = PCStoreValue();
        if wback then R[n] = R[n] - 4*BitCount(registers);

__instruction aarch32_STL_A
    __encoding aarch32_STL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1000xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_STL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1010xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        MemO[address, 4] = R[t];

__instruction aarch32_LDMIB_A
    __encoding aarch32_LDMIB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1001 10x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;

    __execute __conditional
        address = R[n] + 4;
        for i = 0 to 14
            if registers<i> == '1' then
                R[i] = MemA[address,4];  address = address + 4;
        if registers<15> == '1' then
            LoadWritePC(MemA[address,4]);
        if wback && registers<n> == '0' then R[n] = R[n] + 4*BitCount(registers);
        if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;

__instruction aarch32_VNEG_A
    __encoding aarch32_VNEG_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x11 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            advsimd = TRUE;  floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VNEG_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110001 xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VNEG_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x11 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            advsimd = TRUE;  floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VNEG_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110001 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then  // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if floating_point then
                        Elem[D[d+r],e,esize] = FPNeg(Elem[D[m+r],e,esize]);
                    else
                        result = -SInt(Elem[D[m+r],e,esize]);
                        Elem[D[d+r],e,esize] = result<esize-1:0>;
        else             // VFP instruction
            case esize of
                when 16 S[d] = Zeros(16) : FPNeg(S[m]<15:0>);
                when 32 S[d] = FPNeg(S[m]);
                when 64 D[d] = FPNeg(D[m]);

__instruction aarch32_UHASX_A
    __encoding aarch32_UHASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);
        sum  = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);
        R[d]<15:0>  = diff<16:1>;
        R[d]<31:16> = sum<16:1>;

__instruction aarch32_VPMAX_f_A
    __encoding aarch32_VPMAX_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1111 x0x0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPMAX_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1111 x0x0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDEnabled();
        bits(64) dest;
        h = elements DIV 2;
        
        for e = 0 to h-1
            op1 = Elem[D[n],2*e,esize];  op2 = Elem[D[n],2*e+1,esize];
            Elem[dest,e,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());
            op1 = Elem[D[m],2*e,esize];  op2 = Elem[D[m],2*e+1,esize];
            Elem[dest,e+h,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());
        
        D[d] = dest;

__instruction aarch32_VPADAL_A
    __encoding aarch32_VPADAL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0110 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (op == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VPADAL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0110 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (op == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        h = elements DIV 2;
        
        for r = 0 to regs-1
            for e = 0 to h-1
                op1 = Elem[D[m+r],2*e,esize];  op2 = Elem[D[m+r],2*e+1,esize];
                result = Int(op1, unsigned) + Int(op2, unsigned);
                Elem[D[d+r],e,2*esize] = Elem[D[d+r],e,2*esize] + result;

__instruction aarch32_VRINTX_asimd_A
    __encoding aarch32_VRINTX_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0100 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPRounding_TIEEVEN;  exact = TRUE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTX_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0100 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPRounding_TIEEVEN;  exact = TRUE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_SHA256H2_A
    __encoding aarch32_SHA256H2_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x01xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSHA256Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA256H2_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x01xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if !HaveSHA256Ext() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckCryptoEnabled32();
        X = Q[n>>1]; Y = Q[d>>1]; W = Q[m>>1]; part1 = FALSE;
        Q[d>>1] = SHA256hash(X, Y, W, part1);

__instruction aarch32_STLEXD_A
    __encoding aarch32_STLEXD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1010xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);
            if d == 15 || Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t || d == t2 then UNPREDICTABLE;

    __encoding aarch32_STLEXD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1111xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
            if d == 15 || t == 15 || t2 == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t || d == t2 then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        // Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.
        value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];
        if AArch32.ExclusiveMonitorsPass(address, 8) then
            MemO[address, 8] = value;
            R[d] = ZeroExtend('0');
        else
            R[d] = ZeroExtend('1');

__instruction aarch32_REV16_A
    __encoding aarch32_REV16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1011xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  m = UInt(Rm);
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_REV16_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rd 16 +: 3
        __opcode '10111010 01xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);

    __encoding aarch32_REV16_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 1001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
            if m != n || d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        bits(32) result;
        result<31:24> = R[m]<23:16>;
        result<23:16> = R[m]<31:24>;
        result<15:8>  = R[m]<7:0>;
        result<7:0>   = R[m]<15:8>;
        R[d] = result;

__instruction aarch32_LDR_r_A
    __encoding aarch32_LDR_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx011x x0x1xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE "LDRT";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_LDR_r_T1_A
        __instruction_set T16
        __field Rm 22 +: 3
        __field Rn 19 +: 3
        __field Rt 16 +: 3
        __opcode '0101100x xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_LDR_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0101xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE "LDR (literal)";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
            if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if index then offset_addr else R[n];
            data = MemU[address,4];
            if wback then R[n] = offset_addr;
            if t == 15 then
                if address<1:0> == '00' then
                    LoadWritePC(data);
                else
                    UNPREDICTABLE;
            else
                R[t] = data;
        else
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            offset_addr = (R[n] + offset);
            address = offset_addr;
            data = MemU[address,4];
            if t == 15 then
                if address<1:0> == '00' then
                    LoadWritePC(data);
                else
                    UNPREDICTABLE;
            else
                R[t] = data;

__instruction aarch32_UADD16_A
    __encoding aarch32_UADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);
        sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);
        R[d]<15:0>  = sum1<15:0>;
        R[d]<31:16> = sum2<15:0>;
        PSTATE.GE<1:0> = if sum1 >= 0x10000 then '11' else '00';
        PSTATE.GE<3:2> = if sum2 >= 0x10000 then '11' else '00';

__instruction aarch32_ADC_r_A
    __encoding aarch32_ADC_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 101xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_ADC_r_T1_A
        __instruction_set T16
        __field Rm 19 +: 3
        __field Rdn 16 +: 3
        __opcode '01000001 01xxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_ADC_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 010xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);
        if d == 15 then          // Can only occur for A32 encoding
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SUB_rr_A
    __encoding aarch32_SUB_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 010xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute __conditional
        shift_n = UInt(R[s]<7:0>);
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
        R[d] = result;
        if setflags then
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_CLREX_A
    __encoding aarch32_CLREX_A1_A
        __instruction_set A32
        __opcode '11110101 0111xxxx xxxxxxxx 0001xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            // No additional decoding required

    __encoding aarch32_CLREX_T1_A
        __instruction_set T32
        __opcode '11110011 1011xxxx 10x0xxxx 0010xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            // No additional decoding required

    __execute __conditional
        ClearExclusiveLocal(ProcessorID());

__instruction aarch32_VCVT_iv_A
    __encoding aarch32_VCVT_iv_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x11110x xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __encoding aarch32_VCVT_iv_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x11110x xxxx10xx 11x0xxxx'
        __guard TRUE
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __execute __conditional
        CheckVFPEnabled(TRUE);
        if to_integer then
            case esize of
                when 16
                    S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
                when 32
                    S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
                when 64
                    S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);
        else
            case esize of
                when 16
                    bits(16) fp16 = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                    S[d] = Zeros(16):fp16;
                when 32
                    S[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                when 64
                    D[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_VMVN_r_A
    __encoding aarch32_VMVN_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0101 1xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0101 1xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            D[d+r] = NOT(D[m+r]);

__instruction aarch32_VCVTA_vfp_A
    __encoding aarch32_VCVTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111110 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __encoding aarch32_VCVTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111110 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __execute
        CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
            when 32
                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
            when 64
                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_SMMLA_A
    __encoding aarch32_SMMLA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field R 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0101xxxx xxxxxxxx 00x1xxxx'
        __guard cond != '1111'
        __decode
            if Ra == '1111' then SEE "SMMUL";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMMLA_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field R 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0101xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE "SMMUL";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        result = (SInt(R[a]) << 32) + SInt(R[n]) * SInt(R[m]);
        if round then result = result + 0x80000000;
        R[d] = result<63:32>;

__instruction aarch32_VSRI_A
    __encoding aarch32_VSRI_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1xxxxxxx xxxx0100 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSRI_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1xxxxxxx xxxx0100 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        mask = LSR(Ones(esize), shift_amount);
        for r = 0 to regs-1
            for e = 0 to elements-1
                shifted_op = LSR(Elem[D[m+r],e,esize], shift_amount);
                Elem[D[d+r],e,esize] = (Elem[D[d+r],e,esize] AND NOT(mask)) OR shifted_op;

__instruction aarch32_VMLA_f_A
    __encoding aarch32_VMLA_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x1xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;  add = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_f_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x00xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE; add = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VMLA_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x1xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE;  add = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_f_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x00xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE; add = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute __conditional
        CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then  // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    product = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
                    addend = if add then product else FPNeg(product);
                    Elem[D[d+r],e,esize] = FPAdd(Elem[D[d+r],e,esize], addend, StandardFPSCRValue());
        else             // VFP instruction
            case esize of
                when 16
                    addend16 = if add then FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR) else FPNeg(FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR));
                    S[d] = Zeros(16) : FPAdd(S[d]<15:0>, addend16, FPSCR);
                when 32
                    addend32 = if add then FPMul(S[n], S[m], FPSCR) else FPNeg(FPMul(S[n], S[m], FPSCR));
                    S[d] = FPAdd(S[d], addend32, FPSCR);
                when 64
                    addend64 = if add then FPMul(D[n], D[m], FPSCR) else FPNeg(FPMul(D[n], D[m], FPSCR));
                    D[d] = FPAdd(D[d], addend64, FPSCR);

__instruction aarch32_VRINTA_asimd_A
    __encoding aarch32_VRINTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0110 1xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0110 1xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_RSC_r_A
    __encoding aarch32_RSC_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 111xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __execute __conditional
        shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, PSTATE.C);
        if d == 15 then
            if setflags then
                ALUExceptionReturn(result);
            else
                ALUWritePC(result);
        else
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VCVT_hs_A
    __encoding aarch32_VCVT_hs_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx011x 00x0xxxx'
        __guard TRUE
        __decode
            if size != '01' then UNDEFINED;
            half_to_single = (op == '1');
            if half_to_single && Vd<0> == '1' then UNDEFINED;
            if !half_to_single && Vm<0> == '1' then UNDEFINED;
            esize = 16;  elements = 4;
            m = UInt(M:Vm);  d = UInt(D:Vd);

    __encoding aarch32_VCVT_hs_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx011x 00x0xxxx'
        __guard TRUE
        __decode
            if size != '01' then UNDEFINED;
            half_to_single = (op == '1');
            if half_to_single && Vd<0> == '1' then UNDEFINED;
            if !half_to_single && Vm<0> == '1' then UNDEFINED;
            esize = 16;  elements = 4;
            m = UInt(M:Vm);  d = UInt(D:Vd);

    __execute __conditional
        CheckAdvSIMDEnabled();
        for e = 0 to elements-1
            if half_to_single then
                Elem[Q[d>>1],e,32] = FPConvert(Elem[Din[m],e,16], StandardFPSCRValue());
            else
                Elem[D[d],e,16] = FPConvert(Elem[Qin[m>>1],e,32], StandardFPSCRValue());

__instruction aarch32_TEQ_r_A
    __encoding aarch32_TEQ_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0011xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_TEQ_r_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 1001xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
        result = R[n] EOR shifted;
        PSTATE.N = result<31>;
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged

__instruction aarch32_LDRHT_A
    __encoding aarch32_LDRHT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx0000 x111xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_LDRHT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0000 x011xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRHT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0011xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            if Rn == '1111' then SEE "LDRH (literal)";
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        offset = if register_form then R[m] else imm32;
        offset_addr = if add then (R[n] + offset) else (R[n] - offset);
        address = if postindex then R[n] else offset_addr;
        data = MemU_unpriv[address,2];
        if postindex then R[n] = offset_addr;
        R[t] = ZeroExtend(data, 32);

__instruction aarch32_VCLS_A
    __encoding aarch32_VCLS_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0100 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCLS_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0100 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = CountLeadingSignBits(Elem[D[m+r],e,esize])<esize-1:0>;

__instruction aarch32_VCVTA_asimd_A
    __encoding aarch32_VCVTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx0000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx0000 xxx0xxxx'
        __guard TRUE
        __decode
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        CheckAdvSIMDEnabled();
        bits(esize) result;
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,
                                                 StandardFPSCRValue(), rounding);

__instruction aarch32_DMB_A
    __encoding aarch32_DMB_A1_A
        __instruction_set A32
        __field option 0 +: 4
        __opcode '11110101 0111xxxx xxxxxxxx 0101xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_DMB_T1_A
        __instruction_set T32
        __field option 0 +: 4
        __opcode '11110011 1011xxxx 10x0xxxx 0101xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            // No additional decoding required

    __execute __conditional
        case option of
            when '0001'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Reads;
            when '0010'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Writes;
            when '0011'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_All;
            when '0101'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Reads;
            when '0110'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Writes;
            when '0111'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_All;
            when '1001'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Reads;
            when '1010'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Writes;
            when '1011'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_All;
            when '1101'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Reads;
            when '1110'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Writes;
            otherwise    domain = MBReqDomain_FullSystem;      types = MBReqTypes_All;
        
        if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then
            if HCR.BSU == '11' then
                domain = MBReqDomain_FullSystem;
            if HCR.BSU == '10' && domain != MBReqDomain_FullSystem then
                domain = MBReqDomain_OuterShareable;
            if HCR.BSU == '01' && domain == MBReqDomain_Nonshareable then
                domain = MBReqDomain_InnerShareable;
        
        DataMemoryBarrier(domain, types);

__instruction aarch32_VORN_r_A
    __encoding aarch32_VORN_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x11xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VORN_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x11xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            D[d+r] = D[n+r] OR NOT(D[m+r]);

__instruction aarch32_STM_A
    __encoding aarch32_STM_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1000 10x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __encoding aarch32_STM_T1_A
        __instruction_set T16
        __field Rn 24 +: 3
        __field register_list 16 +: 8
        __opcode '11000xxx xxxxxxxx 00000000 00000000'
        __guard TRUE
        __decode
            n = UInt(Rn);  registers = '00000000':register_list;  wback = TRUE;
            if BitCount(registers) < 1 then UNPREDICTABLE;

    __encoding aarch32_STM_T2_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field P 15 +: 1
        __field M 14 +: 1
        __field register_list 0 +: 14
        __opcode '11101000 10x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;
            if registers<13> == '1' then UNPREDICTABLE;
            if registers<15> == '1' then UNPREDICTABLE;

    __execute __conditional
        address = R[n];
        for i = 0 to 14
            if registers<i> == '1' then
                if i == n && wback && i != LowestSetBit(registers) then
                    MemA[address,4] = bits(32) UNKNOWN;  // Only possible for encodings T1 and A1
                else
                    MemA[address,4] = R[i];
                address = address + 4;
        if registers<15> == '1' then  // Only possible for encoding A1
            MemA[address,4] = PCStoreValue();
        if wback then R[n] = R[n] + 4*BitCount(registers);

__instruction aarch32_VCGE_i_A
    __encoding aarch32_VCGE_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x00 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGE_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x00 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute __conditional
        CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                if floating_point then
                    bits(esize) zero = FPZero('0');
                    test_passed = FPCompareGE(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());
                else
                    test_passed = (SInt(Elem[D[m+r],e,esize]) >= 0);
                Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_STMDB_A
    __encoding aarch32_STMDB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1001 00x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __encoding aarch32_STMDB_T1_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field P 15 +: 1
        __field M 14 +: 1
        __field register_list 0 +: 14
        __opcode '11101001 00x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;
            if registers<13> == '1' then UNPREDICTABLE;
            if registers<15> == '1' then UNPREDICTABLE;

    __execute __conditional
        address = R[n] - 4*BitCount(registers);
        for i = 0 to 14
            if registers<i> == '1' then
                if i == n && wback && i != LowestSetBit(registers) then
                    MemA[address,4] = bits(32) UNKNOWN;  // Only possible for encoding A1
                else
                    MemA[address,4] = R[i];
                address = address + 4;
        if registers<15> == '1' then  // Only possible for encoding A1
            MemA[address,4] = PCStoreValue();
        if wback then R[n] = R[n] - 4*BitCount(registers);

__instruction aarch32_UHSUB8_A
    __encoding aarch32_UHSUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHSUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

    __execute __conditional
        diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);
        diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);
        diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);
        diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);
        R[d]<7:0>   = diff1<8:1>;
        R[d]<15:8>  = diff2<8:1>;
        R[d]<23:16> = diff3<8:1>;
        R[d]<31:24> = diff4<8:1>;

__instruction LDNT1D_Z.P.BR_Contiguous
    __encoding LDNT1D_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 100xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(64) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = X[m];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction aarch64_vector_transfer_vector_permute_zip
    __encoding aarch64_vector_transfer_vector_permute_zip
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field op 14 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx0xxxxx 0x1110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            integer part = UInt(op);
            integer pairs = elements DIV 2;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        integer base = part * pairs;
        
        for p = 0 to pairs-1
            Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];
            Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
        __instruction_set A64
        __field Q 30 +: 1
        __field S 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 111011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz == '1' then UNDEFINED;
            integer esize = 32;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean sub_op = (S == '1');
            integer part = 0;

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
        __instruction_set A64
        __field Q 30 +: 1
        __field S 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx1xxxxx 110011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz == '1' then UNDEFINED;
            integer esize = 32;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean sub_op = (S == '1');
            integer part = 1;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize DIV 2) operand1 = Vpart[n,part];
        bits(datasize DIV 2) operand2 = Vpart[m,part];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize DIV 2) element1;
        bits(esize DIV 2) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize DIV 2];
            element2 = Elem[operand2, e, esize DIV 2];
            if sub_op then element1 = FPNeg(element1);
            Elem[result,e,esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
        V[d] = result;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction aarch64_vector_transfer_integer_move_unsigned
    __encoding aarch64_vector_transfer_integer_move_unsigned
        __instruction_set A64
        __field Q 30 +: 1
        __field imm5 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 000xxxxx 001111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer size;
            case Q:imm5 of
                when '0xxxx1' size = 0;     // UMOV Wd, Vn.B
                when '0xxx10' size = 1;     // UMOV Wd, Vn.H
                when '0xx100' size = 2;     // UMOV Wd, Vn.S
                when '1x1000' size = 3;     // UMOV Xd, Vn.D
                otherwise     UNDEFINED;
            
            integer idxdsize = if imm5<4> == '1' then 128 else 64;
            integer index = UInt(imm5<4:size+1>);
            integer esize = 8 << size;
            integer datasize = if Q == '1' then 64 else 32;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(idxdsize) operand = V[n];
        
        X[d] = ZeroExtend(Elem[operand, index, esize], datasize);

__instruction FMIN_Z.P.ZS__
    __encoding FMIN_Z.P.ZS__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field i1 5 +: 1
        __field Zdn 0 +: 5
        __opcode '01100101 xx011111 100xxx00 00xxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMin(element1, imm, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_normal
    __encoding aarch64_memory_single_general_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_arithmetic_unary_diff_neg_fp16
    __encoding aarch64_vector_arithmetic_unary_diff_neg_fp16
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 11111000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean neg = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_diff_neg_float
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 1x100000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean neg = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            if neg then
                element = FPNeg(element);
            else
                element = FPAbs(element);
            Elem[result, e, esize] = element;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_cmp_int_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_cmp_int_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100000 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_int_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element;
        boolean test_passed;
        
        for e = 0 to elements-1
            element = SInt(Elem[operand, e, esize]);
            case comparison of
                when CompareOp_GT test_passed = element > 0;
                when CompareOp_GE test_passed = element >= 0;
                when CompareOp_EQ test_passed = element == 0;
                when CompareOp_LE test_passed = element <= 0;
                when CompareOp_LT test_passed = element < 0;
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_system_register_system
    __encoding aarch64_system_register_system
        __instruction_set A64
        __field L 21 +: 1
        __field o0 19 +: 1
        __field op1 16 +: 3
        __field CRn 12 +: 4
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __field Rt 0 +: 5
        __opcode '11010101 00x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);
            
            integer t = UInt(Rt);
            
            integer sys_op0 = 2 + UInt(o0);
            integer sys_op1 = UInt(op1);
            integer sys_op2 = UInt(op2);
            integer sys_crn = UInt(CRn);
            integer sys_crm = UInt(CRm);
            boolean read = (L == '1');

    __execute
        if read then
            X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);
        else
            AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);

__instruction RDFFR_P.P.F__
    __encoding RDFFR_P.P.F__
        __instruction_set A64
        __field Pg 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 00011000 1111000x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer g = UInt(Pg);
            integer d = UInt(Pd);
            boolean setflags = FALSE;

    __encoding RDFFRS_P.P.F__
        __instruction_set A64
        __field Pg 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 01011000 1111000x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer g = UInt(Pg);
            integer d = UInt(Pd);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        bits(PL) mask = P[g];
        bits(PL) ffr = FFR[];
        bits(PL) result = ffr AND mask;
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, 8);
        P[d] = result;

__instruction aarch64_vector_shift_right_sisd
    __encoding aarch64_vector_shift_right_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __encoding aarch64_vector_shift_right_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) operand2;
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        
        operand2 = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
            Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_float_arithmetic_div
    __encoding aarch64_float_arithmetic_div
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx 000110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        result = FPDiv(operand1, operand2, FPCR);
        
        V[d] = result;

__instruction aarch64_vector_crypto_sm3_sm3partw2
    __encoding aarch64_vector_crypto_sm3_sm3partw2
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 011xxxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSM3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        bits(128) Vd = V[d];
        bits(128) result; 
        bits(128) tmp;
        bits(32) tmp2;
        tmp<127:0> = Vn EOR (ROL(Vm<127:96>,7):ROL(Vm<95:64>,7):ROL(Vm<63:32>,7):ROL(Vm<31:0>,7)); 
        result<127:0> = Vd<127:0> EOR tmp<127:0>;
        tmp2 = ROL(tmp<31:0>,15);
        tmp2 = tmp2 EOR ROL(tmp2,15) EOR ROL(tmp2,23);
        result<127:96> = result<127:96> EOR tmp2;
        V[d]= result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_memory_single_general_immediate_signed_post_idx
    __encoding aarch64_memory_single_general_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111001 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction UCVTF_Z.P.Z_H2FP16
    __encoding UCVTF_Z.P.Z_H2FP16
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01010011 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 16;
            integer d_esize = 16;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding UCVTF_Z.P.Z_W2FP16
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01010101 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 16;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding UCVTF_Z.P.Z_W2S
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 10010101 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 32;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding UCVTF_Z.P.Z_W2D
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11010001 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 64;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding UCVTF_Z.P.Z_X2FP16
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01010111 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 16;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding UCVTF_Z.P.Z_X2S
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11010101 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 32;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding UCVTF_Z.P.Z_X2D
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11010111 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 64;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                bits(d_esize) fpval = FixedToFP(element<s_esize-1:0>, 0, unsigned, FPCR, rounding);
                Elem[result, e, esize] = ZeroExtend(fpval);
        
        Z[d] = result;

__instruction aarch64_memory_single_simdfp_immediate_signed_offset_normal
    __encoding aarch64_memory_single_simdfp_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111100 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(opc<1>:size);
            if scale > 4 then UNDEFINED;
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_VEC;
        MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        bits(64) address;
        bits(datasize) data;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                data = V[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                V[t] = data;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_branch_unconditional_register
    __encoding aarch64_branch_unconditional_register
        __instruction_set A64
        __field Z 24 +: 1
        __field op 21 +: 2
        __field A 11 +: 1
        __field M 10 +: 1
        __field Rn 5 +: 5
        __field Rm 0 +: 5
        __opcode '1101011x 0xx11111 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            BranchType branch_type;
            integer m = UInt(Rm);
            boolean pac = (A == '1');
            boolean use_key_a = (M == '0');
            boolean source_is_sp = ((Z == '1') && (m == 31));
            
            if !pac && m != 0 then 
                UNDEFINED;
            elsif pac && !HavePACExt() then 
                UNDEFINED;
            
            case op of
                when '00' branch_type = BranchType_INDIR;
                when '01' branch_type = BranchType_INDCALL;
                when '10' branch_type = BranchType_RET;
                otherwise UNDEFINED;
            
            if pac then
                if Z == '0' && m != 31 then
                    UNDEFINED;
            
                if branch_type == BranchType_RET then
                    if n != 31 then UNDEFINED;
                    n = 30;
                    source_is_sp = TRUE;

    __execute
        bits(64) target = X[n];
        if pac then
            bits(64) modifier = if source_is_sp then SP[] else X[m];
        
            if use_key_a then
                target = AuthIA(target, modifier);
            else
                target = AuthIB(target, modifier);
        
        if branch_type == BranchType_INDCALL then X[30] = PC[] + 4;
        
        // Value in BTypeNext will be used to set PSTATE.BTYPE
        case branch_type of
            when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ
                if InGuardedPage then
                    if n == 16 || n == 17 then
                        BTypeNext = '01';
                    else
                        BTypeNext = '11';
                else
                    BTypeNext = '01';
            when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ
                BTypeNext = '10';
            when BranchType_RET             // RET, RETAA, RETAB 
                BTypeNext = '00';
        
        BranchTo(target, branch_type);

__instruction aarch64_vector_arithmetic_unary_fp16_round
    __encoding aarch64_vector_arithmetic_unary_fp16_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __encoding aarch64_vector_arithmetic_unary_float_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_add_fp16
    __encoding aarch64_vector_arithmetic_binary_uniform_add_fp16
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 010xxxxx 000101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_add_fp
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 0x1xxxxx 110101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            if pair then
                element1 = Elem[concat, 2*e, esize];
                element2 = Elem[concat, (2*e)+1, esize];
            else
                element1 = Elem[operand1, e, esize];
                element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPAdd(element1, element2, FPCR);
        
        V[d] = result;

__instruction ASRR_Z.P.ZZ__
    __encoding ASRR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010100 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = UInt(Elem[operand1, e, esize]);
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = ASR(element2, element1);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_memory_single_general_immediate_signed_post_idx
    __encoding aarch64_memory_single_general_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111001 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction FCVTZS_Z.P.Z_FP162H
    __encoding FCVTZS_Z.P.Z_FP162H
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01011010 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 16;
            integer d_esize = 16;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZS_Z.P.Z_FP162W
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01011100 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 16;
            integer d_esize = 32;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZS_Z.P.Z_FP162X
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01011110 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 16;
            integer d_esize = 64;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZS_Z.P.Z_S2W
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 10011100 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 32;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZS_Z.P.Z_S2X
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11011100 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 64;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZS_Z.P.Z_D2W
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11011000 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 32;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZS_Z.P.Z_D2X
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11011110 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 64;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRounding_ZERO;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                bits(d_esize) res = FPToFixed(element<s_esize-1:0>, 0, unsigned, FPCR, rounding);
                Elem[result, e, esize] = Extend(res, unsigned);
        
        Z[d] = result;

__instruction SQDECH_R.RS_SX
    __encoding SQDECH_R.RS_SX
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0110xxxx 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 32;

    __encoding SQDECH_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0111xxxx 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction aarch64_vector_crypto_sha2op_sha1_sched1
    __encoding aarch64_vector_crypto_sha2op_sha1_sched1
        __instruction_set A64
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 00101000 000110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            if !HaveSHA1Ext() then UNDEFINED;

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) operand1 = V[d];
        bits(128) operand2 = V[n];
        bits(128) result;
        bits(128) T = operand1 EOR LSR(operand2, 32);
        result<31:0>   = ROL(T<31:0>,   1);
        result<63:32>  = ROL(T<63:32>,  1);
        result<95:64>  = ROL(T<95:64>,  1);
        result<127:96> = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);
        V[d] = result;

__instruction FACGT_P.P.ZZ__
    __encoding FACGT_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx0xxxxx 111xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GT;

    __encoding FACGE_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx0xxxxx 110xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                case op of
                    when Cmp_GE res = FPCompareGE(FPAbs(element1), FPAbs(element2), FPCR);
                    when Cmp_GT res = FPCompareGT(FPAbs(element1), FPAbs(element2), FPCR);
                ElemP[result, e, esize] = if res then '1' else '0';
            else
                ElemP[result, e, esize] = '0';
        
        P[d] = result;

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_binary_uniform_add_saturating_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_add_saturating_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 000011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_add_saturating_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 000011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer sum;
        boolean sat;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            sum = element1 + element2;
            (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction FMLS_Z.ZZZi_H
    __encoding FMLS_Z.ZZZi_H
        __instruction_set A64
        __field i3h 22 +: 1
        __field i3l 19 +: 2
        __field Zm 16 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100100 0x1xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer index = UInt(i3h:i3l);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean op1_neg = TRUE;
            boolean op3_neg = FALSE;

    __encoding FMLS_Z.ZZZi_S
        __instruction_set A64
        __field i2 19 +: 2
        __field Zm 16 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100100 101xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer index = UInt(i2);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean op1_neg = TRUE;
            boolean op3_neg = FALSE;

    __encoding FMLS_Z.ZZZi_D
        __instruction_set A64
        __field i1 20 +: 1
        __field Zm 16 +: 4
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100100 111xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer index = UInt(i1);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean op1_neg = TRUE;
            boolean op3_neg = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer eltspersegment = 128 DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result = Z[da];
        
        for e = 0 to elements-1
            integer segmentbase = e - e MOD eltspersegment;
            integer s = segmentbase + index;
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, s, esize];
            bits(esize) element3 = Elem[result, e, esize];
            if op1_neg then element1 = FPNeg(element1);
            if op3_neg then element3 = FPNeg(element3);
            Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
        
        Z[da] = result;

__instruction LDFF1D_Z.P.BZ_D.x32.scaled
    __encoding LDFF1D_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 1x1xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 3;

    __encoding LDFF1D_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 1x0xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1D_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 111xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 3;

    __encoding LDFF1D_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 110xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction LD4H_Z.P.BR_Contiguous
    __encoding LD4H_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 111xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction EXT_Z.ZI_Des
    __encoding EXT_Z.ZI_Des
        __instruction_set A64
        __field imm8h 16 +: 5
        __field imm8l 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000101 001xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dst = UInt(Zdn);
            integer s1 = dst;
            integer s2 = UInt(Zm);
            integer position = UInt(imm8h:imm8l);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[s1];
        bits(VL) operand2 = Z[s2];
        bits(VL) result;
        
        if position >= elements then
            position = 0;
        
        position = position << 3;
        bits(VL*2) concat = operand2 : operand1;
        result = concat<position+VL-1:position>;
        
        Z[dst] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_int_accum
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_accum
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 100101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        bits(esize) product;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            product = (UInt(element1) * UInt(element2))<esize-1:0>;
            if sub_op then
                Elem[result, e, esize] = Elem[operand3, e, esize] - product;
            else
                Elem[result, e, esize] = Elem[operand3, e, esize] + product;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_long
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 00x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        integer sum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            Elem[result, e, 2*esize] = sum<2*esize-1:0>;
        
        V[d] = result;

__instruction LD3H_Z.P.BI_Contiguous
    __encoding LD3H_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1100xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer offset = SInt(imm4);
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_vector_shift_right_narrow_nonuniform_sisd
    __encoding aarch64_vector_shift_right_narrow_nonuniform_sisd
        __instruction_set A64
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111111 0xxxxxxx 1000x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then UNDEFINED;
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');

    __encoding aarch64_vector_shift_right_narrow_nonuniform_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 0xxxxxxx 1000x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize*2) operand = V[n];
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
            (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);
            if sat then FPSR.QC = '1';
        
        Vpart[d, part] = result;

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_float_arithmetic_mul_product
    __encoding aarch64_float_arithmetic_mul_product
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field op 15 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx x00010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean negated = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        result = FPMul(operand1, operand2, FPCR);
        
        if negated then result = FPNeg(result);
        
        V[d] = result;

__instruction FSCALE_Z.P.ZZ__
    __encoding FSCALE_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx001001 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            integer element2 = SInt(Elem[operand2, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPScale(element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction ABS_Z.P.Z__
    __encoding ABS_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx010110 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            integer element = SInt(Elem[operand, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                element = Abs(element);
                Elem[result, e, esize] = element<esize-1:0>;
        
        Z[d] = result;

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_binary_element_dotp
    __encoding aarch64_vector_arithmetic_binary_element_dotp
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 xxxxxxxx 1110x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveDOTPExt() then UNDEFINED;
            if size  != '10' then UNDEFINED;
            boolean signed = (U=='0');
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(M:Rm);
            integer index = UInt(H:L);
            
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(128) operand2 = V[m];
        bits(datasize) result = V[d];
        for e = 0 to elements-1 
            integer res = 0;
            integer element1, element2;
            for i = 0 to 3
                if signed then  
                    element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
                    element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);
                else 
                    element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
                    element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);
                res = res + element1 * element2; 
            Elem[result, e, esize] = Elem[result, e, esize] + res;
        V[d] = result;

__instruction aarch64_vector_crypto_sm3_sm3tt2b
    __encoding aarch64_vector_crypto_sm3_sm3tt2b
        __instruction_set A64
        __field Rm 16 +: 5
        __field imm2 12 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 010xxxxx 10xx11xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSM3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer i = UInt(imm2);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        bits(128) Vd = V[d];
        bits(32) Wj;
        bits(128) result; 
        bits(32) TT2;
        
        Wj = Elem[Vm,i,32];
        TT2 = (Vd<127:96> AND Vd<95:64>) OR (NOT(Vd<127:96>) AND Vd<63:32>); 
        TT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>;
        
        result<31:0> = Vd<63:32>;
        result<63:32> = ROL(Vd<95:64>,19); 
        result<95:64> = Vd<127:96>; 
        result<127:96> = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); 
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
    __encoding aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
        __instruction_set A64
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 11111001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 1x100001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 11111001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __encoding aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 1x100001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx0xxxxx 100101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveDOTPExt() then UNDEFINED;
            if size!= '10' then UNDEFINED;
            boolean signed = (U=='0');
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        result = V[d];
        for e = 0 to elements-1 
            integer res = 0;
            integer element1, element2;
            for i = 0 to 3 
                if signed then
                    element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
                    element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);
                else 
                    element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
                    element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);
                res = res + element1 * element2; 
            Elem[result, e, esize] = Elem[result, e, esize] + res;
        V[d] = result;

__instruction LD1RQD_Z.P.BI_U64
    __encoding LD1RQD_Z.P.BI_U64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1000xxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = 128 DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g]; // low 16 bits only
        bits(128) result;
        constant integer mbytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * 16;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = Replicate(result, VL DIV 128);

__instruction aarch64_memory_single_general_immediate_signed_offset_lda_stl
    __encoding aarch64_memory_single_general_immediate_signed_offset_lda_stl
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx011001 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_ORDERED;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_float_arithmetic_max_min
    __encoding aarch64_float_arithmetic_max_min
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field op 12 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx 01xx10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            FPMaxMinOp operation;
            case op of
                when '00' operation = FPMaxMinOp_MAX;
                when '01' operation = FPMaxMinOp_MIN;
                when '10' operation = FPMaxMinOp_MAXNUM;
                when '11' operation = FPMaxMinOp_MINNUM;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        case operation of
            when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);
            when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);
            when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);
            when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_clsz
    __encoding aarch64_vector_arithmetic_unary_clsz
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 010010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        
        integer count;
        for e = 0 to elements-1
            if countop == CountOp_CLS then
                count = CountLeadingSignBits(Elem[operand, e, esize]);
            else
                count = CountLeadingZeroBits(Elem[operand, e, esize]);
            Elem[result, e, esize] = count<esize-1:0>;
        V[d] = result;

__instruction aarch64_memory_single_general_register
    __encoding aarch64_memory_single_general_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_branch_conditional_cond
    __encoding aarch64_branch_conditional_cond
        __instruction_set A64
        __field imm19 5 +: 19
        __field cond 0 +: 4
        __opcode '01010100 xxxxxxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __decode
            bits(64) offset = SignExtend(imm19:'00', 64);
            bits(4) condition = cond;

    __execute
        if ConditionHolds(condition) then
            BranchTo(PC[] + offset, BranchType_DIR);

__instruction aarch64_vector_shift_right_narrow_uniform_sisd
    __encoding aarch64_vector_shift_right_narrow_uniform_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 1001x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then UNDEFINED;
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_shift_right_narrow_uniform_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 1001x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize*2) operand = V[n];
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
            (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
            if sat then FPSR.QC = '1';
        
        Vpart[d, part] = result;

__instruction UQSUB_Z.ZI__
    __encoding UQSUB_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field sh 13 +: 1
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx100111 11xxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size:sh == '001' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer imm = UInt(imm8);
            if sh == '1' then imm = imm << 8;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 - imm, esize, unsigned);
        
        Z[dn] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_lda_stl
    __encoding aarch64_memory_single_general_immediate_signed_offset_lda_stl
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx011001 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_ORDERED;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_memory_single_general_immediate_signed_offset_normal
    __encoding aarch64_memory_single_general_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction MLS_Z.P.ZZZ__
    __encoding MLS_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '00000100 xx0xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean sub_op = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = UInt(Elem[operand1, e, esize]);
            integer element2 = UInt(Elem[operand2, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                integer product = element1 * element2;
                if sub_op then
                    Elem[result, e, esize] = Elem[operand3, e, esize] - product;
                else
                    Elem[result, e, esize] = Elem[operand3, e, esize] + product;
            else
                Elem[result, e, esize] = Elem[operand3, e, esize];
        
        Z[da] = result;

__instruction aarch64_integer_shift_variable
    __encoding aarch64_integer_shift_variable
        __instruction_set A64
        __field sf 31 +: 1
        __field Rm 16 +: 5
        __field op2 10 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011010 110xxxxx 0010xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            ShiftType shift_type = DecodeShift(op2);

    __execute
        bits(datasize) result;
        bits(datasize) operand2 = X[m];
        
        result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
        X[d] = result;

__instruction aarch64_integer_arithmetic_add_sub_shiftedreg
    __encoding aarch64_integer_arithmetic_add_sub_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field shift 22 +: 2
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01011 xx0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            
            if shift == '11' then UNDEFINED;
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        X[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp16_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field E 23 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x10xxxxx 0010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field E 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 1110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field E 23 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 0010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field E 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 1110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if abs then
                element1 = FPAbs(element1);
                element2 = FPAbs(element2);
            case cmp of
                when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
                when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
                when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp16_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field E 23 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x10xxxxx 0010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field E 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 1110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field E 23 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 0010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field E 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 1110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if abs then
                element1 = FPAbs(element1);
                element2 = FPAbs(element2);
            case cmp of
                when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
                when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
                when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_system_exceptions_runtime_smc
    __encoding aarch64_system_exceptions_runtime_smc
        __instruction_set A64
        __field imm16 5 +: 16
        __opcode '11010100 000xxxxx xxxxxxxx xxx00011'
        __guard TRUE
        __decode
            bits(16) imm = imm16;

    __execute
        AArch64.CheckForSMCUndefOrTrap(imm);
        
        if SCR_EL3.SMD == '1' then
            // SMC disabled
            AArch64.UndefinedFault();
        else
            AArch64.CallSecureMonitor(imm);

__instruction aarch64_vector_shift_left_long
    __encoding aarch64_vector_shift_left_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 101001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = UInt(immh:immb) - esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = Vpart[n, part];
        bits(datasize*2) result;
        integer element;
        
        for e = 0 to elements-1
            element = Int(Elem[operand, e, esize], unsigned) << shift;
            Elem[result, e, 2*esize] = element<2*esize-1:0>;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_complex
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_complex
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field rot 13 +: 2
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 xxxxxxxx 0xx1x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFCADDExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(M:Rm);
            if size == '00' || size == '11' then UNDEFINED;
            if size == '01' then index = UInt(H:L);
            if size == '10' then index = UInt(H);
            integer esize = 8 << UInt(size);
            if !HaveFP16Ext() && esize == 16 then UNDEFINED;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            if size == '10' && (L == '1' || Q == '0') then UNDEFINED; 
            if size == '01' && H == '1' && Q=='0' then UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        
        for e = 0 to (elements DIV 2) -1 
            case rot of 
                when '00'
                    element1 = Elem[operand2, index*2, esize]; 
                    element2 = Elem[operand1, e*2, esize];
                    element3 = Elem[operand2, index*2+1, esize];
                    element4 = Elem[operand1, e*2, esize];
                when '01'
                    element1 = FPNeg(Elem[operand2, index*2+1, esize]); 
                    element2 = Elem[operand1, e*2+1, esize];
                    element3 = Elem[operand2, index*2, esize];
                    element4 = Elem[operand1, e*2+1, esize];
                when '10'
                    element1 = FPNeg(Elem[operand2, index*2,esize]); 
                    element2 = Elem[operand1, e*2, esize];
                    element3 = FPNeg(Elem[operand2, index*2+1, esize]);
                    element4 = Elem[operand1, e*2, esize];
                when '11'
                    element1 = Elem[operand2, index*2+1, esize]; 
                    element2 = Elem[operand1, e*2+1, esize];
                    element3 = FPNeg(Elem[operand2, index*2, esize]);
                    element4 = Elem[operand1, e*2+1, esize];
        
            Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, FPCR);
            Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);
        
        V[d] = result;

__instruction UDIVR_Z.P.ZZ__
    __encoding UDIVR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010111 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '0x' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer quotient;
                if element1 == 0 then
                    quotient = 0;
                else
                    quotient = RoundTowardsZero(Real(element2) / Real(element1));
                Elem[result, e, esize] = quotient<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_unary_float_xtn_sisd
    __encoding aarch64_vector_arithmetic_unary_float_xtn_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 0x100001 011010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz == '0' then UNDEFINED;
            integer esize = 32;
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;

    __encoding aarch64_vector_arithmetic_unary_float_xtn_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 0x100001 011010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz == '0' then UNDEFINED;
            integer esize = 32;
            integer datasize = 64;
            integer elements = 2;
            integer part = UInt(Q);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand = V[n];
        bits(datasize) result;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR, FPRounding_ODD);
        
        Vpart[d, part] = result;

__instruction ASR_Z.ZW__
    __encoding ASR_Z.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 100000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            integer element2 = UInt(Elem[operand2, (e * esize) DIV 64, 64]);
            Elem[result, e, esize] = ASR(element1, element2);
        
        Z[d] = result;

__instruction UMIN_Z.P.ZZ__
    __encoding UMIN_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx001011 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer minimum = Min(element1, element2);
                Elem[result, e, esize] = minimum<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction ST2W_Z.P.BR_Contiguous
    __encoding ST2W_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 001xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_integer_arithmetic_address_pc_rel
    __encoding aarch64_integer_arithmetic_address_pc_rel
        __instruction_set A64
        __field op 31 +: 1
        __field immlo 29 +: 2
        __field immhi 5 +: 19
        __field Rd 0 +: 5
        __opcode 'xxx10000 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            boolean page = (op == '1');
            bits(64) imm;
            
            if page then
                imm = SignExtend(immhi:immlo:Zeros(12), 64);
            else
                imm = SignExtend(immhi:immlo, 64);

    __execute
        bits(64) base = PC[];
        
        if page then
            base<11:0> = Zeros(12);
        
        X[d] = base + imm;

__instruction aarch64_vector_transfer_vector_permute_transpose
    __encoding aarch64_vector_transfer_vector_permute_transpose
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field op 14 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx0xxxxx 0x1010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            integer part = UInt(op);
            integer pairs = elements DIV 2;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        for p = 0 to pairs-1
            Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];
            Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];
        
        V[d] = result;

__instruction LD2D_Z.P.BI_Contiguous
    __encoding LD2D_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1010xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer offset = SInt(imm4);
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction UQDECW_Z.ZS__
    __encoding UQDECW_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1010xxxx 110011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_unary_cnt
    __encoding aarch64_vector_arithmetic_unary_cnt
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx100000 010110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size != '00' then UNDEFINED;
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV 8;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        
        integer count;
        for e = 0 to elements-1
            count = BitCount(Elem[operand, e, esize]);
            Elem[result, e, esize] = count<esize-1:0>;
        V[d] = result;

__instruction INDEX_Z.II__
    __encoding INDEX_Z.II__
        __instruction_set A64
        __field size 22 +: 2
        __field imm5b 16 +: 5
        __field imm5 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 010000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer d = UInt(Zd);
            integer imm1 = SInt(imm5);
            integer imm2 = SInt(imm5b);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) result;
        
        for e = 0 to elements-1
            integer index = imm1 + e * imm2;
            Elem[result, e, esize] = index<esize-1:0>;
        
        Z[d] = result;

__instruction EOR_Z.P.ZZ__
    __encoding EOR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx011001 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = element1 EOR element2;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_extract_sat_sisd
    __encoding aarch64_vector_arithmetic_unary_extract_sat_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100001 010010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer part = 0;
            integer elements = 1;
            
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_extract_sat_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 010010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand = V[n];
        bits(datasize) result;
        bits(2*esize) element;
        boolean sat;
        
        for e = 0 to elements-1
            element = Elem[operand, e, 2*esize];
            (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);
            if sat then FPSR.QC = '1';
        
        Vpart[d, part] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_sub_int
    __encoding aarch64_vector_arithmetic_binary_uniform_sub_int
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 001001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer diff;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            diff = element1 - element2;
            Elem[result, e, esize] = diff<esize:1>;
        
        V[d] = result;

__instruction aarch64_integer_pac_strip_dp_1src
    __encoding aarch64_integer_pac_strip_dp_1src
        __instruction_set A64
        __field D 10 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11011010 11000001 01000xxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean data = (D == '1');
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if !HavePACExt() then
                UNDEFINED;
            
            if n != 31 then UNDEFINED;

    __encoding aarch64_integer_pac_strip_hint
        __instruction_set A64
        __opcode '11010101 00000011 00100000 11111111'
        __guard TRUE
        __decode
            integer d = 30;
            boolean data = FALSE;

    __execute
        if HavePACExt() then
            X[d] = Strip(X[d], data);

__instruction FSQRT_Z.P.Z__
    __encoding FSQRT_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx001101 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPSqrt(element, FPCR);
        
        Z[d] = result;

__instruction UZP1_Z.ZZ__
    __encoding UZP1_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx1xxxxx 011010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            integer part = 0;

    __encoding UZP2_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx1xxxxx 011011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            integer part = 1;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        bits(VL*2) zipped = operand2:operand1;
        for e = 0 to elements-1
            Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];
        
        Z[d] = result;

__instruction STNT1H_Z.P.BI_Contiguous
    __encoding STNT1H_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 1001xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        constant integer mbytes = esize DIV 8;
        bits(VL) src;
        bits(PL) mask = P[g];
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        src = Z[t];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
            addr = addr + mbytes;

__instruction LD1RQW_Z.P.BI_U32
    __encoding LD1RQW_Z.P.BI_U32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0000xxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = 128 DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g]; // low 16 bits only
        bits(128) result;
        constant integer mbytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * 16;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = Replicate(result, VL DIV 128);

__instruction FCMEQ_P.P.Z0__
    __encoding FCMEQ_P.P.Z0__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx010010 001xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_EQ;

    __encoding FCMGT_P.P.Z0__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx010000 001xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GT;

    __encoding FCMGE_P.P.Z0__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx010000 001xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GE;

    __encoding FCMLT_P.P.Z0__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx010001 001xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_LT;

    __encoding FCMLE_P.P.Z0__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx010001 001xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_LE;

    __encoding FCMNE_P.P.Z0__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx010011 001xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_NE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(PL) result;
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                case op of
                    when Cmp_EQ res = FPCompareEQ(element, 0<esize-1:0>, FPCR);
                    when Cmp_GE res = FPCompareGE(element, 0<esize-1:0>, FPCR);
                    when Cmp_GT res = FPCompareGT(element, 0<esize-1:0>, FPCR);
                    when Cmp_NE res = FPCompareNE(element, 0<esize-1:0>, FPCR);
                    when Cmp_LT res = FPCompareGT(0<esize-1:0>, element, FPCR);
                    when Cmp_LE res = FPCompareGE(0<esize-1:0>, element, FPCR);
                ElemP[result, e, esize] = if res then '1' else '0';
            else
                ElemP[result, e, esize] = '0';
        
        P[d] = result;

__instruction LDFF1B_Z.P.AI_S
    __encoding LDFF1B_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 001xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __encoding LDFF1B_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 001xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_unary_special_recip_int
    __encoding aarch64_vector_arithmetic_unary_special_recip_int
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 1x100001 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz == '1' then UNDEFINED;
            integer esize = 32;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(32) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, 32];
            Elem[result, e, 32] = UnsignedRecipEstimate(element);
        
        V[d] = result;

__instruction LDFF1B_Z.P.BR_U8
    __encoding LDFF1B_Z.P.BR_U8
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 000xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;
            integer msize = 8;
            boolean unsigned = TRUE;

    __encoding LDFF1B_Z.P.BR_U16
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 001xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 8;
            boolean unsigned = TRUE;

    __encoding LDFF1B_Z.P.BR_U32
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 010xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = TRUE;

    __encoding LDFF1B_Z.P.BR_U64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 011xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + UInt(offset) * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            offset = offset + 1;
        
        Z[t] = result;

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_crypto_sha3op_sha1_hash_majority
    __encoding aarch64_vector_crypto_sha3op_sha1_hash_majority
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 000xxxxx 001000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if !HaveSHA1Ext() then UNDEFINED;

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) X = V[d];
        bits(32)  Y = V[n];     // Note: 32 not 128 bits wide
        bits(128) W = V[m];
        bits(32)  t;
        
        for e = 0 to 3
            t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);
            Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
            X<63:32> = ROL(X<63:32>, 30);
            <Y, X> = ROL(Y : X, 32);
        V[d] = X;

__instruction aarch64_system_sysops
    __encoding aarch64_system_sysops
        __instruction_set A64
        __field L 21 +: 1
        __field op1 16 +: 3
        __field CRn 12 +: 4
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __field Rt 0 +: 5
        __opcode '11010101 00x01xxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);
            
            integer t = UInt(Rt);
            
            integer sys_op0 = 1;
            integer sys_op1 = UInt(op1);
            integer sys_op2 = UInt(op2);
            integer sys_crn = UInt(CRn);
            integer sys_crm = UInt(CRm);
            boolean has_result = (L == '1');

    __execute
        if has_result then
            X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);
        else
            AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);

__instruction REV_P.P__
    __encoding REV_P.P__
        __instruction_set A64
        __field size 22 +: 2
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00000101 xx110100 0100000x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Pn);
            integer d = UInt(Pd);

    __execute
        CheckSVEEnabled();
        bits(PL) operand = P[n];
        bits(PL) result = Reverse(operand, esize DIV 8);
        P[d] = result;

__instruction SPLICE_Z.P.ZZ_Des
    __encoding SPLICE_Z.P.ZZ_Des
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000101 xx101100 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dst = UInt(Zdn);
            integer s1 = dst;
            integer s2 = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[s1];
        bits(VL) operand2 = Z[s2];
        bits(VL) result;
        integer x = 0;
        boolean active = FALSE;
        integer lastnum = LastActiveElement(mask, esize);
        
        if lastnum >= 0 then
            for e = 0 to lastnum
                active = active || ElemP[mask, e, esize] == '1';
                if active then
                    Elem[result, x, esize] = Elem[operand1, e, esize];
                    x = x + 1;
        
        elements = elements - x - 1;
        for e = 0 to elements
            Elem[result, x, esize] = Elem[operand2, e, esize];
            x = x + 1;
        
        Z[dst] = result;

__instruction CNT_Z.P.Z__
    __encoding CNT_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx011010 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = BitCount(element)<esize-1:0>;
        
        Z[d] = result;

__instruction SQDECB_R.RS_SX
    __encoding SQDECB_R.RS_SX
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0010xxxx 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 32;

    __encoding SQDECB_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0011xxxx 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction UQINCD_Z.ZS__
    __encoding UQINCD_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1110xxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction PRFH_I.P.BZ_S.x32.scaled
    __encoding PRFH_I.P.BZ_S.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000100 0x1xxxxx 001xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 32;
            boolean offs_unsigned = (xs == '0');
            integer scale = 1;

    __encoding PRFH_I.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000100 0x1xxxxx 001xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 32;
            boolean offs_unsigned = (xs == '0');
            integer scale = 1;

    __encoding PRFH_I.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000100 011xxxxx 101xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 1;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);

__instruction aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 110xxxxx 001111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 1x1xxxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 110xxxxx 001111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __encoding aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 1x1xxxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);
        
        V[d] = result;

__instruction LDFF1SW_Z.P.BZ_D.x32.scaled
    __encoding LDFF1SW_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 0x1xxxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 2;

    __encoding LDFF1SW_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 0x0xxxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1SW_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 011xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 64;
            boolean unsigned = FALSE;
            boolean offs_unsigned = TRUE;
            integer scale = 2;

    __encoding LDFF1SW_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 010xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 64;
            boolean unsigned = FALSE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction aarch64_vector_logical
    __encoding aarch64_vector_logical
        __instruction_set A64
        __field Q 30 +: 1
        __field op 29 +: 1
        __field a 18 +: 1
        __field b 17 +: 1
        __field c 16 +: 1
        __field cmode 12 +: 4
        __field d 9 +: 1
        __field e 8 +: 1
        __field f 7 +: 1
        __field g 6 +: 1
        __field h 5 +: 1
        __field Rd 0 +: 5
        __opcode '0xx01111 00000xxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer rd = UInt(Rd);
            
            integer datasize = if Q == '1' then 128 else 64;
            bits(datasize) imm;
            bits(64) imm64;
            
            ImmediateOp operation;
            case cmode:op of
                when '0xx00' operation = ImmediateOp_MOVI;
                when '0xx01' operation = ImmediateOp_MVNI;
                when '0xx10' operation = ImmediateOp_ORR;
                when '0xx11' operation = ImmediateOp_BIC;
                when '10x00' operation = ImmediateOp_MOVI;
                when '10x01' operation = ImmediateOp_MVNI;
                when '10x10' operation = ImmediateOp_ORR;
                when '10x11' operation = ImmediateOp_BIC;
                when '110x0' operation = ImmediateOp_MOVI;
                when '110x1' operation = ImmediateOp_MVNI;
                when '1110x' operation = ImmediateOp_MOVI;
                when '11110' operation = ImmediateOp_MOVI;
                when '11111' 
                    // FMOV Dn,#imm is in main FP instruction set
                    if Q == '0' then UNDEFINED;
                    operation = ImmediateOp_MOVI;
            
            imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
            imm = Replicate(imm64, datasize DIV 64);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand;
        bits(datasize) result;
        
        case operation of
            when ImmediateOp_MOVI
                result = imm;
            when ImmediateOp_MVNI
                result = NOT(imm);
            when ImmediateOp_ORR
                operand = V[rd];
                result = operand OR imm;
            when ImmediateOp_BIC
                operand = V[rd];
                result = operand AND NOT(imm);
        
        V[rd] = result;

__instruction ST1H_Z.P.BZ_S.x32.scaled
    __encoding ST1H_Z.P.BZ_S.x32.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 111xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 1;

    __encoding ST1H_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 101xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 1;

    __encoding ST1H_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 100xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding ST1H_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 110xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding ST1H_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 101xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 1;

    __encoding ST1H_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 100xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(VL) offset = Z[m];
        bits(VL) src = Z[t];
        bits(PL) mask = P[g];
        bits(64) addr;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;

__instruction ST2D_Z.P.BR_Contiguous
    __encoding ST2D_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 101xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction SMULH_Z.P.ZZ__
    __encoding SMULH_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010010 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer product = (element1 * element2) >> esize;
                Elem[result, e, esize] = product<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction LD2W_Z.P.BI_Contiguous
    __encoding LD2W_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0010xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer offset = SInt(imm4);
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction BIC_Z.P.ZZ__
    __encoding BIC_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx011011 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = element1 AND (NOT element2);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_float_arithmetic_round_frint
    __encoding aarch64_float_arithmetic_round_frint
        __instruction_set A64
        __field type1 22 +: 2
        __field rmode 15 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1001xx x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case rmode of
                when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundInt(operand, FPCR, rounding, exact);
        
        V[d] = result;

__instruction CMPEQ_P.P.ZI__
    __encoding CMPEQ_P.P.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx0xxxxx 100xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_EQ;
            integer imm = SInt(imm5);
            boolean unsigned = FALSE;

    __encoding CMPGT_P.P.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx0xxxxx 000xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GT;
            integer imm = SInt(imm5);
            boolean unsigned = FALSE;

    __encoding CMPGE_P.P.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx0xxxxx 000xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GE;
            integer imm = SInt(imm5);
            boolean unsigned = FALSE;

    __encoding CMPHI_P.P.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm7 14 +: 7
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx1xxxxx xx0xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GT;
            integer imm = UInt(imm7);
            boolean unsigned = TRUE;

    __encoding CMPHS_P.P.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm7 14 +: 7
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx1xxxxx xx0xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GE;
            integer imm = UInt(imm7);
            boolean unsigned = TRUE;

    __encoding CMPLT_P.P.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx0xxxxx 001xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_LT;
            integer imm = SInt(imm5);
            boolean unsigned = FALSE;

    __encoding CMPLE_P.P.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx0xxxxx 001xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_LE;
            integer imm = SInt(imm5);
            boolean unsigned = FALSE;

    __encoding CMPLO_P.P.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm7 14 +: 7
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx1xxxxx xx1xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_LT;
            integer imm = UInt(imm7);
            boolean unsigned = TRUE;

    __encoding CMPLS_P.P.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm7 14 +: 7
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx1xxxxx xx1xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_LE;
            integer imm = UInt(imm7);
            boolean unsigned = TRUE;

    __encoding CMPNE_P.P.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx0xxxxx 100xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Pd);
            SVECmp op = Cmp_NE;
            integer imm = SInt(imm5);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(PL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                boolean cond;
                case op of
                    when Cmp_EQ cond = element1 == imm;
                    when Cmp_NE cond = element1 != imm;
                    when Cmp_GE cond = element1 >= imm;
                    when Cmp_LT cond = element1 <  imm;
                    when Cmp_GT cond = element1 >  imm;
                    when Cmp_LE cond = element1 <= imm;
                ElemP[result, e, esize] = if cond then '1' else '0';
            else
                ElemP[result, e, esize] = '0';
        
        PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction ASRD_Z.P.ZI__
    __encoding ASRD_Z.P.ZI__
        __instruction_set A64
        __field tszh 22 +: 2
        __field Pg 10 +: 3
        __field tszl 8 +: 2
        __field imm3 5 +: 3
        __field Zdn 0 +: 5
        __opcode '00000100 xx000100 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            bits(4) tsize = tszh:tszl;
            case tsize of
                when '0000' UNDEFINED;
                when '0001' esize = 8;
                when '001x' esize = 16;
                when '01xx' esize = 32;
                when '1xxx' esize = 64;
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer shift = (2 * esize) - UInt(tsize:imm3);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = SInt(Elem[operand1, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                if element1 < 0 then
                    element1 = element1 + ((1 << shift) - 1);
                Elem[result, e, esize] = (element1 >> shift)<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction LD1RSB_Z.P.BI_S16
    __encoding LD1RSB_Z.P.BI_S16
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 11xxxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = UInt(imm6);

    __encoding LD1RSB_Z.P.BI_S32
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 11xxxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = UInt(imm6);

    __encoding LD1RSB_Z.P.BI_S64
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 11xxxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = UInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        integer last = LastActiveElement(mask, esize);
        if last >= 0 then
            addr = base + offset * mbytes;
            data = Mem[addr, mbytes, AccType_NORMAL];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_int
    __encoding aarch64_vector_arithmetic_binary_element_mul_int
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 xxxxxxxx 1000x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        bits(esize) product;
        
        element2 = UInt(Elem[operand2, index, esize]);
        for e = 0 to elements-1
            element1 = UInt(Elem[operand1, e, esize]);
            product = (element1 * element2)<esize-1:0>;
            Elem[result, e, esize] = product;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_integer_flags_setf
    __encoding aarch64_integer_flags_setf
        __instruction_set A64
        __field sf 31 +: 1
        __field sz 14 +: 1
        __field Rn 5 +: 5
        __opcode 'x0111010 00000000 0x0010xx xxx01101'
        __guard TRUE
        __decode
            if !HaveFlagManipulateExt() || sf != '0' then UNDEFINED;
            integer msb = if sz=='1' then 15 else 7;
            integer n = UInt(Rn);

    __execute
        bits(32) tmpreg = X[n];
        PSTATE.N = tmpreg<msb>;
        PSTATE.Z = if (tmpreg<msb:0> == Zeros(msb+1)) then '1' else '0';
        PSTATE.V = tmpreg<msb+1> EOR tmpreg<msb>;
        //PSTATE.C unchanged;

__instruction UQDECP_R.P.R_UW
    __encoding UQDECP_R.P.R_UW
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Rdn 0 +: 5
        __opcode '00100101 xx101011 1000100x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);
            boolean unsigned = TRUE;
            integer ssize = 32;

    __encoding UQDECP_R.P.R_X
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Rdn 0 +: 5
        __opcode '00100101 xx101011 1000110x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);
            boolean unsigned = TRUE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(ssize) operand = X[dn];
        bits(ssize) result;
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        integer element = Int(operand, unsigned);
        (result, -) = SatQ(element - count, ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction LD1RB_Z.P.BI_U8
    __encoding LD1RB_Z.P.BI_U8
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 01xxxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = UInt(imm6);

    __encoding LD1RB_Z.P.BI_U16
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 01xxxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = UInt(imm6);

    __encoding LD1RB_Z.P.BI_U32
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 01xxxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = UInt(imm6);

    __encoding LD1RB_Z.P.BI_U64
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 01xxxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = UInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        integer last = LastActiveElement(mask, esize);
        if last >= 0 then
            addr = base + offset * mbytes;
            data = Mem[addr, mbytes, AccType_NORMAL];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_vector_reduce_add_long
    __encoding aarch64_vector_reduce_add_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx110000 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '100' then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        integer sum;
        
        sum = Int(Elem[operand, 0, esize], unsigned);
        for e = 1 to elements-1
            sum = sum + Int(Elem[operand, e, esize], unsigned);
        
        V[d] = sum<2*esize-1:0>;

__instruction LDFF1SB_Z.P.BR_S16
    __encoding LDFF1SB_Z.P.BR_S16
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 110xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 8;
            boolean unsigned = FALSE;

    __encoding LDFF1SB_Z.P.BR_S32
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 101xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = FALSE;

    __encoding LDFF1SB_Z.P.BR_S64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 100xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + UInt(offset) * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            offset = offset + 1;
        
        Z[t] = result;

__instruction LDFF1SB_Z.P.AI_S
    __encoding LDFF1SB_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 001xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = UInt(imm5);

    __encoding LDFF1SB_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 001xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction LSR_Z.ZW__
    __encoding LSR_Z.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 100001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            integer element2 = UInt(Elem[operand2, (e * esize) DIV 64, 64]);
            Elem[result, e, esize] = LSR(element1, element2);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_unary_clsz
    __encoding aarch64_vector_arithmetic_unary_clsz
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 010010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        
        integer count;
        for e = 0 to elements-1
            if countop == CountOp_CLS then
                count = CountLeadingSignBits(Elem[operand, e, esize]);
            else
                count = CountLeadingZeroBits(Elem[operand, e, esize]);
            Elem[result, e, esize] = count<esize-1:0>;
        V[d] = result;

__instruction aarch64_integer_arithmetic_mul_widening_32_64
    __encoding aarch64_integer_arithmetic_mul_widening_32_64
        __instruction_set A64
        __field U 23 +: 1
        __field Rm 16 +: 5
        __field o0 15 +: 1
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '10011011 x01xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer a = UInt(Ra);
            integer destsize = 64;
            integer datasize = 32;
            boolean sub_op = (o0 == '1');
            boolean unsigned = (U == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(destsize) operand3 = X[a];
        
        integer result;
        
        if sub_op then
            result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));
        else
            result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));
        
        X[d] = result<63:0>;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction LDNT1W_Z.P.BR_Contiguous
    __encoding LDNT1W_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 000xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(64) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = X[m];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction aarch64_memory_atomicops_cas_single
    __encoding aarch64_memory_atomicops_cas_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x1xxxxx x11111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) comparevalue;
        bits(datasize) newvalue;
        bits(datasize) data;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        comparevalue = X[s];
        newvalue = X[t];
        
        if n == 31 then 
            CheckSPAlignment(); 
            address = SP[];
        else 
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data = Mem[address, datasize DIV 8, ldacctype];
        if data == comparevalue then  
            Mem[address, datasize DIV 8, stacctype] = newvalue;
        
        X[s] = ZeroExtend(data, regsize);

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction SQSUB_Z.ZZ__
    __encoding SQSUB_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 000110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 - element2, esize, unsigned);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_mul_accum
    __encoding aarch64_vector_arithmetic_binary_disparate_mul_accum
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 10x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        bits(2*esize) accum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            product = (element1 * element2)<2*esize-1:0>;
            if sub_op then
                accum = Elem[operand3, e, 2*esize] - product;
            else
                accum = Elem[operand3, e, 2*esize] + product;
            Elem[result, e, 2*esize] = accum;
        
        V[d] = result;

__instruction aarch64_vector_crypto_aes_round
    __encoding aarch64_vector_crypto_aes_round
        __instruction_set A64
        __field D 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01001110 00101000 010x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            if !HaveAESExt() then UNDEFINED;
            boolean decrypt = (D == '1');

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) operand1 = V[d];
        bits(128) operand2 = V[n];
        bits(128) result;
        result = operand1 EOR operand2;
        if decrypt then
            result = AESInvSubBytes(AESInvShiftRows(result));
        else
            result = AESSubBytes(AESShiftRows(result));
        
        V[d] = result;

__instruction aarch64_memory_single_general_register
    __encoding aarch64_memory_single_general_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction REV_Z.Z__
    __encoding REV_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx111000 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        bits(VL) operand = Z[n];
        bits(VL) result = Reverse(operand, esize);
        Z[d] = result;

__instruction aarch64_integer_logical_shiftedreg
    __encoding aarch64_integer_logical_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field shift 22 +: 2
        __field N 21 +: 1
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01010 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);
            boolean invert = (N == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        X[d] = result;

__instruction ST4H_Z.P.BI_Contiguous
    __encoding ST4H_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 1111xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer offset = SInt(imm4);
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction LDFF1W_Z.P.BZ_S.x32.scaled
    __encoding LDFF1W_Z.P.BZ_S.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 0x1xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 2;

    __encoding LDFF1W_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 0x1xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 2;

    __encoding LDFF1W_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 0x0xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1W_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 0x0xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1W_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 011xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 2;

    __encoding LDFF1W_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 010xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction ST3H_Z.P.BR_Contiguous
    __encoding ST3H_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 110xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_narrow
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_narrow
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 01x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean round = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand1 = V[n];
        bits(2*datasize) operand2 = V[m];
        bits(datasize)   result;
        integer round_const = if round then 1 << (esize - 1) else 0;
        bits(2*esize) element1;
        bits(2*esize) element2;
        bits(2*esize) sum;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, 2*esize];
            element2 = Elem[operand2, e, 2*esize];
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            sum = sum + round_const;
            Elem[result, e, esize] = sum<2*esize-1:esize>;
        
        Vpart[d, part] = result;

__instruction aarch64_memory_single_general_register
    __encoding aarch64_memory_single_general_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_float_arithmetic_unary
    __encoding aarch64_float_arithmetic_unary
        __instruction_set A64
        __field type1 22 +: 2
        __field opc 15 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx10000x x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            FPUnaryOp fpop;
            case opc of
                when '00' fpop = FPUnaryOp_MOV;
                when '01' fpop = FPUnaryOp_ABS;
                when '10' fpop = FPUnaryOp_NEG;
                when '11' fpop = FPUnaryOp_SQRT;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        case fpop of
            when FPUnaryOp_MOV  result = operand;
            when FPUnaryOp_ABS  result = FPAbs(operand);
            when FPUnaryOp_NEG  result = FPNeg(operand);
            when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);
        
        V[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_lda_stl
    __encoding aarch64_memory_single_general_immediate_signed_offset_lda_stl
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx011001 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_ORDERED;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_memory_single_general_immediate_signed_offset_unpriv
    __encoding aarch64_memory_single_general_immediate_signed_offset_unpriv
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        
        unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
        unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
        
        user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
        if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
            acctype = AccType_UNPRIV;
        else
            acctype = AccType_NORMAL;
        
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction DECP_R.P.R__
    __encoding DECP_R.P.R__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Rdn 0 +: 5
        __opcode '00100101 xx101101 1000100x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) operand = X[dn];
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        X[dn] = operand - count;

__instruction aarch64_memory_single_general_immediate_signed_offset_normal
    __encoding aarch64_memory_single_general_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_integer_logical_shiftedreg
    __encoding aarch64_integer_logical_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field shift 22 +: 2
        __field N 21 +: 1
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01010 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);
            boolean invert = (N == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        X[d] = result;

__instruction aarch64_vector_arithmetic_unary_add_pairwise
    __encoding aarch64_vector_arithmetic_unary_add_pairwise
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 14 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 0x1010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV (2*esize);
            boolean acc = (op == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        
        bits(2*esize) sum;
        integer op1;
        integer op2;
        
        result = if acc then V[d] else Zeros();
        for e = 0 to elements-1
            op1 = Int(Elem[operand, 2*e+0, esize], unsigned);
            op2 = Int(Elem[operand, 2*e+1, esize], unsigned);
            sum = (op1 + op2)<2*esize-1:0>;
            Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;
        
        V[d] = result;

__instruction RDFFR_P.F__
    __encoding RDFFR_P.F__
        __instruction_set A64
        __field Pd 0 +: 4
        __opcode '00100101 00011001 11110000 0000xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer d = UInt(Pd);

    __execute
        CheckSVEEnabled();
        bits(PL) ffr = FFR[];
        P[d] = ffr;

__instruction aarch64_integer_ins_ext_extract_immediate
    __encoding aarch64_integer_ins_ext_extract_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field N 22 +: 1
        __field Rm 16 +: 5
        __field imms 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0010011 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            integer lsb;
            
            if N != sf then UNDEFINED;
            if sf == '0' && imms<5> == '1' then UNDEFINED;
            lsb = UInt(imms);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(2*datasize) concat = operand1:operand2;
        
        result = concat<lsb+datasize-1:lsb>;
        
        X[d] = result;

__instruction aarch64_memory_vector_multiple_no_wb
    __encoding aarch64_memory_vector_multiple_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 0x000000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_multiple_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field Rm 16 +: 5
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << UInt(size);
        integer elements = datasize DIV esize;
        
        integer rpt;    // number of iterations
        integer selem;  // structure elements 
        
        case opcode of
            when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
            when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
            when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
            when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
            when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
            when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
            when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
            otherwise UNDEFINED;
        
        // .1D format only permitted with LD1 & ST1
        if size:Q == '110' && selem != 1 then UNDEFINED;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(datasize) rval;
        integer tt;
        constant integer ebytes = esize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        for r = 0 to rpt-1
            for e = 0 to elements-1
                tt = (t + r) MOD 32;
                for s = 0 to selem-1
                    rval = V[tt];
                    if memop == MemOp_LOAD then
                        Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                        V[tt] = rval;
                    else // memop == MemOp_STORE
                        Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                    offs = offs + ebytes;
                    tt = (tt + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_integer_tags_mcsettagpairandzerodatapost
    __encoding aarch64_integer_tags_mcsettagpairandzerodatapost
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 111xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = TRUE;
            boolean postindex = TRUE;
            boolean zero_data = TRUE;

    __encoding aarch64_integer_tags_mcsettagpairandzerodatapre
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 111xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = TRUE;
            boolean postindex = FALSE;
            boolean zero_data = TRUE;

    __encoding aarch64_integer_tags_mcsettagpairandzerodata
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 111xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = FALSE;
            boolean postindex = FALSE;
            boolean zero_data = TRUE;

    __execute
        bits(64) address;
        bits(4) tag;
        
        SetNotTagCheckedInstruction(TRUE);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if !postindex then
            address = address + offset;
        
        if zero_data then
            Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);
            Mem[address+TAG_GRANULE, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);
        
        tag = AllocationTagFromAddress(address);
        MemTag[address] = tag;
        MemTag[address+TAG_GRANULE] = tag;
        
        if writeback then
            if postindex then
                address = address + offset;
        
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_float_arithmetic_round_frint
    __encoding aarch64_float_arithmetic_round_frint
        __instruction_set A64
        __field type1 22 +: 2
        __field rmode 15 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1001xx x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case rmode of
                when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundInt(operand, FPCR, rounding, exact);
        
        V[d] = result;

__instruction aarch64_integer_tags_mcsettagandzerodatapost
    __encoding aarch64_integer_tags_mcsettagandzerodatapost
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 011xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = TRUE;
            boolean postindex = TRUE;
            boolean zero_data = TRUE;

    __encoding aarch64_integer_tags_mcsettagandzerodatapre
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 011xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = TRUE;
            boolean postindex = FALSE;
            boolean zero_data = TRUE;

    __encoding aarch64_integer_tags_mcsettagandzerodata
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 011xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = FALSE;
            boolean postindex = FALSE;
            boolean zero_data = TRUE;

    __execute
        bits(64) address;
        
        SetNotTagCheckedInstruction(TRUE);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if !postindex then
            address = address + offset;
        
        if zero_data then
            Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(TAG_GRANULE * 8);
        
        MemTag[address] = AllocationTagFromAddress(address);
        
        if writeback then
            if postindex then
                address = address + offset;
        
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_arithmetic_binary_element_mul_high_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_high_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field op 12 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011111 xxxxxxxx 110xx0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            boolean round = (op == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_high_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field op 12 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 xxxxxxxx 110xx0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean round = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) result;
        integer round_const = if round then 1 << (esize - 1) else 0;
        integer element1;
        integer element2;
        integer product;
        boolean sat;
        
        element2 = SInt(Elem[operand2, index, esize]);
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            product = (2 * element1 * element2) + round_const;
            // The following only saturates if element1 and element2 equal -(2^(esize-1))
            (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_integer_flags_xaflag
    __encoding aarch64_integer_flags_xaflag
        __instruction_set A64
        __field CRm 8 +: 4
        __opcode '11010101 00000000 0100xxxx 00111111'
        __guard TRUE
        __decode
            if !HaveFlagFormatExt() then UNDEFINED;

    __execute
        bit N = NOT(PSTATE.C) AND NOT(PSTATE.Z);
        bit Z = PSTATE.Z AND PSTATE.C;
        bit C = PSTATE.C OR PSTATE.Z;
        bit V = NOT(PSTATE.C) AND PSTATE.Z;
        
        PSTATE.N = N;
        PSTATE.Z = Z;
        PSTATE.C = C;
        PSTATE.V = V;

__instruction SQINCD_R.RS_SX
    __encoding SQINCD_R.RS_SX
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1110xxxx 111100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 32;

    __encoding SQINCD_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1111xxxx 111100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction LSL_Z.ZW__
    __encoding LSL_Z.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 100011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            integer element2 = UInt(Elem[operand2, (e * esize) DIV 64, 64]);
            Elem[result, e, esize] = LSL(element1, element2);
        
        Z[d] = result;

__instruction aarch64_branch_unconditional_immediate
    __encoding aarch64_branch_unconditional_immediate
        __instruction_set A64
        __field op 31 +: 1
        __field imm26 0 +: 26
        __opcode 'x00101xx xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            BranchType branch_type = if op == '1' then BranchType_DIRCALL else BranchType_DIR;
            bits(64) offset = SignExtend(imm26:'00', 64);

    __execute
        if branch_type == BranchType_DIRCALL then X[30] = PC[] + 4;
        
        BranchTo(PC[] + offset, branch_type);

__instruction aarch64_integer_crc
    __encoding aarch64_integer_crc
        __instruction_set A64
        __field sf 31 +: 1
        __field Rm 16 +: 5
        __field C 12 +: 1
        __field sz 10 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011010 110xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveCRCExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sf == '1' && sz != '11' then UNDEFINED;
            if sf == '0' && sz == '11' then UNDEFINED;
            integer size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64
            boolean crc32c = (C == '1');

    __execute
        bits(32)      acc     = X[n];   // accumulator
        bits(size)    val     = X[m];   // input value
        bits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;
        
        bits(32+size) tempacc = BitReverse(acc) : Zeros(size);
        bits(size+32) tempval = BitReverse(val) : Zeros(32);
        
        // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
        X[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));

__instruction aarch64_vector_arithmetic_binary_disparate_mul_accum
    __encoding aarch64_vector_arithmetic_binary_disparate_mul_accum
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 10x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        bits(2*esize) accum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            product = (element1 * element2)<2*esize-1:0>;
            if sub_op then
                accum = Elem[operand3, e, 2*esize] - product;
            else
                accum = Elem[operand3, e, 2*esize] + product;
            Elem[result, e, 2*esize] = accum;
        
        V[d] = result;

__instruction aarch64_vector_shift_left_sisd
    __encoding aarch64_vector_shift_left_sisd
        __instruction_set A64
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011111 0xxxxxxx 010101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = UInt(immh:immb) - esize;

    __encoding aarch64_vector_shift_left_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 0xxxxxxx 010101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = UInt(immh:immb) - esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) result;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift);
        
        V[d] = result;

__instruction aarch64_memory_single_general_register
    __encoding aarch64_memory_single_general_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction FTMAD_Z.ZZI__
    __encoding FTMAD_Z.ZZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm3 16 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx010xxx 100000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            integer imm = UInt(imm3);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPTrigMAdd(imm, element1, element2, FPCR);
        
        Z[dn] = result;

__instruction aarch64_memory_pair_simdfp_no_alloc
    __encoding aarch64_memory_pair_simdfp_no_alloc
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101100 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = FALSE;
            boolean postindex = FALSE;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer t2 = UInt(Rt2);
        AccType acctype = AccType_VECSTREAM;
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        if opc == '11' then UNDEFINED;
        integer scale = 2 + UInt(opc);
        integer datasize = 8 << scale;
        bits(64) offset = LSL(SignExtend(imm7, 64), scale);
        boolean tag_checked = wback || n != 31;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(datasize) data1;
        bits(datasize) data2;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                data1 = V[t];
                data2 = V[t2];
                Mem[address + 0     , dbytes, acctype] = data1;
                Mem[address + dbytes, dbytes, acctype] = data2;
        
            when MemOp_LOAD
                data1 = Mem[address + 0     , dbytes, acctype];
                data2 = Mem[address + dbytes, dbytes, acctype];
                if rt_unknown then
                    data1 = bits(datasize) UNKNOWN;
                    data2 = bits(datasize) UNKNOWN;
                V[t]  = data1;
                V[t2] = data2;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_shift_right_sisd
    __encoding aarch64_vector_shift_right_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __encoding aarch64_vector_shift_right_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) operand2;
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        
        operand2 = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
            Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
        
        V[d] = result;

__instruction DECB_R.RS__
    __encoding DECB_R.RS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0011xxxx 111001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding DECD_R.RS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1111xxxx 111001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding DECH_R.RS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0111xxxx 111001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding DECW_R.RS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1011xxxx 111001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(64) operand1 = X[dn];
        
        X[dn] = operand1 - (count * imm);

__instruction LD1RQB_Z.P.BR_Contiguous
    __encoding LD1RQB_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 000xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;

    __execute
        CheckSVEEnabled();
        integer elements = 128 DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g]; // low 16 bits only
        bits(64) offset;
        bits(128) result;
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = X[m];
        
        addr = base + UInt(offset) * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = Replicate(result, VL DIV 128);

__instruction LDNF1SW_Z.P.BI_S64
    __encoding LDNF1SW_Z.P.BI_S64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1001xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                // MemNF[] will return fault=TRUE if access is not performed for any reason
                (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction LDR_P.BI__
    __encoding LDR_P.BI__
        __instruction_set A64
        __field imm9h 16 +: 6
        __field imm9l 10 +: 3
        __field Rn 5 +: 5
        __field Pt 0 +: 4
        __opcode '10000101 10xxxxxx 000xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Pt);
            integer n = UInt(Rn);
            integer imm = SInt(imm9h:imm9l);

    __execute
        CheckSVEEnabled();
        integer elements = PL DIV 8;
        bits(64) base;
        integer offset = imm * elements;
        bits(PL) result;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        boolean aligned = AArch64.CheckAlignment(base + offset, 2, AccType_NORMAL, FALSE);
        for e = 0 to elements-1
            Elem[result, e, 8] = AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned];
            offset = offset + 1;
        
        P[t] = result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_memory_single_general_immediate_signed_offset_lda_stl
    __encoding aarch64_memory_single_general_immediate_signed_offset_lda_stl
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx011001 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_ORDERED;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_narrow
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_narrow
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 01x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean round = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand1 = V[n];
        bits(2*datasize) operand2 = V[m];
        bits(datasize)   result;
        integer round_const = if round then 1 << (esize - 1) else 0;
        bits(2*esize) element1;
        bits(2*esize) element2;
        bits(2*esize) sum;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, 2*esize];
            element2 = Elem[operand2, e, 2*esize];
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            sum = sum + round_const;
            Elem[result, e, esize] = sum<2*esize-1:esize>;
        
        Vpart[d, part] = result;

__instruction aarch64_memory_exclusive_pair
    __encoding aarch64_memory_exclusive_pair
        __instruction_set A64
        __field sz 30 +: 1
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '1x001000 0x1xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = TRUE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 32 << UInt(sz);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction SQSUB_Z.ZI__
    __encoding SQSUB_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field sh 13 +: 1
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx100110 11xxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size:sh == '001' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer imm = UInt(imm8);
            if sh == '1' then imm = imm << 8;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 - imm, esize, unsigned);
        
        Z[dn] = result;

__instruction SDIVR_Z.P.ZZ__
    __encoding SDIVR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010110 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '0x' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer quotient;
                if element1 == 0 then
                    quotient = 0;
                else
                    quotient = RoundTowardsZero(Real(element2) / Real(element1));
                Elem[result, e, esize] = quotient<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_system_barriers
    __encoding aarch64_system_barriers
        __instruction_set A64
        __field CRm 8 +: 4
        __field opc 5 +: 2
        __opcode '11010101 00000011 0011xxxx 1xx11111'
        __guard TRUE
        __decode
            MemBarrierOp op;
            MBReqDomain domain;
            MBReqTypes types;
            
            case opc of
                when '00' op = MemBarrierOp_DSB;
                when '01' op = MemBarrierOp_DMB;
                when '10' op = MemBarrierOp_ISB;
                otherwise 
                    if HaveSBExt() && CRm<3:0> == '0000' then 
                        op = MemBarrierOp_SB;
                    else
                        UNDEFINED;
            
            case CRm<3:2> of
                when '00' domain = MBReqDomain_OuterShareable;
                when '01' domain = MBReqDomain_Nonshareable;
                when '10' domain = MBReqDomain_InnerShareable;
                when '11' domain = MBReqDomain_FullSystem;
            
            case CRm<1:0> of
                when '01' types = MBReqTypes_Reads;
                when '10' types = MBReqTypes_Writes;
                when '11' types = MBReqTypes_All;
                otherwise
                    if CRm<3:2> == '01' then
                        op = MemBarrierOp_PSSBB;
                    elsif CRm<3:2> == '00' && opc == '00' then 
                        op = MemBarrierOp_SSBB;
                    elsif HaveSBExt() && CRm<3:2> == '00' && opc == '11' then 
                        op = MemBarrierOp_SB;
                    else
                        types  = MBReqTypes_All;
                        domain = MBReqDomain_FullSystem;

    __execute
        case op of
            when MemBarrierOp_DSB
                DataSynchronizationBarrier(domain, types);
            when MemBarrierOp_DMB
                DataMemoryBarrier(domain, types);
            when MemBarrierOp_ISB
                InstructionSynchronizationBarrier();
            when MemBarrierOp_SSBB
                SpeculativeStoreBypassBarrierToVA();
            when MemBarrierOp_PSSBB
                SpeculativeStoreBypassBarrierToPA();
            when MemBarrierOp_SB
                SpeculationBarrier();

__instruction aarch64_memory_atomicops_swp
    __encoding aarch64_memory_atomicops_swp
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 100000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        Mem[address, datasize DIV 8, stacctype] = X[s];
        
        X[t] = ZeroExtend(data, regsize);

__instruction aarch64_memory_pair_general_post_idx
    __encoding aarch64_memory_pair_general_post_idx
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101000 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = TRUE;
            boolean postindex = TRUE;

    __encoding aarch64_memory_pair_general_pre_idx
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101001 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = TRUE;
            boolean postindex = FALSE;

    __encoding aarch64_memory_pair_general_offset
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101001 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = FALSE;
            boolean postindex = FALSE;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer t2 = UInt(Rt2);
        AccType acctype = AccType_NORMAL;
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        if L:opc<0> == '01' || opc == '11' then UNDEFINED;
        boolean signed = (opc<0> != '0');
        integer scale = 2 + UInt(opc<1>);
        integer datasize = 8 << scale;
        bits(64) offset = LSL(SignExtend(imm7, 64), scale);
        boolean tag_checked = wback || n != 31;
    __execute
        bits(64) address;
        bits(datasize) data1;
        bits(datasize) data2;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        boolean wb_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then
            Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then
            Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_LOAD && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown && t == n then
                    data1 = bits(datasize) UNKNOWN;
                else
                    data1 = X[t];
                if rt_unknown && t2 == n then
                    data2 = bits(datasize) UNKNOWN;
                else
                    data2 = X[t2];
                Mem[address + 0     , dbytes, acctype] = data1;
                Mem[address + dbytes, dbytes, acctype] = data2;
        
            when MemOp_LOAD
                data1 = Mem[address + 0     , dbytes, acctype];
                data2 = Mem[address + dbytes, dbytes, acctype];
                if rt_unknown then
                    data1 = bits(datasize) UNKNOWN;
                    data2 = bits(datasize) UNKNOWN;
                if signed then
                    X[t]  = SignExtend(data1, 64);
                    X[t2] = SignExtend(data2, 64);
                else
                    X[t]  = data1;
                    X[t2] = data2;
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_crypto_sha2op_sha1_hash
    __encoding aarch64_vector_crypto_sha2op_sha1_hash
        __instruction_set A64
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 00101000 000010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            if !HaveSHA1Ext() then UNDEFINED;

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(32) operand = V[n];        // read element [0] only,  [1-3] zeroed
        V[d] = ROL(operand, 30);

__instruction LD2B_Z.P.BR_Contiguous
    __encoding LD2B_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 001xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_memory_single_general_register
    __encoding aarch64_memory_single_general_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction FSUB_Z.ZZ__
    __encoding FSUB_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx0xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPSub(element1, element2, FPCR);
        
        Z[d] = result;

__instruction FMULX_Z.P.ZZ__
    __encoding FMULX_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx001010 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction LASTA_R.P.Z__
    __encoding LASTA_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00000101 xx100000 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer rsize = if esize < 64 then 32 else 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Rd);
            boolean isBefore = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(rsize) result;
        integer last = LastActiveElement(mask, esize);
        
        if isBefore then
            if last < 0 then last = elements - 1;
        else
            last = last + 1;
            if last >= elements then last = 0;
        result = ZeroExtend(Elem[operand, last, esize]);
        
        X[d] = result;

__instruction aarch64_vector_transfer_integer_move_signed
    __encoding aarch64_vector_transfer_integer_move_signed
        __instruction_set A64
        __field Q 30 +: 1
        __field imm5 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 000xxxxx 001011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer size;
            case Q:imm5 of
                when 'xxxxx1' size = 0;     // SMOV [WX]d, Vn.B
                when 'xxxx10' size = 1;     // SMOV [WX]d, Vn.H
                when '1xx100' size = 2;     // SMOV Xd, Vn.S
                otherwise     UNDEFINED;
            
            integer idxdsize = if imm5<4> == '1' then 128 else 64;
            integer index = UInt(imm5<4:size+1>);
            integer esize = 8 << size;
            integer datasize = if Q == '1' then 64 else 32;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(idxdsize) operand = V[n];
        
        X[d] = SignExtend(Elem[operand, index, esize], datasize);

__instruction aarch64_memory_ordered_rcpc
    __encoding aarch64_memory_ordered_rcpc
        __instruction_set A64
        __field size 30 +: 2
        __field Rs 16 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 101xxxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = AccType_ORDERED;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        data = Mem[address, dbytes, acctype];
        X[t] = ZeroExtend(data, regsize);

__instruction NAND_P.P.PP_Z
    __encoding NAND_P.P.PP_Z
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 1000xxxx 01xxxx1x xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = FALSE;

    __encoding NANDS_P.P.PP_Z
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 1100xxxx 01xxxx1x xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            bit element1 = ElemP[operand1, e, esize];
            bit element2 = ElemP[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                ElemP[result, e, esize] = NOT(element1 AND element2);
            else
                ElemP[result, e, esize] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_round
    __encoding aarch64_vector_arithmetic_unary_fp16_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __encoding aarch64_vector_arithmetic_unary_float_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
        
        V[d] = result;

__instruction aarch64_system_register_system
    __encoding aarch64_system_register_system
        __instruction_set A64
        __field L 21 +: 1
        __field o0 19 +: 1
        __field op1 16 +: 3
        __field CRn 12 +: 4
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __field Rt 0 +: 5
        __opcode '11010101 00x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);
            
            integer t = UInt(Rt);
            
            integer sys_op0 = 2 + UInt(o0);
            integer sys_op1 = UInt(op1);
            integer sys_op2 = UInt(op2);
            integer sys_crn = UInt(CRn);
            integer sys_crm = UInt(CRm);
            boolean read = (L == '1');

    __execute
        if read then
            X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);
        else
            AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);

__instruction aarch64_vector_reduce_fp16_add_sisd
    __encoding aarch64_vector_reduce_fp16_add_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 0x110000 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer esize = 16;
            if sz == '1' then UNDEFINED;
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = ReduceOp_FADD;

    __encoding aarch64_vector_reduce_fp_add_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 0x110000 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = ReduceOp_FADD;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction LDNT1B_Z.P.BI_Contiguous
    __encoding LDNT1B_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0000xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        constant integer mbytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction NOT_Z.P.Z__
    __encoding NOT_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx011110 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = NOT element;
        
        Z[d] = result;

__instruction aarch64_integer_shift_variable
    __encoding aarch64_integer_shift_variable
        __instruction_set A64
        __field sf 31 +: 1
        __field Rm 16 +: 5
        __field op2 10 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011010 110xxxxx 0010xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            ShiftType shift_type = DecodeShift(op2);

    __execute
        bits(datasize) result;
        bits(datasize) operand2 = X[m];
        
        result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
        X[d] = result;

__instruction aarch64_vector_shift_right_sisd
    __encoding aarch64_vector_shift_right_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __encoding aarch64_vector_shift_right_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) operand2;
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        
        operand2 = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
            Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field S 13 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111111 xxxxxxxx 11x1x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            boolean rounding = TRUE;
            boolean sub_op = (S  == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field S 13 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 xxxxxxxx 11x1x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean rounding = TRUE;
            boolean sub_op = (S  == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        integer rounding_const = if rounding then 1 << (esize - 1) else 0;
        integer element1;
        integer element2;
        integer element3;
        integer product;
        boolean sat;
        
        element2 = SInt(Elem[operand2, index, esize]);
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            element3 = SInt(Elem[operand3, e, esize]);
            if sub_op then
                accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
            else
                accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
            (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_memory_atomicops_cas_pair
    __encoding aarch64_memory_atomicops_cas_pair
        __instruction_set A64
        __field sz 30 +: 1
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001000 0x1xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            if Rs<0> == '1' then UNDEFINED;
            if Rt<0> == '1' then UNDEFINED;
            
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer s = UInt(Rs);
            
            integer datasize = 32 << UInt(sz);
            integer regsize = datasize;
            AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(2*datasize) comparevalue;
        bits(2*datasize) newvalue;
        bits(2*datasize) data;
        
        bits(datasize) s1 = X[s];
        bits(datasize) s2 = X[s+1];
        bits(datasize) t1 = X[t];
        bits(datasize) t2 = X[t+1];
        comparevalue = if BigEndian() then s1:s2 else s2:s1;
        newvalue     = if BigEndian() then t1:t2 else t2:t1;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, (2 * datasize) DIV 8, ldacctype];
        if data == comparevalue then
            Mem[address, (2 * datasize) DIV 8, stacctype] = newvalue;
        
        if BigEndian() then
            X[s]   = ZeroExtend(data<2*datasize-1:datasize>, regsize);
            X[s+1] = ZeroExtend(data<datasize-1:0>, regsize);
        else
            X[s]   = ZeroExtend(data<datasize-1:0>, regsize);
            X[s+1] = ZeroExtend(data<2*datasize-1:datasize>, regsize);

__instruction aarch64_integer_tags_mcinsertrandomtag
    __encoding aarch64_integer_tags_mcinsertrandomtag
        __instruction_set A64
        __field Xm 16 +: 5
        __field Xn 5 +: 5
        __field Xd 0 +: 5
        __opcode '10011010 110xxxxx 000100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Xd);
            integer n = UInt(Xn);
            integer m = UInt(Xm);

    __execute
        bits(64) operand = if n == 31 then SP[] else X[n];
        bits(64) xm = X[m];
        bits(16) exclude = xm<15:0> OR GCR_EL1.Exclude;
        
        if AllocationTagAccessIsEnabled() then
            if GCR_EL1.RRND == '1' then
                RGSR_EL1 = bits(32) UNKNOWN;
                rtag = _ChooseRandomNonExcludedTag(exclude);
            else
                bits(4) start = RGSR_EL1.TAG;
                bits(4) offset = RandomTag();
        
                rtag = ChooseNonExcludedTag(start, offset, exclude);
        
                RGSR_EL1.TAG = rtag;
        else
            rtag = '0000';
        
        bits(64) result = AddressWithAllocationTag(operand, rtag);
        
        if d == 31 then
            SP[] = result;
        else
            X[d] = result;

__instruction CMPEQ_P.P.ZZ__
    __encoding CMPEQ_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 101xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_EQ;
            boolean unsigned = FALSE;

    __encoding CMPGT_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 100xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GT;
            boolean unsigned = FALSE;

    __encoding CMPGE_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 100xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GE;
            boolean unsigned = FALSE;

    __encoding CMPHI_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 000xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GT;
            boolean unsigned = TRUE;

    __encoding CMPHS_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 000xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GE;
            boolean unsigned = TRUE;

    __encoding CMPNE_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 101xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_NE;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                boolean cond;
                case op of
                    when Cmp_EQ cond = element1 == element2;
                    when Cmp_NE cond = element1 != element2;
                    when Cmp_GE cond = element1 >= element2;
                    when Cmp_LT cond = element1 <  element2;
                    when Cmp_GT cond = element1 >  element2;
                    when Cmp_LE cond = element1 <= element2;
                ElemP[result, e, esize] = if cond then '1' else '0';
            else
                ElemP[result, e, esize] = '0';
        
        PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
    __encoding aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 xx100001 001010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer part = 0;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_unary_extract_sqxtun_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx100001 001010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand = V[n];
        bits(datasize) result;
        bits(2*esize) element;
        boolean sat;
        
        for e = 0 to elements-1
            element = Elem[operand, e, 2*esize];
            (Elem[result, e, esize], sat) = UnsignedSatQ(SInt(element), esize);
            if sat then FPSR.QC = '1';
        
        Vpart[d, part] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
    __encoding aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 xx1xxxxx 10x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '00' || size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;
            
            boolean sub_op = (o1 == '1');

    __encoding aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 10x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '00' || size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        integer accum;
        boolean sat1;
        boolean sat2;
        
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            element2 = SInt(Elem[operand2, e, esize]);
            (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
            if sub_op then
                accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
            else
                accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
            (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
            if sat1 || sat2 then FPSR.QC = '1';
        
        V[d] = result;

__instruction ST1H_Z.P.BI__
    __encoding ST1H_Z.P.BI__
        __instruction_set A64
        __field size 21 +: 2
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 1xx0xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8 << UInt(size);
            integer msize = 16;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) src = Z[t];
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;
            addr = addr + mbytes;

__instruction PRFH_I.P.BI_S
    __encoding PRFH_I.P.BI_S
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000101 11xxxxxx 001xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 1;
            integer offset = SInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) addr;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        
        addr = base + ((offset * elements) << scale);
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Hint_Prefetch(addr, pref_hint, level, stream);
            addr = addr + (1 << scale);

__instruction aarch64_memory_vector_multiple_no_wb
    __encoding aarch64_memory_vector_multiple_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 0x000000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_multiple_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field Rm 16 +: 5
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << UInt(size);
        integer elements = datasize DIV esize;
        
        integer rpt;    // number of iterations
        integer selem;  // structure elements 
        
        case opcode of
            when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
            when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
            when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
            when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
            when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
            when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
            when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
            otherwise UNDEFINED;
        
        // .1D format only permitted with LD1 & ST1
        if size:Q == '110' && selem != 1 then UNDEFINED;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(datasize) rval;
        integer tt;
        constant integer ebytes = esize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        for r = 0 to rpt-1
            for e = 0 to elements-1
                tt = (t + r) MOD 32;
                for s = 0 to selem-1
                    rval = V[tt];
                    if memop == MemOp_LOAD then
                        Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                        V[tt] = rval;
                    else // memop == MemOp_STORE
                        Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                    offs = offs + ebytes;
                    tt = (tt + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction FCMLA_Z.ZZZi_H
    __encoding FCMLA_Z.ZZZi_H
        __instruction_set A64
        __field i2 19 +: 2
        __field Zm 16 +: 3
        __field rot 10 +: 2
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100100 101xxxxx 0001xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer index = UInt(i2);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            integer sel_a = UInt(rot<0>);
            integer sel_b = UInt(NOT(rot<0>));
            boolean neg_i = (rot<1> == '1');
            boolean neg_r = (rot<0> != rot<1>);

    __encoding FCMLA_Z.ZZZi_S
        __instruction_set A64
        __field i1 20 +: 1
        __field Zm 16 +: 4
        __field rot 10 +: 2
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100100 111xxxxx 0001xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer index = UInt(i1);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            integer sel_a = UInt(rot<0>);
            integer sel_b = UInt(NOT(rot<0>));
            boolean neg_i = (rot<1> == '1');
            boolean neg_r = (rot<0> != rot<1>);

    __execute
        CheckSVEEnabled();
        integer pairs = VL DIV (2 * esize);
        integer pairspersegment = 128 DIV (2 * esize);
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for p = 0 to pairs-1
            segmentbase = p - p MOD pairspersegment;
            s = segmentbase + index;
            addend_r = Elem[operand3, 2 * p + 0, esize];
            addend_i = Elem[operand3, 2 * p + 1, esize];
            elt1_a   = Elem[operand1, 2 * p + sel_a, esize];
            elt2_a   = Elem[operand2, 2 * s + sel_a, esize];
            elt2_b   = Elem[operand2, 2 * s + sel_b, esize];
            if neg_r then elt2_a = FPNeg(elt2_a);
            if neg_i then elt2_b = FPNeg(elt2_b);
            addend_r = FPMulAdd(addend_r, elt1_a, elt2_a, FPCR);
            addend_i = FPMulAdd(addend_i, elt1_a, elt2_b, FPCR);
            Elem[result, 2 * p + 0, esize] = addend_r;
            Elem[result, 2 * p + 1, esize] = addend_i;
        
        Z[da] = result;

__instruction FABD_Z.P.ZZ__
    __encoding FABD_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx001000 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPAbs(FPSub(element1, element2, FPCR));
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction FSUBR_Z.P.ZZ__
    __encoding FSUBR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx000011 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPSub(element2, element1, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction INDEX_Z.RR__
    __encoding INDEX_Z.RR__
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 010011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(esize) operand1 = X[n];
        integer element1 = SInt(operand1);
        bits(esize) operand2 = X[m];
        integer element2 = SInt(operand2);
        bits(VL) result;
        
        for e = 0 to elements-1
            integer index = element1 + e * element2;
            Elem[result, e, esize] = index<esize-1:0>;
        
        Z[d] = result;

__instruction LDNF1H_Z.P.BI_U16
    __encoding LDNF1H_Z.P.BI_U16
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1011xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LDNF1H_Z.P.BI_U32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1101xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LDNF1H_Z.P.BI_U64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1111xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                // MemNF[] will return fault=TRUE if access is not performed for any reason
                (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction aarch64_memory_pair_general_no_alloc
    __encoding aarch64_memory_pair_general_no_alloc
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101000 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = FALSE;
            boolean postindex = FALSE;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer t2 = UInt(Rt2);
        AccType acctype = AccType_STREAM;
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        if opc<0> == '1' then UNDEFINED;
        integer scale = 2 + UInt(opc<1>);
        integer datasize = 8 << scale;
        bits(64) offset = LSL(SignExtend(imm7, 64), scale);
        boolean tag_checked = wback || n != 31;
    __execute
        bits(64) address;
        bits(datasize) data1;
        bits(datasize) data2;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown && t == n then
                    data1 = bits(datasize) UNKNOWN;
                else
                    data1 = X[t];
                if rt_unknown && t2 == n then
                    data2 = bits(datasize) UNKNOWN;
                else
                    data2 = X[t2];
                Mem[address + 0     , dbytes, acctype] = data1;
                Mem[address + dbytes, dbytes, acctype] = data2;
        
            when MemOp_LOAD
                data1 = Mem[address + 0     , dbytes, acctype];
                data2 = Mem[address + dbytes, dbytes, acctype];
                if rt_unknown then
                    data1 = bits(datasize) UNKNOWN;
                    data2 = bits(datasize) UNKNOWN;
                X[t]  = data1;
                X[t2] = data2;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_crypto_sm4_sm4enc
    __encoding aarch64_vector_crypto_sm4_sm4enc
        __instruction_set A64
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 11000000 100001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSM4Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vn = V[n];
        bits(32) intval; 
        bits(8) sboxout;
        bits(128) roundresult;
        bits(32) roundkey;
        
        roundresult=V[d];
        for index = 0 to 3
            roundkey = Elem[Vn,index,32];
        
            intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR roundkey; 
        
            for i = 0 to 3  
                Elem[intval,i,8]  = Sbox(Elem[intval,i,8]); 
        
            intval = intval EOR ROL(intval,2) EOR ROL(intval,10) EOR ROL(intval,18) EOR ROL(intval,24);
            intval = intval EOR roundresult<31:0>; 
        
            roundresult<31:0> = roundresult<63:32>;
            roundresult<63:32> = roundresult<95:64>;
            roundresult<95:64> = roundresult<127:96>;
            roundresult<127:96> = intval; 
        V[d] = roundresult;

__instruction LASTB_V.P.Z__
    __encoding LASTB_V.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000101 xx100011 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);
            boolean isBefore = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        integer last = LastActiveElement(mask, esize);
        
        if isBefore then
            if last < 0 then last = elements - 1;
        else
            last = last + 1;
            if last >= elements then last = 0;
        V[d] = Elem[operand, last, esize];

__instruction aarch64_integer_arithmetic_add_sub_carry
    __encoding aarch64_integer_arithmetic_add_sub_carry
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx11010 000xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(4) nzcv;
        
        if sub_op then
            operand2 = NOT(operand2);
        
        (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        X[d] = result;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction FCVTZU_Z.P.Z_FP162H
    __encoding FCVTZU_Z.P.Z_FP162H
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01011011 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 16;
            integer d_esize = 16;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZU_Z.P.Z_FP162W
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01011101 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 16;
            integer d_esize = 32;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZU_Z.P.Z_FP162X
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01011111 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 16;
            integer d_esize = 64;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZU_Z.P.Z_S2W
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 10011101 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 32;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZU_Z.P.Z_S2X
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11011101 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 64;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZU_Z.P.Z_D2W
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11011001 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 32;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FCVTZU_Z.P.Z_D2X
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11011111 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 64;
            boolean unsigned = TRUE;
            FPRounding rounding = FPRounding_ZERO;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                bits(d_esize) res = FPToFixed(element<s_esize-1:0>, 0, unsigned, FPCR, rounding);
                Elem[result, e, esize] = Extend(res, unsigned);
        
        Z[d] = result;

__instruction aarch64_integer_tags_mcsettagpost
    __encoding aarch64_integer_tags_mcsettagpost
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 001xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = TRUE;
            boolean postindex = TRUE;
            boolean zero_data = FALSE;

    __encoding aarch64_integer_tags_mcsettagpre
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 001xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = TRUE;
            boolean postindex = FALSE;
            boolean zero_data = FALSE;

    __encoding aarch64_integer_tags_mcsettag
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 001xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = FALSE;
            boolean postindex = FALSE;
            boolean zero_data = FALSE;

    __execute
        bits(64) address;
        
        SetNotTagCheckedInstruction(TRUE);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if !postindex then
            address = address + offset;
        
        if zero_data then
            Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(TAG_GRANULE * 8);
        
        MemTag[address] = AllocationTagFromAddress(address);
        
        if writeback then
            if postindex then
                address = address + offset;
        
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction CPY_Z.P.I__
    __encoding CPY_Z.P.I__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 16 +: 4
        __field M 14 +: 1
        __field sh 13 +: 1
        __field imm8 5 +: 8
        __field Zd 0 +: 5
        __opcode '00000101 xx01xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size:sh == '001' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer d = UInt(Zd);
            boolean merging = (M == '1');
            integer imm = SInt(imm8);
            if sh == '1' then imm = imm << 8;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) dest = Z[d];
        bits(VL) result;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = imm<esize-1:0>;
            elsif merging then
                Elem[result, e, esize] = Elem[dest, e, esize];
            else
                Elem[result, e, esize] = Zeros();
        
        Z[d] = result;

__instruction aarch64_system_exceptions_debug_halt
    __encoding aarch64_system_exceptions_debug_halt
        __instruction_set A64
        __field imm16 5 +: 16
        __opcode '11010100 010xxxxx xxxxxxxx xxx00000'
        __guard TRUE
        __decode
            if EDSCR.HDE == '0' || !HaltingAllowed() then UndefinedFault();
            if HaveBTIExt() then
                BTypeCompatible = TRUE;

    __execute
        Halt(DebugHalt_HaltInstruction);

__instruction aarch64_vector_arithmetic_binary_uniform_add_wrapping_single_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_add_wrapping_single_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 100001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean sub_op = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_add_wrapping_single_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 100001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean sub_op = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if sub_op then
                Elem[result, e, esize] = element1 - element2;
            else
                Elem[result, e, esize] = element1 + element2;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_diff_neg_int_sisd
    __encoding aarch64_vector_arithmetic_unary_diff_neg_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100000 101110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean neg = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_diff_neg_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 101110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean neg = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element;
        
        for e = 0 to elements-1
            element = SInt(Elem[operand, e, esize]);
            if neg then
                element = -element;
            else
                element = Abs(element);
            Elem[result, e, esize] = element<esize-1:0>;                
        
        V[d] = result;

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction LD1H_Z.P.AI_S
    __encoding LD1H_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 101xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __encoding LD1H_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 101xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction LD1H_Z.P.BR_U16
    __encoding LD1H_Z.P.BR_U16
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 101xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 16;
            boolean unsigned = TRUE;

    __encoding LD1H_Z.P.BR_U32
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 110xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = TRUE;

    __encoding LD1H_Z.P.BR_U64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 111xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction CNOT_Z.P.Z__
    __encoding CNOT_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx011011 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = ZeroExtend(IsZeroBit(element), esize);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_unary_special_frecpx_fp16
    __encoding aarch64_vector_arithmetic_unary_special_frecpx_fp16
        __instruction_set A64
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 11111001 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;           
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_unary_special_frecpx
        __instruction_set A64
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 1x100001 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRecpX(element, FPCR);
        
        V[d] = result;

__instruction aarch64_branch_conditional_compare
    __encoding aarch64_branch_conditional_compare
        __instruction_set A64
        __field sf 31 +: 1
        __field op 24 +: 1
        __field imm19 5 +: 19
        __field Rt 0 +: 5
        __opcode 'x011010x xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer datasize = if sf == '1' then 64 else 32;
            boolean iszero = (op == '0');
            bits(64) offset = SignExtend(imm19:'00', 64);

    __execute
        bits(datasize) operand1 = X[t];
        
        if IsZero(operand1) == iszero then
            BranchTo(PC[] + offset, BranchType_DIR);

__instruction aarch64_branch_unconditional_immediate
    __encoding aarch64_branch_unconditional_immediate
        __instruction_set A64
        __field op 31 +: 1
        __field imm26 0 +: 26
        __opcode 'x00101xx xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            BranchType branch_type = if op == '1' then BranchType_DIRCALL else BranchType_DIR;
            bits(64) offset = SignExtend(imm26:'00', 64);

    __execute
        if branch_type == BranchType_DIRCALL then X[30] = PC[] + 4;
        
        BranchTo(PC[] + offset, branch_type);

__instruction aarch64_integer_logical_shiftedreg
    __encoding aarch64_integer_logical_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field shift 22 +: 2
        __field N 21 +: 1
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01010 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);
            boolean invert = (N == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        X[d] = result;

__instruction UQSUB_Z.ZZ__
    __encoding UQSUB_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 - element2, esize, unsigned);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_diff
    __encoding aarch64_vector_arithmetic_binary_disparate_diff
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field op 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 01x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean accumulate = (op == '0');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) absdiff;
        
        result = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            absdiff = Abs(element1 - element2)<2*esize-1:0>;
            Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
        V[d] = result;

__instruction LSR_Z.P.ZW__
    __encoding LSR_Z.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx011001 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            integer element2 = UInt(Elem[operand2, (e * esize) DIV 64, 64]);
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = LSR(element1, element2);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 001101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            if pair then
                element1 = Elem[concat, 2*e, esize];
                element2 = Elem[concat, (2*e)+1, esize];
            else
                element1 = Elem[operand1, e, esize];
                element2 = Elem[operand2, e, esize];
        
            if minimum then
                Elem[result, e, esize] = FPMin(element1, element2, FPCR);
            else
                Elem[result, e, esize] = FPMax(element1, element2, FPCR);
        
        V[d] = result;

__instruction CLS_Z.P.Z__
    __encoding CLS_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx011000 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = CountLeadingSignBits(element)<esize-1:0>;
        
        Z[d] = result;

__instruction SABD_Z.P.ZZ__
    __encoding SABD_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx001100 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer absdiff = Abs(element1 - element2);
                Elem[result, e, esize] = absdiff<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_float_widen
    __encoding aarch64_vector_arithmetic_unary_float_widen
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 0x100001 011110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16 << UInt(sz);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = Vpart[n, part];
        bits(2*datasize) result;
        
        for e = 0 to elements-1
            Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR);
        
        V[d] = result;

__instruction aarch64_vector_crypto_sha3_rax1
    __encoding aarch64_vector_crypto_sha3_rax1
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 011xxxxx 100011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSHA3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        V[d] = Vn EOR (ROL(Vm<127:64>,1):ROL(Vm<63:0>, 1));

__instruction aarch64_vector_arithmetic_unary_cmp_int_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_cmp_int_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100000 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_int_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element;
        boolean test_passed;
        
        for e = 0 to elements-1
            element = SInt(Elem[operand, e, esize]);
            case comparison of
                when CompareOp_GT test_passed = element > 0;
                when CompareOp_GE test_passed = element >= 0;
                when CompareOp_EQ test_passed = element == 0;
                when CompareOp_LE test_passed = element <= 0;
                when CompareOp_LT test_passed = element < 0;
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction UQDECH_Z.ZS__
    __encoding UQDECH_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 0110xxxx 110011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction LD1SH_Z.P.AI_S
    __encoding LD1SH_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 101xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = FALSE;
            integer offset = UInt(imm5);

    __encoding LD1SH_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 101xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = FALSE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction LD1SH_Z.P.BR_S32
    __encoding LD1SH_Z.P.BR_S32
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 001xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = FALSE;

    __encoding LD1SH_Z.P.BR_S64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 000xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_int_accum
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_accum
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 100101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        bits(esize) product;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            product = (UInt(element1) * UInt(element2))<esize-1:0>;
            if sub_op then
                Elem[result, e, esize] = Elem[operand3, e, esize] - product;
            else
                Elem[result, e, esize] = Elem[operand3, e, esize] + product;
        
        V[d] = result;

__instruction SMINV_R.P.Z__
    __encoding SMINV_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000100 xx001010 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        integer minimum = if unsigned then (2^esize - 1) else (2^(esize-1) - 1);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer element = Int(Elem[operand, e, esize], unsigned);
                minimum = Min(minimum, element);
        
        V[d] = minimum<esize-1:0>;

__instruction aarch64_float_arithmetic_round_frint_32_64
    __encoding aarch64_float_arithmetic_round_frint_32_64
        __instruction_set A64
        __field type1 22 +: 2
        __field op 15 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx10100x x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFrintExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '1x' UNDEFINED;
            
            integer intsize = if op<1> == '0' then 32 else 64;
            
            FPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundIntN(operand, FPCR, rounding, intsize);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_int_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field eq 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 0011x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean cmp_eq = (eq == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field eq 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0011x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean cmp_eq = (eq == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_logical_and_orr
    __encoding aarch64_vector_arithmetic_binary_uniform_logical_and_orr
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean invert = (size<0> == '1');
            LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND
                result = operand1 AND operand2;
            when LogicalOp_ORR
                result = operand1 OR operand2;
        
        V[d] = result;

__instruction aarch64_integer_flags_cfinv
    __encoding aarch64_integer_flags_cfinv
        __instruction_set A64
        __field CRm 8 +: 4
        __opcode '11010101 00000000 0100xxxx 00011111'
        __guard TRUE
        __decode
            if !HaveFlagManipulateExt() then UNDEFINED;

    __execute
        PSTATE.C = NOT(PSTATE.C);

__instruction aarch64_integer_pac_pacga_dp_2src
    __encoding aarch64_integer_pac_pacga_dp_2src
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '10011010 110xxxxx 001100xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean source_is_sp = FALSE;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if !HavePACExt() then
                UNDEFINED;
            
            if m == 31 then source_is_sp = TRUE;

    __execute
        if source_is_sp then
            X[d] = AddPACGA(X[n], SP[]);
        else
            X[d] = AddPACGA(X[n], X[m]);

__instruction aarch64_memory_single_general_immediate_signed_post_idx
    __encoding aarch64_memory_single_general_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111001 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction FCVT_Z.P.Z_H2S
    __encoding FCVT_Z.P.Z_H2S
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 10001001 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 16;
            integer d_esize = 32;

    __encoding FCVT_Z.P.Z_H2D
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11001001 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 16;
            integer d_esize = 64;

    __encoding FCVT_Z.P.Z_S2H
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 10001000 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 16;

    __encoding FCVT_Z.P.Z_S2D
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11001011 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 64;

    __encoding FCVT_Z.P.Z_D2H
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11001000 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 16;

    __encoding FCVT_Z.P.Z_D2S
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11001010 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 32;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                bits(d_esize) res = FPConvertSVE(element<s_esize-1:0>, FPCR);
                Elem[result, e, esize] = ZeroExtend(res);
        
        Z[d] = result;

__instruction aarch64_float_move_fp_select
    __encoding aarch64_float_move_fp_select
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field cond 12 +: 4
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            bits(4) condition = cond;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        
        result = if ConditionHolds(condition) then V[n] else V[m];
        
        V[d] = result;

__instruction CLASTB_V.P.Z__
    __encoding CLASTB_V.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Vdn 0 +: 5
        __opcode '00000101 xx101011 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Vdn);
            integer m = UInt(Zm);
            boolean isBefore = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(esize) operand1 = V[dn];
        bits(VL) operand2 = Z[m];
        bits(esize) result;
        integer last = LastActiveElement(mask, esize);
        
        if last < 0 then
            result = ZeroExtend(operand1);
        else
            if !isBefore then
                last = last + 1;
                if last >= elements then last = 0;
            result = Elem[operand2, last, esize];
        
        V[dn] = result;

__instruction FSUB_Z.P.ZZ__
    __encoding FSUB_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx000001 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPSub(element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_vector_shift_right_narrow_uniform_sisd
    __encoding aarch64_vector_shift_right_narrow_uniform_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 1001x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then UNDEFINED;
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_shift_right_narrow_uniform_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 1001x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize*2) operand = V[n];
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
            (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
            if sat then FPSR.QC = '1';
        
        Vpart[d, part] = result;

__instruction ADD_Z.P.ZZ__
    __encoding ADD_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx000000 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = element1 + element2;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_wide
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_wide
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 00x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand1 = V[n];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        integer sum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, 2*esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            Elem[result, e, 2*esize] = sum<2*esize-1:0>;
        
        V[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_lda_stl
    __encoding aarch64_memory_single_general_immediate_signed_offset_lda_stl
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx011001 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_ORDERED;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction CLASTA_R.P.Z__
    __encoding CLASTA_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000101 xx110000 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);
            integer m = UInt(Zm);
            integer csize = if esize < 64 then 32 else 64;
            boolean isBefore = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(esize) operand1 = X[dn];
        bits(VL) operand2 = Z[m];
        bits(csize) result;
        integer last = LastActiveElement(mask, esize);
        
        if last < 0 then
            result = ZeroExtend(operand1);
        else
            if !isBefore then
                last = last + 1;
                if last >= elements then last = 0;
            result = ZeroExtend(Elem[operand2, last, esize]);
        
        X[dn] = result;

__instruction UMULH_Z.P.ZZ__
    __encoding UMULH_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010011 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer product = (element1 * element2) >> esize;
                Elem[result, e, esize] = product<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction STR_Z.BI__
    __encoding STR_Z.BI__
        __instruction_set A64
        __field imm9h 16 +: 6
        __field imm9l 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 10xxxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer imm = SInt(imm9h:imm9l);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV 8;
        bits(VL) src;
        bits(64) base;
        integer offset = imm * elements;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        src = Z[t];
        boolean aligned = AArch64.CheckAlignment(base + offset, 16, AccType_NORMAL, TRUE);
        for e = 0 to elements-1
            AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned] = Elem[src, e, 8];
            offset = offset + 1;

__instruction SQDECW_R.RS_SX
    __encoding SQDECW_R.RS_SX
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1010xxxx 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 32;

    __encoding SQDECW_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1011xxxx 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction aarch64_memory_pair_general_post_idx
    __encoding aarch64_memory_pair_general_post_idx
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101000 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = TRUE;
            boolean postindex = TRUE;

    __encoding aarch64_memory_pair_general_pre_idx
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101001 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = TRUE;
            boolean postindex = FALSE;

    __encoding aarch64_memory_pair_general_offset
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101001 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = FALSE;
            boolean postindex = FALSE;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer t2 = UInt(Rt2);
        AccType acctype = AccType_NORMAL;
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        if L:opc<0> == '01' || opc == '11' then UNDEFINED;
        boolean signed = (opc<0> != '0');
        integer scale = 2 + UInt(opc<1>);
        integer datasize = 8 << scale;
        bits(64) offset = LSL(SignExtend(imm7, 64), scale);
        boolean tag_checked = wback || n != 31;
    __execute
        bits(64) address;
        bits(datasize) data1;
        bits(datasize) data2;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        boolean wb_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then
            Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then
            Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_LOAD && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown && t == n then
                    data1 = bits(datasize) UNKNOWN;
                else
                    data1 = X[t];
                if rt_unknown && t2 == n then
                    data2 = bits(datasize) UNKNOWN;
                else
                    data2 = X[t2];
                Mem[address + 0     , dbytes, acctype] = data1;
                Mem[address + dbytes, dbytes, acctype] = data2;
        
            when MemOp_LOAD
                data1 = Mem[address + 0     , dbytes, acctype];
                data2 = Mem[address + dbytes, dbytes, acctype];
                if rt_unknown then
                    data1 = bits(datasize) UNKNOWN;
                    data2 = bits(datasize) UNKNOWN;
                if signed then
                    X[t]  = SignExtend(data1, 64);
                    X[t2] = SignExtend(data2, 64);
                else
                    X[t]  = data1;
                    X[t2] = data2;
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction ORR_P.P.PP_Z
    __encoding ORR_P.P.PP_Z
        __instruction_set A64
        __field S 22 +: 1
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 1000xxxx 01xxxx0x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = FALSE;

    __encoding ORRS_P.P.PP_Z
        __instruction_set A64
        __field S 22 +: 1
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 1100xxxx 01xxxx0x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            bit element1 = ElemP[operand1, e, esize];
            bit element2 = ElemP[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                ElemP[result, e, esize] = element1 OR element2;
            else
                ElemP[result, e, esize] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction FMUL_Z.P.ZS__
    __encoding FMUL_Z.P.ZS__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field i1 5 +: 1
        __field Zdn 0 +: 5
        __opcode '01100101 xx011010 100xxx00 00xxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPTwo('0');

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMul(element1, imm, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction ST2B_Z.P.BI_Contiguous
    __encoding ST2B_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 0011xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer offset = SInt(imm4);
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction aarch64_memory_single_general_immediate_signed_offset_unpriv
    __encoding aarch64_memory_single_general_immediate_signed_offset_unpriv
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        
        unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
        unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
        
        user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
        if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
            acctype = AccType_UNPRIV;
        else
            acctype = AccType_NORMAL;
        
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_crypto_sm4_sm4enckey
    __encoding aarch64_vector_crypto_sm4_sm4enckey
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 011xxxxx 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSM4Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(32) intval; 
        bits(8) sboxout;
        bits(128) result;
        bits(32) const;
        bits(128) roundresult;
        
        roundresult = V[n];
        for index = 0 to 3 
            const = Elem[Vm,index,32];
        
            intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR const; 
        
            for i = 0 to 3  
                Elem[intval,i,8] = Sbox(Elem[intval,i,8]); 
        
            intval = intval EOR ROL(intval,13) EOR ROL(intval,23);
            intval = intval EOR roundresult<31:0>; 
        
            roundresult<31:0> = roundresult<63:32>;
            roundresult<63:32> = roundresult<95:64>;
            roundresult<95:64> = roundresult<127:96>;
            roundresult<127:96> = intval; 
        V[d] = roundresult;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 001101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            if pair then
                element1 = Elem[concat, 2*e, esize];
                element2 = Elem[concat, (2*e)+1, esize];
            else
                element1 = Elem[operand1, e, esize];
                element2 = Elem[operand2, e, esize];
        
            if minimum then
                Elem[result, e, esize] = FPMin(element1, element2, FPCR);
            else
                Elem[result, e, esize] = FPMax(element1, element2, FPCR);
        
        V[d] = result;

__instruction SQDECP_R.P.R_SX
    __encoding SQDECP_R.P.R_SX
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Rdn 0 +: 5
        __opcode '00100101 xx101010 1000100x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);
            boolean unsigned = FALSE;
            integer ssize = 32;

    __encoding SQDECP_R.P.R_X
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Rdn 0 +: 5
        __opcode '00100101 xx101010 1000110x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);
            boolean unsigned = FALSE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(ssize) operand = X[dn];
        bits(ssize) result;
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        integer element = Int(operand, unsigned);
        (result, -) = SatQ(element - count, ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction aarch64_memory_ordered_rcpc
    __encoding aarch64_memory_ordered_rcpc
        __instruction_set A64
        __field size 30 +: 2
        __field Rs 16 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 101xxxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = AccType_ORDERED;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        data = Mem[address, dbytes, acctype];
        X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_shift
    __encoding aarch64_vector_arithmetic_unary_shift
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx100001 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = esize;
            boolean unsigned = FALSE; // Or TRUE without change of functionality

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = Vpart[n, part];
        bits(2*datasize) result;
        integer element;
        
        for e = 0 to elements-1
            element = Int(Elem[operand, e, esize], unsigned) << shift;
            Elem[result, e, 2*esize] = element<2*esize-1:0>;
        
        V[d] = result;

__instruction LSL_Z.P.ZW__
    __encoding LSL_Z.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx011011 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            integer element2 = UInt(Elem[operand2, (e * esize) DIV 64, 64]);
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = LSL(element1, element2);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction PFIRST_P.P.P__
    __encoding PFIRST_P.P.P__
        __instruction_set A64
        __field Pg 5 +: 4
        __field Pdn 0 +: 4
        __opcode '00100101 01011000 1100000x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer dn = UInt(Pdn);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) result = P[dn];
        integer first = -1;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' && first == -1 then
                first = e;
        
        if first >= 0 then
            ElemP[result, first, esize] = '1';
        
        PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[dn] = result;

__instruction DUP_Z.R__
    __encoding DUP_Z.R__
        __instruction_set A64
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx100000 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Rn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) operand;
        if n == 31 then
            operand = SP[];
        else
            operand = X[n];
        bits(VL) result;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = operand<esize-1:0>;
        
        Z[d] = result;

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction ST1B_Z.P.BI__
    __encoding ST1B_Z.P.BI__
        __instruction_set A64
        __field size 21 +: 2
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 0xx0xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8 << UInt(size);
            integer msize = 8;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) src = Z[t];
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;
            addr = addr + mbytes;

__instruction aarch64_memory_single_general_immediate_signed_post_idx
    __encoding aarch64_memory_single_general_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111001 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction FMINNM_Z.P.ZS__
    __encoding FMINNM_Z.P.ZS__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field i1 5 +: 1
        __field Zdn 0 +: 5
        __opcode '01100101 xx011101 100xxx00 00xxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMinNum(element1, imm, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_unary_diff_neg_fp16
    __encoding aarch64_vector_arithmetic_unary_diff_neg_fp16
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 11111000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean neg = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_diff_neg_float
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 1x100000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean neg = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            if neg then
                element = FPNeg(element);
            else
                element = FPAbs(element);
            Elem[result, e, esize] = element;
        
        V[d] = result;

__instruction aarch64_integer_logical_immediate
    __encoding aarch64_integer_logical_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field N 22 +: 1
        __field immr 16 +: 6
        __field imms 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10010 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            bits(datasize) imm;
            if sf == '0' && N != '0' then UNDEFINED;
            (imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = imm;
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_sub_fp16_simd
    __encoding aarch64_vector_arithmetic_binary_uniform_sub_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 110xxxxx 000101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean abs = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_sub_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 1x1xxxxx 110101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean abs = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        bits(esize) diff;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            diff = FPSub(element1, element2, FPCR);
            Elem[result, e, esize] = if abs then FPAbs(diff) else diff;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_diff
    __encoding aarch64_vector_arithmetic_binary_uniform_diff
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0111x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean accumulate = (ac == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        bits(esize) absdiff;
        
        result = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            absdiff = Abs(element1 - element2)<esize-1:0>;
            Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_int
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_int
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 xxxxxxxx 0x00x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o2 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        integer element1;
        integer element2;
        bits(esize) product;
        
        element2 = UInt(Elem[operand2, index, esize]);
        for e = 0 to elements-1
            element1 = UInt(Elem[operand1, e, esize]);
            product = (element1 * element2)<esize-1:0>;
            if sub_op then
                Elem[result, e, esize] = Elem[operand3, e, esize] - product;
            else
                Elem[result, e, esize] = Elem[operand3, e, esize] + product;
        V[d] = result;

__instruction LDNT1H_Z.P.BI_Contiguous
    __encoding LDNT1H_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1000xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        constant integer mbytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction SQINCB_R.RS_SX
    __encoding SQINCB_R.RS_SX
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0010xxxx 111100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 32;

    __encoding SQINCB_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0011xxxx 111100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction aarch64_integer_tags_mcsettagpairpost
    __encoding aarch64_integer_tags_mcsettagpairpost
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 101xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = TRUE;
            boolean postindex = TRUE;
            boolean zero_data = FALSE;

    __encoding aarch64_integer_tags_mcsettagpairpre
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 101xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = TRUE;
            boolean postindex = FALSE;
            boolean zero_data = FALSE;

    __encoding aarch64_integer_tags_mcsettagpair
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 101xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
            boolean writeback = FALSE;
            boolean postindex = FALSE;
            boolean zero_data = FALSE;

    __execute
        bits(64) address;
        bits(4) tag;
        
        SetNotTagCheckedInstruction(TRUE);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if !postindex then
            address = address + offset;
        
        if zero_data then
            Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);
            Mem[address+TAG_GRANULE, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);
        
        tag = AllocationTagFromAddress(address);
        MemTag[address] = tag;
        MemTag[address+TAG_GRANULE] = tag;
        
        if writeback then
            if postindex then
                address = address + offset;
        
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction UQDECD_Z.ZS__
    __encoding UQDECD_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1110xxxx 110011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction ST4W_Z.P.BR_Contiguous
    __encoding ST4W_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 011xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction aarch64_integer_arithmetic_add_sub_extendedreg
    __encoding aarch64_integer_arithmetic_add_sub_extendedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field imm3 10 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01011 001xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            ExtendType extend_type = DecodeRegExtend(option);       
            integer shift = UInt(imm3);
            if shift > 4 then UNDEFINED;

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = if n == 31 then SP[] else X[n];
        bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction LD4D_Z.P.BI_Contiguous
    __encoding LD4D_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1110xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer offset = SInt(imm4);
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_integer_bitfield
    __encoding aarch64_integer_bitfield
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field N 22 +: 1
        __field immr 16 +: 6
        __field imms 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10011 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            
            boolean inzero;
            boolean extend;
            integer R;
            integer S;
            bits(datasize) wmask;
            bits(datasize) tmask;
            
            case opc of
                when '00' inzero = TRUE;  extend = TRUE;    // SBFM
                when '01' inzero = FALSE; extend = FALSE;   // BFM
                when '10' inzero = TRUE;  extend = FALSE;   // UBFM
                when '11' UNDEFINED;
            
            if sf == '1' && N != '1' then UNDEFINED;
            if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;
            
            R = UInt(immr);
            S = UInt(imms);
            (wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);

    __execute
        bits(datasize) dst = if inzero then Zeros() else X[d];
        bits(datasize) src = X[n];
        
        // perform bitfield move on low bits
        bits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);
        
        // determine extension bits (sign, zero or dest register)
        bits(datasize) top = if extend then Replicate(src<S>) else dst;
        
        // combine extension bits and result bits
        X[d] = (top AND NOT(tmask)) OR (bot AND tmask);

__instruction aarch64_vector_crypto_sha3_eor3
    __encoding aarch64_vector_crypto_sha3_eor3
        __instruction_set A64
        __field Rm 16 +: 5
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 000xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSHA3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer a = UInt(Ra);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        bits(128) Va = V[a];
        V[d] = Vn EOR Vm EOR Va;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction ST3W_Z.P.BI_Contiguous
    __encoding ST3W_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 0101xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer offset = SInt(imm4);
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction aarch64_vector_arithmetic_unary_cmp_int_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_cmp_int_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100000 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_int_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element;
        boolean test_passed;
        
        for e = 0 to elements-1
            element = SInt(Elem[operand, e, esize]);
            case comparison of
                when CompareOp_GT test_passed = element > 0;
                when CompareOp_GE test_passed = element >= 0;
                when CompareOp_EQ test_passed = element == 0;
                when CompareOp_LE test_passed = element <= 0;
                when CompareOp_LT test_passed = element < 0;
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction LD3D_Z.P.BR_Contiguous
    __encoding LD3D_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 110xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_memory_single_general_immediate_signed_post_idx
    __encoding aarch64_memory_single_general_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111001 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction FMAX_Z.P.ZZ__
    __encoding FMAX_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx000110 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMax(element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction LDNF1B_Z.P.BI_U8
    __encoding LDNF1B_Z.P.BI_U8
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0001xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LDNF1B_Z.P.BI_U16
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0011xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LDNF1B_Z.P.BI_U32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0101xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LDNF1B_Z.P.BI_U64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0111xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                // MemNF[] will return fault=TRUE if access is not performed for any reason
                (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_logical_and_orr
    __encoding aarch64_vector_arithmetic_binary_uniform_logical_and_orr
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean invert = (size<0> == '1');
            LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND
                result = operand1 AND operand2;
            when LogicalOp_ORR
                result = operand1 OR operand2;
        
        V[d] = result;

__instruction UQADD_Z.ZZ__
    __encoding UQADD_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 000101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 + element2, esize, unsigned);
        
        Z[d] = result;

__instruction FMAXNM_Z.P.ZS__
    __encoding FMAXNM_Z.P.ZS__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field i1 5 +: 1
        __field Zdn 0 +: 5
        __opcode '01100101 xx011100 100xxx00 00xxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMaxNum(element1, imm, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction LSRR_Z.P.ZZ__
    __encoding LSRR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010101 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = UInt(Elem[operand1, e, esize]);
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = LSR(element2, element1);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction SDOT_Z.ZZZ__
    __encoding SDOT_Z.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01000100 xx0xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '0x' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) res = Elem[operand3, e, esize];
            for i = 0 to 3
                integer element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                integer element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);
                res = res + element1 * element2;
            Elem[result, e, esize] = res;
        
        Z[da] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_round
    __encoding aarch64_vector_arithmetic_unary_fp16_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __encoding aarch64_vector_arithmetic_unary_float_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
        
        V[d] = result;

__instruction aarch64_float_arithmetic_add_sub
    __encoding aarch64_float_arithmetic_add_sub
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx 001x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean sub_op = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        if sub_op then
            result = FPSub(operand1, operand2, FPCR);
        else
            result = FPAdd(operand1, operand2, FPCR);
        
        V[d] = result;

__instruction PRFB_I.P.BI_S
    __encoding PRFB_I.P.BI_S
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000101 11xxxxxx 000xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 0;
            integer offset = SInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) addr;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        
        addr = base + ((offset * elements) << scale);
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Hint_Prefetch(addr, pref_hint, level, stream);
            addr = addr + (1 << scale);

__instruction BRKPB_P.P.PP__
    __encoding BRKPB_P.P.PP__
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0000xxxx 11xxxx0x xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = FALSE;

    __encoding BRKPBS_P.P.PP__
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0100xxxx 11xxxx0x xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        boolean last = (LastActive(mask, operand1, 8) == '1');
        
        for e = 0 to elements-1
            if ElemP[mask, e, 8] == '1' then
                last = last && (ElemP[operand2, e, 8] == '0');
                ElemP[result, e, 8] = if last then '1' else '0';
            else
                ElemP[result, e, 8] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_float_compare_uncond
    __encoding aarch64_float_compare_uncond
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field opc 3 +: 2
        __opcode '00011110 xx1xxxxx 001000xx xxxxx000'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer m = UInt(Rm);   // ignored when opc<0> == '1'
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean signal_all_nans = (opc<1> == '1');
            boolean cmp_with_zero = (opc<0> == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2;
        
        operand2 = if cmp_with_zero then FPZero('0') else V[m];
        
        PSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);

__instruction UADDV_R.P.Z__
    __encoding UADDV_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000100 xx000001 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        integer sum = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer element = UInt(Elem[operand, e, esize]);
                sum = sum + element;
        
        V[d] = sum<63:0>;

__instruction LD1RQH_Z.P.BR_Contiguous
    __encoding LD1RQH_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 100xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;

    __execute
        CheckSVEEnabled();
        integer elements = 128 DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g]; // low 16 bits only
        bits(64) offset;
        bits(128) result;
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = X[m];
        
        addr = base + UInt(offset) * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = Replicate(result, VL DIV 128);

__instruction INSR_Z.V__
    __encoding INSR_Z.V__
        __instruction_set A64
        __field size 22 +: 2
        __field Vm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000101 xx110100 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer m = UInt(Vm);

    __execute
        CheckSVEEnabled();
        bits(VL) dest = Z[dn];
        bits(esize) src = V[m];
        Z[dn] = dest<VL-esize-1:0> : src;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_vector_arithmetic_binary_uniform_logical_and_orr
    __encoding aarch64_vector_arithmetic_binary_uniform_logical_and_orr
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean invert = (size<0> == '1');
            LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND
                result = operand1 AND operand2;
            when LogicalOp_ORR
                result = operand1 OR operand2;
        
        V[d] = result;

__instruction CNTB_R.S__
    __encoding CNTB_R.S__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rd 0 +: 5
        __opcode '00000100 0010xxxx 111000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer d = UInt(Rd);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding CNTD_R.S__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rd 0 +: 5
        __opcode '00000100 1110xxxx 111000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer d = UInt(Rd);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding CNTH_R.S__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rd 0 +: 5
        __opcode '00000100 0110xxxx 111000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer d = UInt(Rd);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding CNTW_R.S__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rd 0 +: 5
        __opcode '00000100 1010xxxx 111000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer d = UInt(Rd);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        
        X[d] = (count * imm)<63:0>;

__instruction ASR_Z.P.ZW__
    __encoding ASR_Z.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx011000 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            integer element2 = UInt(Elem[operand2, (e * esize) DIV 64, 64]);
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = ASR(element1, element2);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction ADDVL_R.RI__
    __encoding ADDVL_R.RI__
        __instruction_set A64
        __field Rn 16 +: 5
        __field imm6 5 +: 6
        __field Rd 0 +: 5
        __opcode '00000100 001xxxxx 01010xxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer n = UInt(Rn);
            integer d = UInt(Rd);
            integer imm = SInt(imm6);

    __execute
        CheckSVEEnabled();
        bits(64) operand1 = if n == 31 then SP[] else X[n];
        bits(64) result = operand1 + (imm * (VL DIV 8));
        
        if d == 31 then
            SP[] = result;
        else
            X[d] = result;

__instruction aarch64_vector_logical
    __encoding aarch64_vector_logical
        __instruction_set A64
        __field Q 30 +: 1
        __field op 29 +: 1
        __field a 18 +: 1
        __field b 17 +: 1
        __field c 16 +: 1
        __field cmode 12 +: 4
        __field d 9 +: 1
        __field e 8 +: 1
        __field f 7 +: 1
        __field g 6 +: 1
        __field h 5 +: 1
        __field Rd 0 +: 5
        __opcode '0xx01111 00000xxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer rd = UInt(Rd);
            
            integer datasize = if Q == '1' then 128 else 64;
            bits(datasize) imm;
            bits(64) imm64;
            
            ImmediateOp operation;
            case cmode:op of
                when '0xx00' operation = ImmediateOp_MOVI;
                when '0xx01' operation = ImmediateOp_MVNI;
                when '0xx10' operation = ImmediateOp_ORR;
                when '0xx11' operation = ImmediateOp_BIC;
                when '10x00' operation = ImmediateOp_MOVI;
                when '10x01' operation = ImmediateOp_MVNI;
                when '10x10' operation = ImmediateOp_ORR;
                when '10x11' operation = ImmediateOp_BIC;
                when '110x0' operation = ImmediateOp_MOVI;
                when '110x1' operation = ImmediateOp_MVNI;
                when '1110x' operation = ImmediateOp_MOVI;
                when '11110' operation = ImmediateOp_MOVI;
                when '11111' 
                    // FMOV Dn,#imm is in main FP instruction set
                    if Q == '0' then UNDEFINED;
                    operation = ImmediateOp_MOVI;
            
            imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
            imm = Replicate(imm64, datasize DIV 64);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand;
        bits(datasize) result;
        
        case operation of
            when ImmediateOp_MOVI
                result = imm;
            when ImmediateOp_MVNI
                result = NOT(imm);
            when ImmediateOp_ORR
                operand = V[rd];
                result = operand OR imm;
            when ImmediateOp_BIC
                operand = V[rd];
                result = operand AND NOT(imm);
        
        V[rd] = result;

__instruction SEL_P.P.PP__
    __encoding SEL_P.P.PP__
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0000xxxx 01xxxx1x xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            bit element1 = ElemP[operand1, e, esize];
            bit element2 = ElemP[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                ElemP[result, e, esize] = element1;
            else
                ElemP[result, e, esize] = element2;
        
        P[d] = result;

__instruction aarch64_memory_literal_general
    __encoding aarch64_memory_literal_general
        __instruction_set A64
        __field opc 30 +: 2
        __field imm19 5 +: 19
        __field Rt 0 +: 5
        __opcode 'xx011000 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            MemOp memop = MemOp_LOAD;
            boolean signed = FALSE;
            integer size;
            bits(64) offset;
            
            case opc of
                when '00'
                    size = 4;
                when '01'
                    size = 8;
                when '10'
                    size = 4;
                    signed = TRUE;
                when '11'
                    memop = MemOp_PREFETCH;
            
            offset = SignExtend(imm19:'00', 64);
            boolean tag_checked = FALSE;

    __execute
        bits(64) address = PC[] + offset;
        bits(size*8) data;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        case memop of
            when MemOp_LOAD
                data = Mem[address, size, AccType_NORMAL];
                if signed then
                    X[t] = SignExtend(data, 64);
                else
                    X[t] = data;
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);

__instruction aarch64_float_arithmetic_round_frint
    __encoding aarch64_float_arithmetic_round_frint
        __instruction_set A64
        __field type1 22 +: 2
        __field rmode 15 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1001xx x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case rmode of
                when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundInt(operand, FPCR, rounding, exact);
        
        V[d] = result;

__instruction FTSMUL_Z.ZZ__
    __encoding FTSMUL_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx0xxxxx 000011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPTrigSMul(element1, element2, FPCR);
        
        Z[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_unpriv
    __encoding aarch64_memory_single_general_immediate_signed_offset_unpriv
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        
        unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
        unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
        
        user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
        if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
            acctype = AccType_UNPRIV;
        else
            acctype = AccType_NORMAL;
        
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_float_arithmetic_mul_add_sub
    __encoding aarch64_float_arithmetic_mul_add_sub
        __instruction_set A64
        __field type1 22 +: 2
        __field o1 21 +: 1
        __field Rm 16 +: 5
        __field o0 15 +: 1
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011111 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer a = UInt(Ra);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean opa_neg = (o1 == '1');
            boolean op1_neg = (o0 != o1);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operanda = V[a];
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        if opa_neg then operanda = FPNeg(operanda);
        if op1_neg then operand1 = FPNeg(operand1);
        result = FPMulAdd(operanda, operand1, operand2, FPCR);
        
        V[d] = result;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction aarch64_memory_single_general_immediate_signed_offset_normal
    __encoding aarch64_memory_single_general_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_reduce_fp16_maxnm_sisd
    __encoding aarch64_vector_reduce_fp16_maxnm_sisd
        __instruction_set A64
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 xx110000 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            if sz == '1' then UNDEFINED;
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

    __encoding aarch64_vector_reduce_fp_maxnm_sisd
        __instruction_set A64
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 xx110000 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction LD2H_Z.P.BR_Contiguous
    __encoding LD2H_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 101xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction FADDV_V.P.Z__
    __encoding FADDV_V.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '01100101 xx000000 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);

    __execute
        CheckSVEEnabled();
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(esize) identity = FPZero('0');
        
        V[d] = ReducePredicated(ReduceOp_FADD, operand, mask, identity);

__instruction aarch64_integer_arithmetic_add_sub_immediate
    __encoding aarch64_integer_arithmetic_add_sub_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field sh 22 +: 1
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10001 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            bits(datasize) imm;
            
            case sh of
                when '0' imm = ZeroExtend(imm12, datasize);
                when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = if n == 31 then SP[] else X[n];
        bits(datasize) operand2 = imm;
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction ZIP2_Z.ZZ__
    __encoding ZIP2_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx1xxxxx 011001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            integer part = 1;

    __encoding ZIP1_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx1xxxxx 011000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            integer part = 0;

    __execute
        CheckSVEEnabled();
        integer pairs = VL DIV (esize * 2);
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        integer base = part * pairs;
        for p = 0 to pairs-1
            Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];
            Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];
        
        Z[d] = result;

__instruction LD1D_Z.P.BZ_D.x32.scaled
    __encoding LD1D_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 1x1xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 3;

    __encoding LD1D_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 1x0xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1D_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 111xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 3;

    __encoding LD1D_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 110xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset = Z[m];
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction STNT1D_Z.P.BR_Contiguous
    __encoding STNT1D_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 100xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(64) offset = X[m];
        bits(VL) src;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        src = Z[t];
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
            offset = offset + 1;

__instruction aarch64_integer_arithmetic_address_pc_rel
    __encoding aarch64_integer_arithmetic_address_pc_rel
        __instruction_set A64
        __field op 31 +: 1
        __field immlo 29 +: 2
        __field immhi 5 +: 19
        __field Rd 0 +: 5
        __opcode 'xxx10000 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            boolean page = (op == '1');
            bits(64) imm;
            
            if page then
                imm = SignExtend(immhi:immlo:Zeros(12), 64);
            else
                imm = SignExtend(immhi:immlo, 64);

    __execute
        bits(64) base = PC[];
        
        if page then
            base<11:0> = Zeros(12);
        
        X[d] = base + imm;

__instruction FNMLS_Z.P.ZZZ__
    __encoding FNMLS_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100101 xx1xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean op1_neg = FALSE;
            boolean op3_neg = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            bits(esize) element3 = Elem[operand3, e, esize];
            
            if ElemP[mask, e, esize] == '1' then
                if op1_neg then element1 = FPNeg(element1);
                if op3_neg then element3 = FPNeg(element3);
                Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
            else
                Elem[result, e, esize] = element3;
        
        Z[da] = result;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction ORR_Z.ZZ__
    __encoding ORR_Z.ZZ__
        __instruction_set A64
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 011xxxxx 001100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        
        Z[d] = operand1 OR operand2;

__instruction SQADD_Z.ZI__
    __encoding SQADD_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field sh 13 +: 1
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx100100 11xxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size:sh == '001' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer imm = UInt(imm8);
            if sh == '1' then imm = imm << 8;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 + imm, esize, unsigned);
        
        Z[dn] = result;

__instruction LD1SW_Z.P.BZ_D.x32.scaled
    __encoding LD1SW_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 0x1xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 2;

    __encoding LD1SW_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 0x0xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1SW_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 011xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 64;
            boolean unsigned = FALSE;
            boolean offs_unsigned = TRUE;
            integer scale = 2;

    __encoding LD1SW_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 010xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 64;
            boolean unsigned = FALSE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset = Z[m];
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_vector_crypto_sha3op_sha256_hash
    __encoding aarch64_vector_crypto_sha3op_sha256_hash
        __instruction_set A64
        __field Rm 16 +: 5
        __field P 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 000xxxxx 010x00xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if !HaveSHA256Ext() then UNDEFINED;
            boolean part1 = (P == '0');

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) result;
        if part1 then
            result = SHA256hash(V[d], V[n], V[m], TRUE);
        else
            result = SHA256hash(V[n], V[d], V[m], FALSE);
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field a 23 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (a == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            if pair then
                element1 = Elem[concat, 2*e, esize];
                element2 = Elem[concat, (2*e)+1, esize];
            else
                element1 = Elem[operand1, e, esize];
                element2 = Elem[operand2, e, esize];
        
            if minimum then
                Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
            else
                Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);
        
        V[d] = result;

__instruction UQINCP_Z.P.Z__
    __encoding UQINCP_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Zdn 0 +: 5
        __opcode '00100101 xx101001 1000000x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[dn];
        bits(VL) result;
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        for e = 0 to elements-1
            integer element = Int(Elem[operand, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element + count, esize, unsigned);
        
        Z[dn] = result;

__instruction PTRUE_P.S__
    __encoding PTRUE_P.S__
        __instruction_set A64
        __field size 22 +: 2
        __field pattern 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx011000 111000xx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer d = UInt(Pd);
            boolean setflags = FALSE;
            bits(5) pat = pattern;

    __encoding PTRUES_P.S__
        __instruction_set A64
        __field size 22 +: 2
        __field pattern 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx011001 111000xx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer d = UInt(Pd);
            boolean setflags = TRUE;
            bits(5) pat = pattern;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(PL) result;
        
        for e = 0 to elements-1
            ElemP[result, e, esize] = if e < count then '1' else '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(result, result, esize);
        P[d] = result;

__instruction aarch64_integer_arithmetic_add_sub_extendedreg
    __encoding aarch64_integer_arithmetic_add_sub_extendedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field imm3 10 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01011 001xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            ExtendType extend_type = DecodeRegExtend(option);       
            integer shift = UInt(imm3);
            if shift > 4 then UNDEFINED;

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = if n == 31 then SP[] else X[n];
        bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_post_idx
    __encoding aarch64_memory_single_general_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111001 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_long
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 xxxxxxxx 0x10x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean sub_op = (o2 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(idxdsize)   operand2 = V[m];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        
        element2 = Int(Elem[operand2, index, esize], unsigned);
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            product = (element1 * element2)<2*esize-1:0>;
            if sub_op then
                Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
            else
                Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_extract_sat_sisd
    __encoding aarch64_vector_arithmetic_unary_extract_sat_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100001 010010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer part = 0;
            integer elements = 1;
            
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_extract_sat_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 010010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand = V[n];
        bits(datasize) result;
        bits(2*esize) element;
        boolean sat;
        
        for e = 0 to elements-1
            element = Elem[operand, e, 2*esize];
            (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);
            if sat then FPSR.QC = '1';
        
        Vpart[d, part] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_sub_int
    __encoding aarch64_vector_arithmetic_binary_uniform_sub_int
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 001001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer diff;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            diff = element1 - element2;
            Elem[result, e, esize] = diff<esize:1>;
        
        V[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_lda_stl
    __encoding aarch64_memory_single_general_immediate_signed_offset_lda_stl
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx011001 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_ORDERED;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 101101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' || size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean rounding = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 101101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' || size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean rounding = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer round_const = if rounding then 1 << (esize - 1) else 0;
        integer element1;
        integer element2;
        integer product;
        boolean sat;
        
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            element2 = SInt(Elem[operand2, e, esize]);
            product = (2 * element1 * element2) + round_const;
            (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction AND_Z.P.ZZ__
    __encoding AND_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx011010 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = element1 AND element2;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_vector_crypto_sha512_sha512su1
    __encoding aarch64_vector_crypto_sha512_sha512su1
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 011xxxxx 100010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSHA512Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(64) sig1;
        bits(128) Vtmp;
        bits(128) X = V[n];
        bits(128) Y = V[m];
        bits(128) W = V[d];
        
        sig1 = ROR(X<127:64>, 19) EOR ROR(X<127:64>,61) EOR ('000000':X<127:70>);
        Vtmp<127:64> = W<127:64> + sig1 + Y<127:64>;
        sig1 = ROR(X<63:0>, 19) EOR ROR(X<63:0>,61) EOR ('000000':X<63:6>);
        Vtmp<63:0> = W<63:0> + sig1 + Y<63:0>;
        V[d] = Vtmp;

__instruction SQINCH_R.RS_SX
    __encoding SQINCH_R.RS_SX
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0110xxxx 111100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 32;

    __encoding SQINCH_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0111xxxx 111100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction ST2H_Z.P.BI_Contiguous
    __encoding ST2H_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 1011xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer offset = SInt(imm4);
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction aarch64_vector_shift_left_long
    __encoding aarch64_vector_shift_left_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 101001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = UInt(immh:immb) - esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = Vpart[n, part];
        bits(datasize*2) result;
        integer element;
        
        for e = 0 to elements-1
            element = Int(Elem[operand, e, esize], unsigned) << shift;
            Elem[result, e, 2*esize] = element<2*esize-1:0>;
        
        V[d] = result;

__instruction aarch64_system_exceptions_debug_breakpoint
    __encoding aarch64_system_exceptions_debug_breakpoint
        __instruction_set A64
        __field imm16 5 +: 16
        __opcode '11010100 001xxxxx xxxxxxxx xxx00000'
        __guard TRUE
        __decode
            bits(16) comment = imm16;
            if HaveBTIExt() then
                BTypeCompatible = TRUE;

    __execute
        AArch64.SoftwareBreakpoint(comment);

__instruction LD1W_Z.P.BZ_S.x32.scaled
    __encoding LD1W_Z.P.BZ_S.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 0x1xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 2;

    __encoding LD1W_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 0x1xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 2;

    __encoding LD1W_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 0x0xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1W_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 0x0xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1W_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 011xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 2;

    __encoding LD1W_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 010xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset = Z[m];
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_system_barriers
    __encoding aarch64_system_barriers
        __instruction_set A64
        __field CRm 8 +: 4
        __field opc 5 +: 2
        __opcode '11010101 00000011 0011xxxx 1xx11111'
        __guard TRUE
        __decode
            MemBarrierOp op;
            MBReqDomain domain;
            MBReqTypes types;
            
            case opc of
                when '00' op = MemBarrierOp_DSB;
                when '01' op = MemBarrierOp_DMB;
                when '10' op = MemBarrierOp_ISB;
                otherwise 
                    if HaveSBExt() && CRm<3:0> == '0000' then 
                        op = MemBarrierOp_SB;
                    else
                        UNDEFINED;
            
            case CRm<3:2> of
                when '00' domain = MBReqDomain_OuterShareable;
                when '01' domain = MBReqDomain_Nonshareable;
                when '10' domain = MBReqDomain_InnerShareable;
                when '11' domain = MBReqDomain_FullSystem;
            
            case CRm<1:0> of
                when '01' types = MBReqTypes_Reads;
                when '10' types = MBReqTypes_Writes;
                when '11' types = MBReqTypes_All;
                otherwise
                    if CRm<3:2> == '01' then
                        op = MemBarrierOp_PSSBB;
                    elsif CRm<3:2> == '00' && opc == '00' then 
                        op = MemBarrierOp_SSBB;
                    elsif HaveSBExt() && CRm<3:2> == '00' && opc == '11' then 
                        op = MemBarrierOp_SB;
                    else
                        types  = MBReqTypes_All;
                        domain = MBReqDomain_FullSystem;

    __execute
        case op of
            when MemBarrierOp_DSB
                DataSynchronizationBarrier(domain, types);
            when MemBarrierOp_DMB
                DataMemoryBarrier(domain, types);
            when MemBarrierOp_ISB
                InstructionSynchronizationBarrier();
            when MemBarrierOp_SSBB
                SpeculativeStoreBypassBarrierToVA();
            when MemBarrierOp_PSSBB
                SpeculativeStoreBypassBarrierToPA();
            when MemBarrierOp_SB
                SpeculationBarrier();

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_narrow
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_narrow
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 01x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean round = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand1 = V[n];
        bits(2*datasize) operand2 = V[m];
        bits(datasize)   result;
        integer round_const = if round then 1 << (esize - 1) else 0;
        bits(2*esize) element1;
        bits(2*esize) element2;
        bits(2*esize) sum;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, 2*esize];
            element2 = Elem[operand2, e, 2*esize];
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            sum = sum + round_const;
            Elem[result, e, esize] = sum<2*esize-1:esize>;
        
        Vpart[d, part] = result;

__instruction STNT1W_Z.P.BR_Contiguous
    __encoding STNT1W_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 000xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(64) offset = X[m];
        bits(VL) src;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        src = Z[t];
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
            offset = offset + 1;

__instruction aarch64_memory_single_general_immediate_unsigned
    __encoding aarch64_memory_single_general_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111001 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_single
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_single
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer maxmin;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
            Elem[result, e, esize] = maxmin<esize-1:0>;
        
        V[d] = result;

__instruction FRECPE_Z.Z__
    __encoding FRECPE_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx001110 001100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand = Z[n];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRecipEstimate(element, FPCR);
        
        Z[d] = result;

__instruction INCP_Z.P.Z__
    __encoding INCP_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Zdn 0 +: 5
        __opcode '00100101 xx101100 1000000x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[dn];
        bits(VL) result;
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = Elem[operand, e, esize] + count;
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_unary_add_saturating_sisd
    __encoding aarch64_vector_arithmetic_unary_add_saturating_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100000 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_add_saturating_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        
        bits(datasize) operand2 = V[d];
        integer op1;
        integer op2;
        boolean sat;
        
        for e = 0 to elements-1
            op1 = Int(Elem[operand, e, esize], !unsigned);
            op2 = Int(Elem[operand2, e, esize], unsigned);
            (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);
            if sat then FPSR.QC = '1';
        V[d] = result;

__instruction aarch64_memory_single_general_register
    __encoding aarch64_memory_single_general_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction LD1B_Z.P.BR_U8
    __encoding LD1B_Z.P.BR_U8
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 000xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;
            integer msize = 8;
            boolean unsigned = TRUE;

    __encoding LD1B_Z.P.BR_U16
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 001xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 8;
            boolean unsigned = TRUE;

    __encoding LD1B_Z.P.BR_U32
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 010xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = TRUE;

    __encoding LD1B_Z.P.BR_U64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 011xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction LD1B_Z.P.AI_S
    __encoding LD1B_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 001xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __encoding LD1B_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 001xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_integer_arithmetic_add_sub_immediate
    __encoding aarch64_integer_arithmetic_add_sub_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field sh 22 +: 1
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10001 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            bits(datasize) imm;
            
            case sh of
                when '0' imm = ZeroExtend(imm12, datasize);
                when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = if n == 31 then SP[] else X[n];
        bits(datasize) operand2 = imm;
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_add_halving_rounding
    __encoding aarch64_vector_arithmetic_binary_uniform_add_halving_rounding
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 000101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_cmp_fp16_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_cmp_fp16_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 11111000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 1x100000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_fp16_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 11111000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 1x100000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) zero = FPZero('0');
        bits(esize) element;
        boolean test_passed;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            case comparison of
                when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
                when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
                when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
                when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
                when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction LD1SB_Z.P.BR_S16
    __encoding LD1SB_Z.P.BR_S16
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 110xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 8;
            boolean unsigned = FALSE;

    __encoding LD1SB_Z.P.BR_S32
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 101xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = FALSE;

    __encoding LD1SB_Z.P.BR_S64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 100xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction LD1SB_Z.P.AI_S
    __encoding LD1SB_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 001xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = UInt(imm5);

    __encoding LD1SB_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 001xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_long
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 00x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        integer sum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            Elem[result, e, 2*esize] = sum<2*esize-1:0>;
        
        V[d] = result;

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_vector_reduce_fp16_max_sisd
    __encoding aarch64_vector_reduce_fp16_max_sisd
        __instruction_set A64
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 xx110000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            if sz == '1' then UNDEFINED;
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

    __encoding aarch64_vector_reduce_fp_max_sisd
        __instruction_set A64
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 xx110000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction SUBR_Z.P.ZZ__
    __encoding SUBR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx000011 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = element2 - element1;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_diff
    __encoding aarch64_vector_arithmetic_binary_uniform_diff
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0111x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean accumulate = (ac == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        bits(esize) absdiff;
        
        result = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            absdiff = Abs(element1 - element2)<esize-1:0>;
            Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_add_pairwise
    __encoding aarch64_vector_arithmetic_unary_add_pairwise
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 14 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 0x1010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV (2*esize);
            boolean acc = (op == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        
        bits(2*esize) sum;
        integer op1;
        integer op2;
        
        result = if acc then V[d] else Zeros();
        for e = 0 to elements-1
            op1 = Int(Elem[operand, 2*e+0, esize], unsigned);
            op2 = Int(Elem[operand, 2*e+1, esize], unsigned);
            sum = (op1 + op2)<2*esize-1:0>;
            Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;
        
        V[d] = result;

__instruction aarch64_system_barriers
    __encoding aarch64_system_barriers
        __instruction_set A64
        __field CRm 8 +: 4
        __field opc 5 +: 2
        __opcode '11010101 00000011 0011xxxx 1xx11111'
        __guard TRUE
        __decode
            MemBarrierOp op;
            MBReqDomain domain;
            MBReqTypes types;
            
            case opc of
                when '00' op = MemBarrierOp_DSB;
                when '01' op = MemBarrierOp_DMB;
                when '10' op = MemBarrierOp_ISB;
                otherwise 
                    if HaveSBExt() && CRm<3:0> == '0000' then 
                        op = MemBarrierOp_SB;
                    else
                        UNDEFINED;
            
            case CRm<3:2> of
                when '00' domain = MBReqDomain_OuterShareable;
                when '01' domain = MBReqDomain_Nonshareable;
                when '10' domain = MBReqDomain_InnerShareable;
                when '11' domain = MBReqDomain_FullSystem;
            
            case CRm<1:0> of
                when '01' types = MBReqTypes_Reads;
                when '10' types = MBReqTypes_Writes;
                when '11' types = MBReqTypes_All;
                otherwise
                    if CRm<3:2> == '01' then
                        op = MemBarrierOp_PSSBB;
                    elsif CRm<3:2> == '00' && opc == '00' then 
                        op = MemBarrierOp_SSBB;
                    elsif HaveSBExt() && CRm<3:2> == '00' && opc == '11' then 
                        op = MemBarrierOp_SB;
                    else
                        types  = MBReqTypes_All;
                        domain = MBReqDomain_FullSystem;

    __execute
        case op of
            when MemBarrierOp_DSB
                DataSynchronizationBarrier(domain, types);
            when MemBarrierOp_DMB
                DataMemoryBarrier(domain, types);
            when MemBarrierOp_ISB
                InstructionSynchronizationBarrier();
            when MemBarrierOp_SSBB
                SpeculativeStoreBypassBarrierToVA();
            when MemBarrierOp_PSSBB
                SpeculativeStoreBypassBarrierToPA();
            when MemBarrierOp_SB
                SpeculationBarrier();

__instruction FADD_Z.ZZ__
    __encoding FADD_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx0xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPAdd(element1, element2, FPCR);
        
        Z[d] = result;

__instruction FRECPS_Z.ZZ__
    __encoding FRECPS_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx0xxxxx 000110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPRecipStepFused(element1, element2);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_add_saturating_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_add_saturating_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 000011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_add_saturating_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 000011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer sum;
        boolean sat;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            sum = element1 + element2;
            (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_shift_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_shift_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');
            if S == '0' && size != '11' then UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_shift_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        integer round_const = 0;
        integer shift;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            shift = SInt(Elem[operand2, e, esize]<7:0>);
            if rounding then
                round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift 
            element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
            if saturating then
                (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                if sat then FPSR.QC = '1';
            else
                Elem[result, e, esize] = element<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_vector_reduce_fp16_maxnm_simd
    __encoding aarch64_vector_reduce_fp16_maxnm_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field o1 23 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 x0110000 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

    __encoding aarch64_vector_reduce_fp_maxnm_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx110000 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q != '01' then UNDEFINED; // .4S only
            
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011111 xxxxxxxx 0x11x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;
            
            boolean sub_op = (o2 == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 xxxxxxxx 0x11x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o2 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(idxdsize)   operand2 = V[m];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        integer accum;
        boolean sat1;
        boolean sat2;
        
        element2 = SInt(Elem[operand2, index, esize]);
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
            if sub_op then
                accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
            else
                accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
            (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
            if sat1 || sat2 then FPSR.QC = '1';
        
        V[d] = result;

__instruction ST4D_Z.P.BR_Contiguous
    __encoding ST4D_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 111xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction CNTP_R.P.P__
    __encoding CNTP_R.P.P__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Rd 0 +: 5
        __opcode '00100101 xx100000 10xxxx0x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer d = UInt(Rd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand = P[n];
        bits(64) sum = Zeros();
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' && ElemP[operand, e, esize] == '1' then
                sum = sum + 1;
        X[d] = sum;

__instruction aarch64_memory_single_general_register
    __encoding aarch64_memory_single_general_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction SXTB_Z.P.Z__
    __encoding SXTB_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx010000 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer s_esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean unsigned = FALSE;

    __encoding SXTH_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx010010 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size != '1x' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer s_esize = 16;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean unsigned = FALSE;

    __encoding SXTW_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx010100 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer s_esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Extend(element<s_esize-1:0>, esize, unsigned);
        
        Z[d] = result;

__instruction LD4W_Z.P.BI_Contiguous
    __encoding LD4W_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0110xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer offset = SInt(imm4);
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_float_arithmetic_round_frint_32_64
    __encoding aarch64_float_arithmetic_round_frint_32_64
        __instruction_set A64
        __field type1 22 +: 2
        __field op 15 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx10100x x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFrintExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '1x' UNDEFINED;
            
            integer intsize = if op<1> == '0' then 32 else 64;
            
            FPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundIntN(operand, FPCR, rounding, intsize);
        
        V[d] = result;

__instruction UQINCW_Z.ZS__
    __encoding UQINCW_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1010xxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 xx0xxxxx 1000x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' || size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean rounding = TRUE;
            boolean sub_op = (S == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx0xxxxx 1000x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' || size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean rounding = TRUE;
            boolean sub_op = (S == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        integer rounding_const = if rounding then 1 << (esize - 1) else 0;
        integer element1;
        integer element2;
        integer element3;
        integer product;
        boolean sat;
        
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            element2 = SInt(Elem[operand2, e, esize]);
            element3 = SInt(Elem[operand3, e, esize]);
            if sub_op then
                accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
            else
                accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
            (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction SMAX_Z.P.ZZ__
    __encoding SMAX_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx001000 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer maximum = Max(element1, element2);
                Elem[result, e, esize] = maximum<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction ST3D_Z.P.BI_Contiguous
    __encoding ST3D_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 1101xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer offset = SInt(imm4);
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction LD3W_Z.P.BR_Contiguous
    __encoding LD3W_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 010xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction DUP_Z.Zi__
    __encoding DUP_Z.Zi__
        __instruction_set A64
        __field imm2 22 +: 2
        __field tsz 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx1xxxxx 001000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            bits(7) imm = imm2:tsz;
            case tsz of
                when '00000' UNDEFINED;
                when '10000' esize = 128; index = UInt(imm<6:5>);
                when 'x1000' esize = 64;  index = UInt(imm<6:4>);
                when 'xx100' esize = 32;  index = UInt(imm<6:3>);
                when 'xxx10' esize = 16;  index = UInt(imm<6:2>);
                when 'xxxx1' esize = 8;   index = UInt(imm<6:1>);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) result;
        bits(esize) element;
        
        if index >= elements then
            element = Zeros();
        else
            element = Elem[operand1, index, esize];
        result = Replicate(element);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_wide
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_wide
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 00x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand1 = V[n];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        integer sum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, 2*esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            Elem[result, e, 2*esize] = sum<2*esize-1:0>;
        
        V[d] = result;

__instruction ADDPL_R.RI__
    __encoding ADDPL_R.RI__
        __instruction_set A64
        __field Rn 16 +: 5
        __field imm6 5 +: 6
        __field Rd 0 +: 5
        __opcode '00000100 011xxxxx 01010xxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer n = UInt(Rn);
            integer d = UInt(Rd);
            integer imm = SInt(imm6);

    __execute
        CheckSVEEnabled();
        bits(64) operand1 = if n == 31 then SP[] else X[n];
        bits(64) result = operand1 + (imm * (PL DIV 8));
        
        if d == 31 then
            SP[] = result;
        else
            X[d] = result;

__instruction aarch64_memory_single_general_register
    __encoding aarch64_memory_single_general_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_transfer_vector_table
    __encoding aarch64_vector_transfer_vector_table
        __instruction_set A64
        __field Q 30 +: 1
        __field Rm 16 +: 5
        __field len 13 +: 2
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 000xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV 8;
            integer regs = UInt(len) + 1;
            boolean is_tbl = (op == '0');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) indices = V[m];
        bits(128*regs) table = Zeros();
        bits(datasize) result;
        integer index;
        
        // Create table from registers
        for i = 0 to regs - 1
            table<128*i+127:128*i> = V[n];
            n = (n + 1) MOD 32;
        
        result = if is_tbl then Zeros() else V[d];
        for i = 0 to elements - 1
            index = UInt(Elem[indices, i, 8]);
            if index < 16 * regs then
                Elem[result, i, 8] = Elem[table, index, 8];
        
        V[d] = result;

__instruction STR_P.BI__
    __encoding STR_P.BI__
        __instruction_set A64
        __field imm9h 16 +: 6
        __field imm9l 10 +: 3
        __field Rn 5 +: 5
        __field Pt 0 +: 4
        __opcode '11100101 10xxxxxx 000xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Pt);
            integer n = UInt(Rn);
            integer imm = SInt(imm9h:imm9l);

    __execute
        CheckSVEEnabled();
        integer elements = PL DIV 8;
        bits(PL) src;
        bits(64) base;
        integer offset = imm * elements;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        src = P[t];
        boolean aligned = AArch64.CheckAlignment(base + offset, 2, AccType_NORMAL, TRUE);
        for e = 0 to elements-1
            AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned] = Elem[src, e, 8];
            offset = offset + 1;

__instruction aarch64_memory_literal_general
    __encoding aarch64_memory_literal_general
        __instruction_set A64
        __field opc 30 +: 2
        __field imm19 5 +: 19
        __field Rt 0 +: 5
        __opcode 'xx011000 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            MemOp memop = MemOp_LOAD;
            boolean signed = FALSE;
            integer size;
            bits(64) offset;
            
            case opc of
                when '00'
                    size = 4;
                when '01'
                    size = 8;
                when '10'
                    size = 4;
                    signed = TRUE;
                when '11'
                    memop = MemOp_PREFETCH;
            
            offset = SignExtend(imm19:'00', 64);
            boolean tag_checked = FALSE;

    __execute
        bits(64) address = PC[] + offset;
        bits(size*8) data;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        case memop of
            when MemOp_LOAD
                data = Mem[address, size, AccType_NORMAL];
                if signed then
                    X[t] = SignExtend(data, 64);
                else
                    X[t] = data;
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);

__instruction aarch64_vector_arithmetic_unary_rbit
    __encoding aarch64_vector_arithmetic_unary_rbit
        __instruction_set A64
        __field Q 30 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 01100000 010110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV 8;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        bits(esize) rev;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            for i = 0 to esize-1
                rev<esize-1-i> = element<i>;
            Elem[result, e, esize] = rev;
        
        V[d] = result;

__instruction aarch64_memory_single_simdfp_register
    __encoding aarch64_memory_single_simdfp_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111100 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(opc<1>:size);
            if scale > 4 then UNDEFINED;
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_VEC;
        MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        bits(64) address;
        bits(datasize) data;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                data = V[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                V[t] = data;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_integer_logical_shiftedreg
    __encoding aarch64_integer_logical_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field shift 22 +: 2
        __field N 21 +: 1
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01010 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);
            boolean invert = (N == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        X[d] = result;

__instruction NEG_Z.P.Z__
    __encoding NEG_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx010111 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            integer element = SInt(Elem[operand, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                element = -element;
                Elem[result, e, esize] = element<esize-1:0>;
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_int_product
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_product
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 100111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if U == '1' && size != '00' then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean poly = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        bits(esize) product;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if poly then
                product = PolynomialMult(element1, element2)<esize-1:0>;
            else
                product = (UInt(element1) * UInt(element2))<esize-1:0>;
            Elem[result, e, esize] = product;
        
        V[d] = result;

__instruction aarch64_memory_vector_multiple_no_wb
    __encoding aarch64_memory_vector_multiple_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 0x000000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_multiple_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field Rm 16 +: 5
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << UInt(size);
        integer elements = datasize DIV esize;
        
        integer rpt;    // number of iterations
        integer selem;  // structure elements 
        
        case opcode of
            when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
            when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
            when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
            when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
            when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
            when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
            when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
            otherwise UNDEFINED;
        
        // .1D format only permitted with LD1 & ST1
        if size:Q == '110' && selem != 1 then UNDEFINED;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(datasize) rval;
        integer tt;
        constant integer ebytes = esize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        for r = 0 to rpt-1
            for e = 0 to elements-1
                tt = (t + r) MOD 32;
                for s = 0 to selem-1
                    rval = V[tt];
                    if memop == MemOp_LOAD then
                        Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                        V[tt] = rval;
                    else // memop == MemOp_STORE
                        Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                    offs = offs + ebytes;
                    tt = (tt + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction STNT1B_Z.P.BI_Contiguous
    __encoding STNT1B_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 0001xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        constant integer mbytes = esize DIV 8;
        bits(VL) src;
        bits(PL) mask = P[g];
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        src = Z[t];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
            addr = addr + mbytes;

__instruction aarch64_memory_single_general_register
    __encoding aarch64_memory_single_general_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction aarch64_memory_literal_general
    __encoding aarch64_memory_literal_general
        __instruction_set A64
        __field opc 30 +: 2
        __field imm19 5 +: 19
        __field Rt 0 +: 5
        __opcode 'xx011000 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            MemOp memop = MemOp_LOAD;
            boolean signed = FALSE;
            integer size;
            bits(64) offset;
            
            case opc of
                when '00'
                    size = 4;
                when '01'
                    size = 8;
                when '10'
                    size = 4;
                    signed = TRUE;
                when '11'
                    memop = MemOp_PREFETCH;
            
            offset = SignExtend(imm19:'00', 64);
            boolean tag_checked = FALSE;

    __execute
        bits(64) address = PC[] + offset;
        bits(size*8) data;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        case memop of
            when MemOp_LOAD
                data = Mem[address, size, AccType_NORMAL];
                if signed then
                    X[t] = SignExtend(data, 64);
                else
                    X[t] = data;
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);

__instruction BRKA_P.P.P__
    __encoding BRKA_P.P.P__
        __instruction_set A64
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field M 4 +: 1
        __field Pd 0 +: 4
        __opcode '00100101 00010000 01xxxx0x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer d = UInt(Pd);
            boolean merging = (M == '1');
            boolean setflags = FALSE;

    __encoding BRKAS_P.P.P_Z
        __instruction_set A64
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 01010000 01xxxx0x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer d = UInt(Pd);
            boolean merging = FALSE;
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand  = P[n];
        bits(PL) operand2 = P[d];
        boolean break = FALSE;
        bits(PL) result;
        
        for e = 0 to elements-1
            boolean element = ElemP[operand, e, esize] == '1';
            if ElemP[mask, e, esize] == '1' then
                ElemP[result, e, esize] = if !break then '1' else '0';
                break = break || element;
            elsif merging then
                ElemP[result, e, esize] = ElemP[operand2, e, esize];
            else
                ElemP[result, e, esize] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_vector_logical
    __encoding aarch64_vector_logical
        __instruction_set A64
        __field Q 30 +: 1
        __field op 29 +: 1
        __field a 18 +: 1
        __field b 17 +: 1
        __field c 16 +: 1
        __field cmode 12 +: 4
        __field d 9 +: 1
        __field e 8 +: 1
        __field f 7 +: 1
        __field g 6 +: 1
        __field h 5 +: 1
        __field Rd 0 +: 5
        __opcode '0xx01111 00000xxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer rd = UInt(Rd);
            
            integer datasize = if Q == '1' then 128 else 64;
            bits(datasize) imm;
            bits(64) imm64;
            
            ImmediateOp operation;
            case cmode:op of
                when '0xx00' operation = ImmediateOp_MOVI;
                when '0xx01' operation = ImmediateOp_MVNI;
                when '0xx10' operation = ImmediateOp_ORR;
                when '0xx11' operation = ImmediateOp_BIC;
                when '10x00' operation = ImmediateOp_MOVI;
                when '10x01' operation = ImmediateOp_MVNI;
                when '10x10' operation = ImmediateOp_ORR;
                when '10x11' operation = ImmediateOp_BIC;
                when '110x0' operation = ImmediateOp_MOVI;
                when '110x1' operation = ImmediateOp_MVNI;
                when '1110x' operation = ImmediateOp_MOVI;
                when '11110' operation = ImmediateOp_MOVI;
                when '11111' 
                    // FMOV Dn,#imm is in main FP instruction set
                    if Q == '0' then UNDEFINED;
                    operation = ImmediateOp_MOVI;
            
            imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
            imm = Replicate(imm64, datasize DIV 64);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand;
        bits(datasize) result;
        
        case operation of
            when ImmediateOp_MOVI
                result = imm;
            when ImmediateOp_MVNI
                result = NOT(imm);
            when ImmediateOp_ORR
                operand = V[rd];
                result = operand OR imm;
            when ImmediateOp_BIC
                operand = V[rd];
                result = operand AND NOT(imm);
        
        V[rd] = result;

__instruction UQINCH_Z.ZS__
    __encoding UQINCH_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 0110xxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp16_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field E 23 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x10xxxxx 0010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field E 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 1110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field E 23 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 0010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field E 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 1110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if abs then
                element1 = FPAbs(element1);
                element2 = FPAbs(element2);
            case cmp of
                when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
                when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
                when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_float_arithmetic_max_min
    __encoding aarch64_float_arithmetic_max_min
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field op 12 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx 01xx10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            FPMaxMinOp operation;
            case op of
                when '00' operation = FPMaxMinOp_MAX;
                when '01' operation = FPMaxMinOp_MIN;
                when '10' operation = FPMaxMinOp_MAXNUM;
                when '11' operation = FPMaxMinOp_MINNUM;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        case operation of
            when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);
            when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);
            when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);
            when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);
        
        V[d] = result;

__instruction SUB_Z.P.ZZ__
    __encoding SUB_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx000001 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = element1 - element2;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction FADD_Z.P.ZZ__
    __encoding FADD_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx000000 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPAdd(element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction FEXPA_Z.Z__
    __encoding FEXPA_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx100000 101110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand  = Z[n];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPExpA(element);
        
        Z[d] = result;

__instruction aarch64_integer_arithmetic_add_sub_shiftedreg
    __encoding aarch64_integer_arithmetic_add_sub_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field shift 22 +: 2
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01011 xx0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            
            if shift == '11' then UNDEFINED;
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        X[d] = result;

__instruction aarch64_vector_arithmetic_unary_not
    __encoding aarch64_vector_arithmetic_unary_not
        __instruction_set A64
        __field Q 30 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 00100000 010110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV 8;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = NOT(element);
        
        V[d] = result;

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_cmp_int_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_cmp_int_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100000 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_int_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element;
        boolean test_passed;
        
        for e = 0 to elements-1
            element = SInt(Elem[operand, e, esize]);
            case comparison of
                when CompareOp_GT test_passed = element > 0;
                when CompareOp_GE test_passed = element >= 0;
                when CompareOp_EQ test_passed = element == 0;
                when CompareOp_LE test_passed = element <= 0;
                when CompareOp_LT test_passed = element < 0;
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_diff
    __encoding aarch64_vector_arithmetic_binary_disparate_diff
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field op 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 01x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean accumulate = (op == '0');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) absdiff;
        
        result = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            absdiff = Abs(element1 - element2)<2*esize-1:0>;
            Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
        V[d] = result;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction UMAXV_R.P.Z__
    __encoding UMAXV_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000100 xx001001 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        integer maximum = if unsigned then 0 else -(2^(esize-1));
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer element = Int(Elem[operand, e, esize], unsigned);
                maximum = Max(maximum, element);
        
        V[d] = maximum<esize-1:0>;

__instruction aarch64_integer_arithmetic_add_sub_shiftedreg
    __encoding aarch64_integer_arithmetic_add_sub_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field shift 22 +: 2
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01011 xx0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            
            if shift == '11' then UNDEFINED;
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        X[d] = result;

__instruction ST1D_Z.P.AI_D
    __encoding ST1D_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 110xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(VL) src = Z[t];
        bits(PL) mask = P[g];
        bits(64) addr;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;

__instruction ST1D_Z.P.BR__
    __encoding ST1D_Z.P.BR__
        __instruction_set A64
        __field size 21 +: 2
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 1xxxxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '0x' then SEE(sve_mem_spill);
            if size == '10' then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8 << UInt(size);
            integer msize = 64;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        bits(VL) src = Z[t];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;
            offset = offset + 1;

__instruction LD1W_Z.P.BI_U32
    __encoding LD1W_Z.P.BI_U32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0100xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LD1W_Z.P.BI_U64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0110xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction aarch64_integer_tags_mcinserttagmask
    __encoding aarch64_integer_tags_mcinserttagmask
        __instruction_set A64
        __field Xm 16 +: 5
        __field Xn 5 +: 5
        __field Xd 0 +: 5
        __opcode '10011010 110xxxxx 000101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Xd);
            integer n = UInt(Xn);
            integer m = UInt(Xm);

    __execute
        bits(64) address = if n == 31 then SP[] else X[n];
        bits(64) mask = X[m];
        bits(4) tag = AllocationTagFromAddress(address);
        
        mask<UInt(tag)> = '1';
        X[d] = mask;

__instruction aarch64_vector_arithmetic_binary_uniform_diff
    __encoding aarch64_vector_arithmetic_binary_uniform_diff
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0111x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean accumulate = (ac == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        bits(esize) absdiff;
        
        result = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            absdiff = Abs(element1 - element2)<esize-1:0>;
            Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
        V[d] = result;

__instruction aarch64_memory_vector_multiple_no_wb
    __encoding aarch64_memory_vector_multiple_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 0x000000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_multiple_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field Rm 16 +: 5
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << UInt(size);
        integer elements = datasize DIV esize;
        
        integer rpt;    // number of iterations
        integer selem;  // structure elements 
        
        case opcode of
            when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
            when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
            when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
            when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
            when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
            when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
            when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
            otherwise UNDEFINED;
        
        // .1D format only permitted with LD1 & ST1
        if size:Q == '110' && selem != 1 then UNDEFINED;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(datasize) rval;
        integer tt;
        constant integer ebytes = esize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        for r = 0 to rpt-1
            for e = 0 to elements-1
                tt = (t + r) MOD 32;
                for s = 0 to selem-1
                    rval = V[tt];
                    if memop == MemOp_LOAD then
                        Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                        V[tt] = rval;
                    else // memop == MemOp_STORE
                        Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                    offs = offs + ebytes;
                    tt = (tt + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction TRN1_P.PP__
    __encoding TRN1_P.PP__
        __instruction_set A64
        __field size 22 +: 2
        __field Pm 16 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00000101 xx10xxxx 0101000x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            integer part = 0;

    __encoding TRN2_P.PP__
        __instruction_set A64
        __field size 22 +: 2
        __field Pm 16 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00000101 xx10xxxx 0101010x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            integer part = 1;

    __execute
        CheckSVEEnabled();
        integer pairs = VL DIV (esize * 2);
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        for p = 0 to pairs-1
            Elem[result, 2*p+0, esize DIV 8] = Elem[operand1, 2*p+part, esize DIV 8];
            Elem[result, 2*p+1, esize DIV 8] = Elem[operand2, 2*p+part, esize DIV 8];
        
        P[d] = result;

__instruction aarch64_integer_tags_mcsubtag
    __encoding aarch64_integer_tags_mcsubtag
        __instruction_set A64
        __field uimm6 16 +: 6
        __field op3 14 +: 2
        __field uimm4 10 +: 4
        __field Xn 5 +: 5
        __field Xd 0 +: 5
        __opcode '11010001 10xxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Xd);
            integer n = UInt(Xn);
            bits(4) tag_offset = uimm4;
            bits(64) offset = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);
            boolean ADD = FALSE;

    __execute
        bits(64) operand1 = if n == 31 then SP[] else X[n];
        bits(4) start_tag = AllocationTagFromAddress(operand1);
        bits(16) exclude = GCR_EL1.Exclude;
        bits(64) result;
        bits(4) rtag;
        
        if AllocationTagAccessIsEnabled() then
            rtag = ChooseNonExcludedTag(start_tag, tag_offset, exclude);
        else
            rtag = '0000';
        
        if ADD then
            (result, -) = AddWithCarry(operand1, offset, '0');
        else
            (result, -) = AddWithCarry(operand1, NOT(offset), '1');
        
        result = AddressWithAllocationTag(result, rtag);
        
        if d == 31 then
            SP[] = result;
        else
            X[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_normal
    __encoding aarch64_memory_single_general_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_memory_pair_general_no_alloc
    __encoding aarch64_memory_pair_general_no_alloc
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101000 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = FALSE;
            boolean postindex = FALSE;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer t2 = UInt(Rt2);
        AccType acctype = AccType_STREAM;
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        if opc<0> == '1' then UNDEFINED;
        integer scale = 2 + UInt(opc<1>);
        integer datasize = 8 << scale;
        bits(64) offset = LSL(SignExtend(imm7, 64), scale);
        boolean tag_checked = wback || n != 31;
    __execute
        bits(64) address;
        bits(datasize) data1;
        bits(datasize) data2;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown && t == n then
                    data1 = bits(datasize) UNKNOWN;
                else
                    data1 = X[t];
                if rt_unknown && t2 == n then
                    data2 = bits(datasize) UNKNOWN;
                else
                    data2 = X[t2];
                Mem[address + 0     , dbytes, acctype] = data1;
                Mem[address + dbytes, dbytes, acctype] = data2;
        
            when MemOp_LOAD
                data1 = Mem[address + 0     , dbytes, acctype];
                data2 = Mem[address + dbytes, dbytes, acctype];
                if rt_unknown then
                    data1 = bits(datasize) UNKNOWN;
                    data2 = bits(datasize) UNKNOWN;
                X[t]  = data1;
                X[t2] = data2;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_arithmetic_unary_rev
    __encoding aarch64_vector_arithmetic_unary_rev
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 000x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            // size=esize:   B(0),  H(1),  S(1), D(S)
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            
            // op=REVx: 64(0), 32(1), 16(2)
            bits(2) op = o0:U; 
            
            // => op+size: 
            //    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X
            //    32+B = 1, 32+H = 2, 32+S = X, 32+D = X
            //    16+B = 2, 16+H = X, 16+S = X, 16+D = X
            //     8+B = X,  8+H = X,  8+S = X,  8+D = X
            // => 3-(op+size) (index bits in group)
            //    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X
            //    32+B = 2, 32+H = 1, 32+S = X, 32+D = X
            //    16+B = 1, 16+H = X, 16+S = X, 16+D = X
            //     8+B = X,  8+H = X,  8+S = X,  8+D = X
            
            // index bits within group: 1, 2, 3
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            
            integer containers = datasize DIV container_size;
            integer elements_per_container = container_size DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element = 0;
        integer rev_element;
        for c = 0 to containers-1
            rev_element = element + elements_per_container - 1;
            for e = 0 to elements_per_container-1
                Elem[result, rev_element, esize] = Elem[operand, element, esize];
                element = element + 1;
                rev_element = rev_element - 1;
        
        V[d] = result;

__instruction aarch64_integer_arithmetic_pointer_mcsubtracttaggedaddress
    __encoding aarch64_integer_arithmetic_pointer_mcsubtracttaggedaddress
        __instruction_set A64
        __field Xm 16 +: 5
        __field Xn 5 +: 5
        __field Xd 0 +: 5
        __opcode '10011010 110xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Xd);
            integer n = UInt(Xn);
            integer m = UInt(Xm);
            boolean setflags = FALSE;

    __execute
        bits(64) operand1 = if n == 31 then SP[] else X[n];
        bits(64) operand2 = if m == 31 then SP[] else X[m];
        operand1 = SignExtend(operand1<55:0>, 64);
        operand2 = SignExtend(operand2<55:0>, 64);
        
        bits(64) result;
        bits(4) nzcv;
        
        operand2 = NOT(operand2);
        (result, nzcv) = AddWithCarry(operand1, operand2, '1');
        
        if setflags then
            PSTATE.<N,Z,C,V> = nzcv;
        X[d] = result;

__instruction LD3B_Z.P.BI_Contiguous
    __encoding LD3B_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0100xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer offset = SInt(imm4);
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_float_compare_cond
    __encoding aarch64_float_compare_cond
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field cond 12 +: 4
        __field Rn 5 +: 5
        __field op 4 +: 1
        __field nzcv 0 +: 4
        __opcode '00011110 xx1xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean signal_all_nans = (op == '1');
            bits(4) condition = cond;
            bits(4) flags = nzcv;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2;
        
        operand2 = V[m];
        
        if ConditionHolds(condition) then
            flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);
        PSTATE.<N,Z,C,V> = flags;

__instruction SQINCW_R.RS_SX
    __encoding SQINCW_R.RS_SX
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1010xxxx 111100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 32;

    __encoding SQINCW_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1011xxxx 111100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction RBIT_Z.P.Z__
    __encoding RBIT_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx100111 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = BitReverse(element);
        
        Z[d] = result;

__instruction UDIV_Z.P.ZZ__
    __encoding UDIV_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010101 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '0x' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer quotient;
                if element2 == 0 then
                    quotient = 0;
                else
                    quotient = RoundTowardsZero(Real(element1) / Real(element2));
                Elem[result, e, esize] = quotient<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction FMAXV_V.P.Z__
    __encoding FMAXV_V.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '01100101 xx000110 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);

    __execute
        CheckSVEEnabled();
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(esize) identity = FPInfinity('1');
        
        V[d] = ReducePredicated(ReduceOp_FMAX, operand, mask, identity);

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_float_convert_fix
    __encoding aarch64_float_convert_fix
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field scale 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            
            case type1 of
                when '00' fltsize = 32;
                when '01' fltsize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            if sf == '0' && scale<5> == '0' then UNDEFINED;
            integer fracbits = 64 - UInt(scale);
            
            case opcode<2:1>:rmode of
                when '00 11'        // FCVTZ
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                otherwise
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
                V[d] = fltval;

__instruction PTEST_.P.P__
    __encoding PTEST_.P.P__
        __instruction_set A64
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __opcode '00100101 01010000 11xxxx0x xxx00000'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);

    __execute
        CheckSVEEnabled();
        bits(PL) mask = P[g];
        bits(PL) result = P[n];
        
        PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);

__instruction LD4B_Z.P.BR_Contiguous
    __encoding LD4B_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 011xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction PRFD_I.P.BR_S
    __encoding PRFD_I.P.BR_S
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000101 100xxxxx 110xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) offset = X[m];
        bits(64) addr;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + (UInt(offset) << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);
            offset = offset + 1;

__instruction PRFD_I.P.AI_S
    __encoding PRFD_I.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000101 100xxxxx 111xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 3;
            integer offset = UInt(imm5);

    __encoding PRFD_I.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000101 100xxxxx 111xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 3;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) base;
        bits(64) addr;
        base = Z[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);

__instruction UDOT_Z.ZZZ__
    __encoding UDOT_Z.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01000100 xx0xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '0x' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) res = Elem[operand3, e, esize];
            for i = 0 to 3
                integer element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                integer element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);
                res = res + element1 * element2;
            Elem[result, e, esize] = res;
        
        Z[da] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_narrow
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_narrow
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 01x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean round = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand1 = V[n];
        bits(2*datasize) operand2 = V[m];
        bits(datasize)   result;
        integer round_const = if round then 1 << (esize - 1) else 0;
        bits(2*esize) element1;
        bits(2*esize) element2;
        bits(2*esize) sum;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, 2*esize];
            element2 = Elem[operand2, e, 2*esize];
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            sum = sum + round_const;
            Elem[result, e, esize] = sum<2*esize-1:esize>;
        
        Vpart[d, part] = result;

__instruction aarch64_integer_arithmetic_add_sub_immediate
    __encoding aarch64_integer_arithmetic_add_sub_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field sh 22 +: 1
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10001 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            bits(datasize) imm;
            
            case sh of
                when '0' imm = ZeroExtend(imm12, datasize);
                when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = if n == 31 then SP[] else X[n];
        bits(datasize) operand2 = imm;
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction LD1SW_Z.P.BI_S64
    __encoding LD1SW_Z.P.BI_S64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1000xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction MUL_Z.ZI__
    __encoding MUL_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx110000 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer imm = SInt(imm8);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = SInt(Elem[operand1, e, esize]);
            Elem[result, e, esize] = (element1 * imm)<esize-1:0>;
        
        Z[dn] = result;

__instruction SQADD_Z.ZZ__
    __encoding SQADD_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 000100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 + element2, esize, unsigned);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_long
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 xxxxxxxx 0x10x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean sub_op = (o2 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(idxdsize)   operand2 = V[m];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        
        element2 = Int(Elem[operand2, index, esize], unsigned);
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            product = (element1 * element2)<2*esize-1:0>;
            if sub_op then
                Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
            else
                Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;
        
        V[d] = result;

__instruction ORR_Z.ZI__
    __encoding ORR_Z.ZI__
        __instruction_set A64
        __field imm13 5 +: 13
        __field Zdn 0 +: 5
        __opcode '00000101 000000xx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer dn = UInt(Zdn);
            bits(64) imm;
            (imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV 64;
        bits(VL) operand = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(64) element1 = Elem[operand, e, 64];
            Elem[result, e, 64] = element1 OR imm;
        
        Z[dn] = result;

__instruction aarch64_integer_arithmetic_add_sub_extendedreg
    __encoding aarch64_integer_arithmetic_add_sub_extendedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field imm3 10 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01011 001xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            ExtendType extend_type = DecodeRegExtend(option);       
            integer shift = UInt(imm3);
            if shift > 4 then UNDEFINED;

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = if n == 31 then SP[] else X[n];
        bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_crypto_sha3op_sha256_sched1
    __encoding aarch64_vector_crypto_sha3op_sha256_sched1
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 000xxxxx 011000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if !HaveSHA256Ext() then UNDEFINED;

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) operand1 = V[d];
        bits(128) operand2 = V[n];
        bits(128) operand3 = V[m];
        bits(128) result;
        bits(128) T0 = operand3<31:0> : operand2<127:32>;
        bits(64) T1;
        bits(32) elt;
        
        T1 = operand3<127:64>;
        for e = 0 to 1
            elt = Elem[T1, e, 32];
            elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
            elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];
            Elem[result, e, 32] = elt;
        
        T1 = result<63:0>;
        for e = 2 to 3
            elt = Elem[T1, e - 2, 32];
            elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
            elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];
            Elem[result, e, 32] = elt;
        
        V[d] = result;

__instruction SQDECD_R.RS_SX
    __encoding SQDECD_R.RS_SX
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1110xxxx 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 32;

    __encoding SQDECD_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1111xxxx 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction aarch64_vector_arithmetic_unary_diff_neg_int_sisd
    __encoding aarch64_vector_arithmetic_unary_diff_neg_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100000 101110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean neg = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_diff_neg_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 101110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean neg = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element;
        
        for e = 0 to elements-1
            element = SInt(Elem[operand, e, esize]);
            if neg then
                element = -element;
            else
                element = Abs(element);
            Elem[result, e, esize] = element<esize-1:0>;                
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_float_round_frint_32_64
    __encoding aarch64_vector_arithmetic_unary_float_round_frint_32_64
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 0x100001 111x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFrintExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            integer intsize = if op == '0' then 32 else 64; 
            FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);
        
        V[d] = result;

__instruction BIC_Z.ZZ__
    __encoding BIC_Z.ZZ__
        __instruction_set A64
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 111xxxxx 001100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        
        Z[d] = operand1 AND (NOT operand2);

__instruction aarch64_vector_arithmetic_unary_special_sqrt_fp16
    __encoding aarch64_vector_arithmetic_unary_special_sqrt_fp16
        __instruction_set A64
        __field Q 30 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 11111001 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __encoding aarch64_vector_arithmetic_unary_special_sqrt
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 1x100001 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPSqrt(element, FPCR);
        
        V[d] = result;

__instruction aarch64_branch_conditional_test
    __encoding aarch64_branch_conditional_test
        __instruction_set A64
        __field b5 31 +: 1
        __field op 24 +: 1
        __field b40 19 +: 5
        __field imm14 5 +: 14
        __field Rt 0 +: 5
        __opcode 'x011011x xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            
            integer datasize = if b5 == '1' then 64 else 32;
            integer bit_pos = UInt(b5:b40);
            bit bit_val = op;
            bits(64) offset = SignExtend(imm14:'00', 64);

    __execute
        bits(datasize) operand = X[t];
        
        if operand<bit_pos> == bit_val then
            BranchTo(PC[] + offset, BranchType_DIR);

__instruction aarch64_float_arithmetic_mul_add_sub
    __encoding aarch64_float_arithmetic_mul_add_sub
        __instruction_set A64
        __field type1 22 +: 2
        __field o1 21 +: 1
        __field Rm 16 +: 5
        __field o0 15 +: 1
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011111 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer a = UInt(Ra);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean opa_neg = (o1 == '1');
            boolean op1_neg = (o0 != o1);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operanda = V[a];
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        if opa_neg then operanda = FPNeg(operanda);
        if op1_neg then operand1 = FPNeg(operand1);
        result = FPMulAdd(operanda, operand1, operand2, FPCR);
        
        V[d] = result;

__instruction ST1W_Z.P.AI_S
    __encoding ST1W_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 011xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            integer offset = UInt(imm5);

    __encoding ST1W_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 010xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(VL) src = Z[t];
        bits(PL) mask = P[g];
        bits(64) addr;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;

__instruction ST1W_Z.P.BR__
    __encoding ST1W_Z.P.BR__
        __instruction_set A64
        __field size 21 +: 2
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 0xxxxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size != '1x' then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8 << UInt(size);
            integer msize = 32;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        bits(VL) src = Z[t];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;
            offset = offset + 1;

__instruction LD1D_Z.P.BI_U64
    __encoding LD1D_Z.P.BI_U64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1110xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 001101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            if pair then
                element1 = Elem[concat, 2*e, esize];
                element2 = Elem[concat, (2*e)+1, esize];
            else
                element1 = Elem[operand1, e, esize];
                element2 = Elem[operand2, e, esize];
        
            if minimum then
                Elem[result, e, esize] = FPMin(element1, element2, FPCR);
            else
                Elem[result, e, esize] = FPMax(element1, element2, FPCR);
        
        V[d] = result;

__instruction aarch64_vector_transfer_vector_permute_transpose
    __encoding aarch64_vector_transfer_vector_permute_transpose
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field op 14 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx0xxxxx 0x1010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            integer part = UInt(op);
            integer pairs = elements DIV 2;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        for p = 0 to pairs-1
            Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];
            Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];
        
        V[d] = result;

__instruction INCB_R.RS__
    __encoding INCB_R.RS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0011xxxx 111000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding INCD_R.RS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1111xxxx 111000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding INCH_R.RS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0111xxxx 111000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding INCW_R.RS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1011xxxx 111000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(64) operand1 = X[dn];
        
        X[dn] = operand1 + (count * imm);

__instruction LDFF1SH_Z.P.AI_S
    __encoding LDFF1SH_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 101xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = FALSE;
            integer offset = UInt(imm5);

    __encoding LDFF1SH_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 101xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = FALSE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction LDFF1SH_Z.P.BR_S32
    __encoding LDFF1SH_Z.P.BR_S32
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 001xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = FALSE;

    __encoding LDFF1SH_Z.P.BR_S64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 000xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + UInt(offset) * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            offset = offset + 1;
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_int
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_int
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 xxxxxxxx 0x00x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o2 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        integer element1;
        integer element2;
        bits(esize) product;
        
        element2 = UInt(Elem[operand2, index, esize]);
        for e = 0 to elements-1
            element1 = UInt(Elem[operand1, e, esize]);
            product = (element1 * element2)<esize-1:0>;
            if sub_op then
                Elem[result, e, esize] = Elem[operand3, e, esize] - product;
            else
                Elem[result, e, esize] = Elem[operand3, e, esize] + product;
        V[d] = result;

__instruction PRFW_I.P.BR_S
    __encoding PRFW_I.P.BR_S
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000101 000xxxxx 110xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) offset = X[m];
        bits(64) addr;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + (UInt(offset) << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);
            offset = offset + 1;

__instruction PRFW_I.P.AI_S
    __encoding PRFW_I.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000101 000xxxxx 111xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 2;
            integer offset = UInt(imm5);

    __encoding PRFW_I.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000101 000xxxxx 111xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 2;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) base;
        bits(64) addr;
        base = Z[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);

__instruction aarch64_vector_crypto_sm3_sm3tt2a
    __encoding aarch64_vector_crypto_sm3_sm3tt2a
        __instruction_set A64
        __field Rm 16 +: 5
        __field imm2 12 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 010xxxxx 10xx10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSM3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer i = UInt(imm2);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        bits(128) Vd = V[d];
        bits(32) Wj;
        bits(128) result; 
        bits(32) TT1;
        
        Wj = Elem[Vm,i,32];
        TT2 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);
        TT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>;
        
        result<31:0> = Vd<63:32>;
        result<63:32> = ROL(Vd<95:64>,19); 
        result<95:64> = Vd<127:96>; 
        result<127:96> = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); 
        V[d] = result;

__instruction aarch64_system_register_cpsr
    __encoding aarch64_system_register_cpsr
        __instruction_set A64
        __field op1 16 +: 3
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000xxx 0100xxxx xxx11111'
        __guard TRUE
        __decode
            if op1 == '000' && op2 == '000' then SEE "CFINV";
            if op1 == '000' && op2 == '001' then SEE "XAFlag";
            if op1 == '000' && op2 == '010' then SEE "AXFlag";
            
            AArch64.CheckSystemAccess('00', op1, '0100', CRm, op2, '11111', '0');
            
            bits(4) operand = CRm;
            PSTATEField field;
            case op1:op2 of
                when '000 011' 
                    if !HaveUAOExt() then
                        UNDEFINED;
                    field = PSTATEField_UAO;
                when '000 100' 
                    if !HavePANExt() then
                        UNDEFINED;
                    field = PSTATEField_PAN;
                when '000 101' field = PSTATEField_SP;
                when '011 010' 
                    if !HaveDITExt() then
                        UNDEFINED;
                    field = PSTATEField_DIT;
                when '011 110' field = PSTATEField_DAIFSet;
                when '011 111' field = PSTATEField_DAIFClr;
                when '011 001' 
                    if !HaveSSBSExt() then
                        UNDEFINED;
                    field = PSTATEField_SSBS;
                otherwise      UNDEFINED;
            
            // Check that an AArch64 MSR/MRS access to the DAIF flags is permitted
            if op1 == '011' && PSTATE.EL == EL0 && (IsInHost() || SCTLR_EL1.UMA == '0') then
                AArch64.SystemAccessTrap(EL1, 0x18);    // Exception_SystemRegisterTrap

    __execute
        case field of
            when PSTATEField_SSBS    
                PSTATE.SSBS = operand<0>;
            when PSTATEField_SP    
                PSTATE.SP = operand<0>;
            when PSTATEField_DAIFSet
                PSTATE.D = PSTATE.D OR operand<3>;
                PSTATE.A = PSTATE.A OR operand<2>;
                PSTATE.I = PSTATE.I OR operand<1>;
                PSTATE.F = PSTATE.F OR operand<0>;
            when PSTATEField_DAIFClr
                PSTATE.D = PSTATE.D AND NOT(operand<3>);
                PSTATE.A = PSTATE.A AND NOT(operand<2>);
                PSTATE.I = PSTATE.I AND NOT(operand<1>);
                PSTATE.F = PSTATE.F AND NOT(operand<0>);
            when PSTATEField_PAN
                PSTATE.PAN = operand<0>;
            when PSTATEField_UAO
                PSTATE.UAO = operand<0>;
            when PSTATEField_DIT
                PSTATE.DIT = operand<0>;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field S 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 1xxxxxxx 0x00x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
            if sz == '1' then UNDEFINED;
            integer index = UInt(H:L:M); 
            
            integer esize = 32;
            integer datasize = if Q=='1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (S == '1');
            integer part = 0;

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field S 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 1xxxxxxx 1x00x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
            if sz == '1' then UNDEFINED;
            integer index = UInt(H:L:M); 
            
            integer esize = 32;
            integer datasize = if Q=='1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (S == '1');
            integer part = 1;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize DIV 2) operand1 = Vpart[n,part];
        bits(128) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize DIV 2) element1;
        bits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2];
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize DIV 2];
            if sub_op then element1 = FPNeg(element1);
            Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_diff
    __encoding aarch64_vector_arithmetic_binary_uniform_diff
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0111x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean accumulate = (ac == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        bits(esize) absdiff;
        
        result = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            absdiff = Abs(element1 - element2)<esize-1:0>;
            Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
    __encoding aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
        __instruction_set A64
        __field Q 30 +: 1
        __field opc2 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx1xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            VBitOp op;
            
            case opc2 of
                when '00' op = VBitOp_VEOR;
                when '01' op = VBitOp_VBSL;
                when '10' op = VBitOp_VBIT;
                when '11' op = VBitOp_VBIF;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1;
        bits(datasize) operand2;
        bits(datasize) operand3;
        bits(datasize) operand4 = V[n];
        
        case op of
            when VBitOp_VEOR
                operand1 = V[m];
                operand2 = Zeros();
                operand3 = Ones();
            when VBitOp_VBSL
                operand1 = V[m];
                operand2 = operand1;
                operand3 = V[d];
            when VBitOp_VBIT
                operand1 = V[d];
                operand2 = operand1;
                operand3 = V[m];
            when VBitOp_VBIF
                operand1 = V[d];
                operand2 = operand1;
                operand3 = NOT(V[m]);
        
        V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction ST3B_Z.P.BR_Contiguous
    __encoding ST3B_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 010xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction aarch64_branch_unconditional_eret
    __encoding aarch64_branch_unconditional_eret
        __instruction_set A64
        __field A 11 +: 1
        __field M 10 +: 1
        __field Rn 5 +: 5
        __field op4 0 +: 5
        __opcode '11010110 10011111 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if PSTATE.EL == EL0 then UNDEFINED;
            boolean pac = (A == '1');
            boolean use_key_a = (M == '0');
            
            if !pac && op4 != '00000' then
                UNDEFINED;
            elsif pac && (!HavePACExt() || op4 != '11111') then
                UNDEFINED;
            
            if Rn != '11111' then 
                UNDEFINED;

    __execute
        AArch64.CheckForERetTrap(pac, use_key_a);
        bits(64) target = ELR[];
        
        if pac then
            if use_key_a then
                target = AuthIA(ELR[], SP[]);
            else
                target = AuthIB(ELR[], SP[]);
        
        AArch64.ExceptionReturn(target, SPSR[]);

__instruction aarch64_float_arithmetic_unary
    __encoding aarch64_float_arithmetic_unary
        __instruction_set A64
        __field type1 22 +: 2
        __field opc 15 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx10000x x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            FPUnaryOp fpop;
            case opc of
                when '00' fpop = FPUnaryOp_MOV;
                when '01' fpop = FPUnaryOp_ABS;
                when '10' fpop = FPUnaryOp_NEG;
                when '11' fpop = FPUnaryOp_SQRT;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        case fpop of
            when FPUnaryOp_MOV  result = operand;
            when FPUnaryOp_ABS  result = FPAbs(operand);
            when FPUnaryOp_NEG  result = FPNeg(operand);
            when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);
        
        V[d] = result;

__instruction UXTB_Z.P.Z__
    __encoding UXTB_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx010001 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer s_esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean unsigned = TRUE;

    __encoding UXTH_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx010011 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size != '1x' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer s_esize = 16;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean unsigned = TRUE;

    __encoding UXTW_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx010101 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer s_esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Extend(element<s_esize-1:0>, esize, unsigned);
        
        Z[d] = result;

__instruction INSR_Z.R__
    __encoding INSR_Z.R__
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000101 xx100100 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer m = UInt(Rm);

    __execute
        CheckSVEEnabled();
        bits(VL) dest = Z[dn];
        bits(esize) src = X[m];
        Z[dn] = dest<VL-esize-1:0> : src;

__instruction aarch64_integer_arithmetic_add_sub_shiftedreg
    __encoding aarch64_integer_arithmetic_add_sub_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field shift 22 +: 2
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01011 xx0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            
            if shift == '11' then UNDEFINED;
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        X[d] = result;

__instruction ST4B_Z.P.BI_Contiguous
    __encoding ST4B_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 0111xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer offset = SInt(imm4);
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction PRFB_I.P.BZ_S.x32.scaled
    __encoding PRFB_I.P.BZ_S.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000100 0x1xxxxx 000xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 32;
            boolean offs_unsigned = (xs == '0');
            integer scale = 0;

    __encoding PRFB_I.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000100 0x1xxxxx 000xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 32;
            boolean offs_unsigned = (xs == '0');
            integer scale = 0;

    __encoding PRFB_I.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000100 011xxxxx 100xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);

__instruction aarch64_vector_shift_right_narrow_uniform_sisd
    __encoding aarch64_vector_shift_right_narrow_uniform_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 1001x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then UNDEFINED;
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_shift_right_narrow_uniform_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 1001x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize*2) operand = V[n];
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
            (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
            if sat then FPSR.QC = '1';
        
        Vpart[d, part] = result;

__instruction aarch64_vector_shift_right_sisd
    __encoding aarch64_vector_shift_right_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __encoding aarch64_vector_shift_right_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) operand2;
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        
        operand2 = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
            Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_vector_transfer_vector_extract
    __encoding aarch64_vector_transfer_vector_extract
        __instruction_set A64
        __field Q 30 +: 1
        __field Rm 16 +: 5
        __field imm4 11 +: 4
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 000xxxxx 0xxxx0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if Q == '0' && imm4<3> == '1' then UNDEFINED;
            
            integer datasize = if Q == '1' then 128 else 64;
            integer position = UInt(imm4) << 3;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) hi = V[m];
        bits(datasize) lo = V[n];
        bits(datasize*2) concat = hi : lo;
        
        V[d] = concat<position+datasize-1:position>;

__instruction UUNPKHI_Z.Z__
    __encoding UUNPKHI_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx110011 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean unsigned = TRUE;
            boolean hi = TRUE;

    __encoding UUNPKLO_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx110010 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean unsigned = TRUE;
            boolean hi = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer hsize = esize DIV 2;
        bits(VL) operand = Z[n];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(hsize) element = if hi then Elem[operand, e + elements, hsize] else Elem[operand, e, hsize];
            Elem[result, e, esize] = Extend(element, esize, unsigned);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field rot 11 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx0xxxxx 110xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFCADDExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '00' then UNDEFINED;
            if Q == '0' && size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            if !HaveFP16Ext() && esize == 16 then UNDEFINED;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        bits(esize) element3;
        bits(esize) element4;
        
        for e = 0 to (elements DIV 2) -1 
            case rot of 
                when '00'
                    element1 = Elem[operand2, e*2, esize]; 
                    element2 = Elem[operand1, e*2, esize];
                    element3 = Elem[operand2, e*2+1, esize];
                    element4 = Elem[operand1, e*2, esize];
                when '01'
                    element1 = FPNeg(Elem[operand2, e*2+1, esize]); 
                    element2 = Elem[operand1, e*2+1, esize];
                    element3 = Elem[operand2, e*2, esize];
                    element4 = Elem[operand1, e*2+1, esize];
                when '10'
                    element1 = FPNeg(Elem[operand2, e*2, esize]); 
                    element2 = Elem[operand1, e*2, esize];
                    element3 = FPNeg(Elem[operand2, e*2+1, esize]);
                    element4 = Elem[operand1, e*2, esize];
                when '11'
                    element1 = Elem[operand2, e*2+1, esize]; 
                    element2 = Elem[operand1, e*2+1, esize];
                    element3 = FPNeg(Elem[operand2, e*2, esize]);
                    element4 = Elem[operand1, e*2+1, esize];
        
            Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2,   esize], element2, element1, FPCR);
            Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);
        
        V[d] = result;

__instruction LDR_Z.BI__
    __encoding LDR_Z.BI__
        __instruction_set A64
        __field imm9h 16 +: 6
        __field imm9l 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 10xxxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer imm = SInt(imm9h:imm9l);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV 8;
        bits(64) base;
        integer offset = imm * elements;
        bits(VL) result;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        boolean aligned = AArch64.CheckAlignment(base + offset, 16, AccType_NORMAL, FALSE);
        for e = 0 to elements-1
            Elem[result, e, 8] = AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned];
            offset = offset + 1;
        
        Z[t] = result;

__instruction aarch64_memory_single_simdfp_immediate_signed_post_idx
    __encoding aarch64_memory_single_simdfp_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111100 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(opc<1>:size);
            if scale > 4 then UNDEFINED;
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_simdfp_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111100 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(opc<1>:size);
            if scale > 4 then UNDEFINED;
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_simdfp_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111101 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(opc<1>:size);
            if scale > 4 then UNDEFINED;
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_VEC;
        MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        bits(64) address;
        bits(datasize) data;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                data = V[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                V[t] = data;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction UQADD_Z.ZI__
    __encoding UQADD_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field sh 13 +: 1
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx100101 11xxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size:sh == '001' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer imm = UInt(imm8);
            if sh == '1' then imm = imm << 8;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 + imm, esize, unsigned);
        
        Z[dn] = result;

__instruction ORN_P.P.PP_Z
    __encoding ORN_P.P.PP_Z
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 1000xxxx 01xxxx0x xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = FALSE;

    __encoding ORNS_P.P.PP_Z
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 1100xxxx 01xxxx0x xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            bit element1 = ElemP[operand1, e, esize];
            bit element2 = ElemP[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                ElemP[result, e, esize] = element1 OR (NOT element2);
            else
                ElemP[result, e, esize] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_post_idx
    __encoding aarch64_memory_single_general_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111001 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction SQINCP_Z.P.Z__
    __encoding SQINCP_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Zdn 0 +: 5
        __opcode '00100101 xx101000 1000000x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[dn];
        bits(VL) result;
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        for e = 0 to elements-1
            integer element = Int(Elem[operand, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element + count, esize, unsigned);
        
        Z[dn] = result;

__instruction CLASTB_Z.P.ZZ__
    __encoding CLASTB_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000101 xx101001 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean isBefore = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        integer last = LastActiveElement(mask, esize);
        
        if last < 0 then
            result = operand1;
        else
            if !isBefore then
                last = last + 1;
                if last >= elements then last = 0;
            for e = 0 to elements-1
                Elem[result, e, esize] = Elem[operand2, last, esize];
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_unary_float_round_frint_32_64
    __encoding aarch64_vector_arithmetic_unary_float_round_frint_32_64
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 0x100001 111x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFrintExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            integer intsize = if op == '0' then 32 else 64; 
            FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);
        
        V[d] = result;

__instruction LDFF1H_Z.P.BR_U16
    __encoding LDFF1H_Z.P.BR_U16
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 101xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 16;
            boolean unsigned = TRUE;

    __encoding LDFF1H_Z.P.BR_U32
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 110xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = TRUE;

    __encoding LDFF1H_Z.P.BR_U64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 111xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + UInt(offset) * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            offset = offset + 1;
        
        Z[t] = result;

__instruction aarch64_integer_arithmetic_mul_widening_32_64
    __encoding aarch64_integer_arithmetic_mul_widening_32_64
        __instruction_set A64
        __field U 23 +: 1
        __field Rm 16 +: 5
        __field o0 15 +: 1
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '10011011 x01xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer a = UInt(Ra);
            integer destsize = 64;
            integer datasize = 32;
            boolean sub_op = (o0 == '1');
            boolean unsigned = (U == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(destsize) operand3 = X[a];
        
        integer result;
        
        if sub_op then
            result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));
        else
            result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));
        
        X[d] = result<63:0>;

__instruction LDFF1H_Z.P.AI_S
    __encoding LDFF1H_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 101xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __encoding LDFF1H_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 101xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction LD1RH_Z.P.BI_U16
    __encoding LD1RH_Z.P.BI_U16
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 11xxxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = UInt(imm6);

    __encoding LD1RH_Z.P.BI_U32
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 11xxxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = UInt(imm6);

    __encoding LD1RH_Z.P.BI_U64
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 11xxxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = UInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        integer last = LastActiveElement(mask, esize);
        if last >= 0 then
            addr = base + offset * mbytes;
            data = Mem[addr, mbytes, AccType_NORMAL];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction FMLS_Z.P.ZZZ__
    __encoding FMLS_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100101 xx1xxxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean op1_neg = TRUE;
            boolean op3_neg = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            bits(esize) element3 = Elem[operand3, e, esize];
            
            if ElemP[mask, e, esize] == '1' then
                if op1_neg then element1 = FPNeg(element1);
                if op3_neg then element3 = FPNeg(element3);
                Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
            else
                Elem[result, e, esize] = element3;
        
        Z[da] = result;

__instruction MOVPRFX_Z.Z__
    __encoding MOVPRFX_Z.Z__
        __instruction_set A64
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 00100000 101111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        bits(VL) result = Z[n];
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx0xxxxx 100101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveDOTPExt() then UNDEFINED;
            if size!= '10' then UNDEFINED;
            boolean signed = (U=='0');
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        result = V[d];
        for e = 0 to elements-1 
            integer res = 0;
            integer element1, element2;
            for i = 0 to 3 
                if signed then
                    element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
                    element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);
                else 
                    element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
                    element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);
                res = res + element1 * element2; 
            Elem[result, e, esize] = Elem[result, e, esize] + res;
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_element_dotp
    __encoding aarch64_vector_arithmetic_binary_element_dotp
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 xxxxxxxx 1110x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveDOTPExt() then UNDEFINED;
            if size  != '10' then UNDEFINED;
            boolean signed = (U=='0');
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(M:Rm);
            integer index = UInt(H:L);
            
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(128) operand2 = V[m];
        bits(datasize) result = V[d];
        for e = 0 to elements-1 
            integer res = 0;
            integer element1, element2;
            for i = 0 to 3
                if signed then  
                    element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
                    element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);
                else 
                    element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
                    element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);
                res = res + element1 * element2; 
            Elem[result, e, esize] = Elem[result, e, esize] + res;
        V[d] = result;

__instruction aarch64_system_barriers
    __encoding aarch64_system_barriers
        __instruction_set A64
        __field CRm 8 +: 4
        __field opc 5 +: 2
        __opcode '11010101 00000011 0011xxxx 1xx11111'
        __guard TRUE
        __decode
            MemBarrierOp op;
            MBReqDomain domain;
            MBReqTypes types;
            
            case opc of
                when '00' op = MemBarrierOp_DSB;
                when '01' op = MemBarrierOp_DMB;
                when '10' op = MemBarrierOp_ISB;
                otherwise 
                    if HaveSBExt() && CRm<3:0> == '0000' then 
                        op = MemBarrierOp_SB;
                    else
                        UNDEFINED;
            
            case CRm<3:2> of
                when '00' domain = MBReqDomain_OuterShareable;
                when '01' domain = MBReqDomain_Nonshareable;
                when '10' domain = MBReqDomain_InnerShareable;
                when '11' domain = MBReqDomain_FullSystem;
            
            case CRm<1:0> of
                when '01' types = MBReqTypes_Reads;
                when '10' types = MBReqTypes_Writes;
                when '11' types = MBReqTypes_All;
                otherwise
                    if CRm<3:2> == '01' then
                        op = MemBarrierOp_PSSBB;
                    elsif CRm<3:2> == '00' && opc == '00' then 
                        op = MemBarrierOp_SSBB;
                    elsif HaveSBExt() && CRm<3:2> == '00' && opc == '11' then 
                        op = MemBarrierOp_SB;
                    else
                        types  = MBReqTypes_All;
                        domain = MBReqDomain_FullSystem;

    __execute
        case op of
            when MemBarrierOp_DSB
                DataSynchronizationBarrier(domain, types);
            when MemBarrierOp_DMB
                DataMemoryBarrier(domain, types);
            when MemBarrierOp_ISB
                InstructionSynchronizationBarrier();
            when MemBarrierOp_SSBB
                SpeculativeStoreBypassBarrierToVA();
            when MemBarrierOp_PSSBB
                SpeculativeStoreBypassBarrierToPA();
            when MemBarrierOp_SB
                SpeculationBarrier();

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_transfer_vector_permute_zip
    __encoding aarch64_vector_transfer_vector_permute_zip
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field op 14 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx0xxxxx 0x1110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            integer part = UInt(op);
            integer pairs = elements DIV 2;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        integer base = part * pairs;
        
        for p = 0 to pairs-1
            Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];
            Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];
        
        V[d] = result;

__instruction aarch64_integer_shift_variable
    __encoding aarch64_integer_shift_variable
        __instruction_set A64
        __field sf 31 +: 1
        __field Rm 16 +: 5
        __field op2 10 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011010 110xxxxx 0010xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            ShiftType shift_type = DecodeShift(op2);

    __execute
        bits(datasize) result;
        bits(datasize) operand2 = X[m];
        
        result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
        X[d] = result;

__instruction LD1RSH_Z.P.BI_S32
    __encoding LD1RSH_Z.P.BI_S32
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 01xxxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = FALSE;
            integer offset = UInt(imm6);

    __encoding LD1RSH_Z.P.BI_S64
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 01xxxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = FALSE;
            integer offset = UInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        integer last = LastActiveElement(mask, esize);
        if last >= 0 then
            addr = base + offset * mbytes;
            data = Mem[addr, mbytes, AccType_NORMAL];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction UDOT_Z.ZZZi_S
    __encoding UDOT_Z.ZZZi_S
        __instruction_set A64
        __field i2 19 +: 2
        __field Zm 16 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01000100 101xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer index = UInt(i2);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);

    __encoding UDOT_Z.ZZZi_D
        __instruction_set A64
        __field i1 20 +: 1
        __field Zm 16 +: 4
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01000100 111xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer index = UInt(i1);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer eltspersegment = 128 DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer segmentbase = e - e MOD eltspersegment;
            integer s = segmentbase + index;
            bits(esize) res = Elem[operand3, e, esize];
            for i = 0 to 3
                integer element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                integer element2 = UInt(Elem[operand2, 4 * s + i, esize DIV 4]);
                res = res + element1 * element2;
            Elem[result, e, esize] = res;
        
        Z[da] = result;

__instruction aarch64_vector_crypto_sm3_sm3partw1
    __encoding aarch64_vector_crypto_sm3_sm3partw1
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 011xxxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSM3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        bits(128) Vd = V[d];
        bits(128) result; 
        
        result<95:0> = (Vd EOR Vn)<95:0> EOR (ROL(Vm<127:96>,15):ROL(Vm<95:64>,15):ROL(Vm<63:32>,15));
        
        for i = 0 to 3
            if i == 3 then 
                result<127:96> = (Vd EOR Vn)<127:96> EOR (ROL(result<31:0>,15));
            result<(32*i)+31:(32*i)> = result<(32*i)+31:(32*i)> EOR ROL(result<(32*i)+31:(32*i)>,15) EOR ROL(result<(32*i)+31:(32*i)>,23);
        V[d] = result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction ST1B_Z.P.BZ_D.x32.unscaled
    __encoding ST1B_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 000xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding ST1B_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 010xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding ST1B_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 000xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(VL) offset = Z[m];
        bits(VL) src = Z[t];
        bits(PL) mask = P[g];
        bits(64) addr;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;

__instruction aarch64_integer_arithmetic_mul_widening_64_128hi
    __encoding aarch64_integer_arithmetic_mul_widening_64_128hi
        __instruction_set A64
        __field U 23 +: 1
        __field Rm 16 +: 5
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '10011011 x10xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer a = UInt(Ra);           // ignored by UMULH/SMULH
            integer destsize = 64;
            integer datasize = destsize;
            boolean unsigned = (U == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        
        integer result;
        
        result = Int(operand1, unsigned) * Int(operand2, unsigned);
        
        X[d] = result<127:64>;

__instruction aarch64_udf
    __encoding aarch64_udf
        __instruction_set A64
        __field imm16 0 +: 16
        __opcode '00000000 00000000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            // The imm16 field is ignored by hardware.
            UNDEFINED;

    __execute
        // No operation.

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_single
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_single
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer maxmin;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
            Elem[result, e, esize] = maxmin<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_post_idx
    __encoding aarch64_memory_single_general_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111001 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction ZIP2_P.PP__
    __encoding ZIP2_P.PP__
        __instruction_set A64
        __field size 22 +: 2
        __field Pm 16 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00000101 xx10xxxx 0100010x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            integer part = 1;

    __encoding ZIP1_P.PP__
        __instruction_set A64
        __field size 22 +: 2
        __field Pm 16 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00000101 xx10xxxx 0100000x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            integer part = 0;

    __execute
        CheckSVEEnabled();
        integer pairs = VL DIV (esize * 2);
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        integer base = part * pairs;
        for p = 0 to pairs-1
            Elem[result, 2*p+0, esize DIV 8] = Elem[operand1, base+p, esize DIV 8];
            Elem[result, 2*p+1, esize DIV 8] = Elem[operand2, base+p, esize DIV 8];
        
        P[d] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
        __instruction_set A64
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011111 00xxxxxx 0x01x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64;
            integer index;
            index = UInt(H:L:M);
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            boolean sub_op = (o2 == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011111 1xxxxxxx 0x01x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi = M;
            case sz:L of
                when '0x' index = UInt(H:L);
                when '10' index = UInt(H);
                when '11' UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            boolean sub_op = (o2 == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 00xxxxxx 0x01x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64;
            integer index;
            index = UInt(H:L:M);
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean sub_op = (o2 == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 1xxxxxxx 0x01x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi = M;
            case sz:L of
                when '0x' index = UInt(H:L);
                when '10' index = UInt(H);
                when '11' UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean sub_op = (o2 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2 = Elem[operand2, index, esize];
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            if sub_op then element1 = FPNeg(element1);
            Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
        V[d] = result;

__instruction aarch64_integer_bitfield
    __encoding aarch64_integer_bitfield
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field N 22 +: 1
        __field immr 16 +: 6
        __field imms 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10011 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            
            boolean inzero;
            boolean extend;
            integer R;
            integer S;
            bits(datasize) wmask;
            bits(datasize) tmask;
            
            case opc of
                when '00' inzero = TRUE;  extend = TRUE;    // SBFM
                when '01' inzero = FALSE; extend = FALSE;   // BFM
                when '10' inzero = TRUE;  extend = FALSE;   // UBFM
                when '11' UNDEFINED;
            
            if sf == '1' && N != '1' then UNDEFINED;
            if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;
            
            R = UInt(immr);
            S = UInt(imms);
            (wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);

    __execute
        bits(datasize) dst = if inzero then Zeros() else X[d];
        bits(datasize) src = X[n];
        
        // perform bitfield move on low bits
        bits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);
        
        // determine extension bits (sign, zero or dest register)
        bits(datasize) top = if extend then Replicate(src<S>) else dst;
        
        // combine extension bits and result bits
        X[d] = (top AND NOT(tmask)) OR (bot AND tmask);

__instruction FMUL_Z.ZZi_H
    __encoding FMUL_Z.ZZi_H
        __instruction_set A64
        __field i3h 22 +: 1
        __field i3l 19 +: 2
        __field Zm 16 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100100 0x1xxxxx 001000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer index = UInt(i3h:i3l);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __encoding FMUL_Z.ZZi_S
        __instruction_set A64
        __field i2 19 +: 2
        __field Zm 16 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100100 101xxxxx 001000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer index = UInt(i2);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __encoding FMUL_Z.ZZi_D
        __instruction_set A64
        __field i1 20 +: 1
        __field Zm 16 +: 4
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100100 111xxxxx 001000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer index = UInt(i1);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer eltspersegment = 128 DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer segmentbase = e - e MOD eltspersegment;
            integer s = segmentbase + index;
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, s, esize];
            Elem[result, e, esize] = FPMul(element1, element2, FPCR);
        
        Z[d] = result;

__instruction MOVPRFX_Z.P.Z__
    __encoding MOVPRFX_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field M 16 +: 1
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx01000x 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean merging = (M == '1');

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) dest = Z[d];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = element;
            elsif merging then
                Elem[result, e, esize] = Elem[dest, e, esize];
            else
                Elem[result, e, esize] = Zeros();
        
        Z[d] = result;

__instruction FMSB_Z.P.ZZZ__
    __encoding FMSB_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Za 16 +: 5
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx1xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            integer a = UInt(Za);
            boolean op1_neg = TRUE;
            boolean op3_neg = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[a];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            bits(esize) element3 = Elem[operand3, e, esize];
            
            if ElemP[mask, e, esize] == '1' then
                if op1_neg then element1 = FPNeg(element1);
                if op3_neg then element3 = FPNeg(element3);
                Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction FMINNM_Z.P.ZZ__
    __encoding FMINNM_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx000101 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_integer_arithmetic_rev
    __encoding aarch64_integer_arithmetic_rev
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 10 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x1011010 11000000 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize = if sf == '1' then 64 else 32;
            
            integer container_size;
            case opc of
                when '00'
                    Unreachable();
                when '01'
                    container_size = 16;
                when '10'
                    container_size = 32;
                when '11'
                    if sf == '0' then UNDEFINED;
                    container_size = 64;

    __execute
        bits(datasize) operand = X[n];
        bits(datasize) result;
        
        integer containers = datasize DIV container_size;
        integer elements_per_container = container_size DIV 8;
        integer index = 0;
        integer rev_index;
        for c = 0 to containers-1
            rev_index = index + ((elements_per_container - 1) * 8);
            for e = 0 to elements_per_container-1
                result<rev_index + 7:rev_index> = operand<index + 7:index>;
                index = index + 8;
                rev_index = rev_index - 8;
        
        X[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_logical_and_orr
    __encoding aarch64_vector_arithmetic_binary_uniform_logical_and_orr
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean invert = (size<0> == '1');
            LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND
                result = operand1 AND operand2;
            when LogicalOp_ORR
                result = operand1 OR operand2;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_mul_accum
    __encoding aarch64_vector_arithmetic_binary_disparate_mul_accum
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 10x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        bits(2*esize) accum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            product = (element1 * element2)<2*esize-1:0>;
            if sub_op then
                accum = Elem[operand3, e, 2*esize] - product;
            else
                accum = Elem[operand3, e, 2*esize] + product;
            Elem[result, e, 2*esize] = accum;
        
        V[d] = result;

__instruction aarch64_memory_vector_multiple_no_wb
    __encoding aarch64_memory_vector_multiple_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 0x000000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_multiple_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field Rm 16 +: 5
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << UInt(size);
        integer elements = datasize DIV esize;
        
        integer rpt;    // number of iterations
        integer selem;  // structure elements 
        
        case opcode of
            when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
            when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
            when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
            when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
            when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
            when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
            when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
            otherwise UNDEFINED;
        
        // .1D format only permitted with LD1 & ST1
        if size:Q == '110' && selem != 1 then UNDEFINED;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(datasize) rval;
        integer tt;
        constant integer ebytes = esize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        for r = 0 to rpt-1
            for e = 0 to elements-1
                tt = (t + r) MOD 32;
                for s = 0 to selem-1
                    rval = V[tt];
                    if memop == MemOp_LOAD then
                        Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                        V[tt] = rval;
                    else // memop == MemOp_STORE
                        Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                    offs = offs + ebytes;
                    tt = (tt + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_wide
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_wide
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 00x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand1 = V[n];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        integer sum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, 2*esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            Elem[result, e, 2*esize] = sum<2*esize-1:0>;
        
        V[d] = result;

__instruction aarch64_vector_shift_left_sat_sisd
    __encoding aarch64_vector_shift_left_sat_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 011x01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = UInt(immh:immb) - esize;
            
            boolean src_unsigned;
            boolean dst_unsigned;
            case op:U of
                when '00' UNDEFINED;
                when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

    __encoding aarch64_vector_shift_left_sat_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 011x01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = UInt(immh:immb) - esize;
            
            boolean src_unsigned;
            boolean dst_unsigned;
            case op:U of
                when '00' UNDEFINED;
                when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) result;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = Int(Elem[operand, e, esize], src_unsigned) << shift;
            (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction UQINCH_R.RS_UW
    __encoding UQINCH_R.RS_UW
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0110xxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 32;

    __encoding UQINCH_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0111xxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction LD1D_Z.P.AI_D
    __encoding LD1D_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 101xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction LD1D_Z.P.BR_U64
    __encoding LD1D_Z.P.BR_U64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 111xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_long
    __encoding aarch64_vector_arithmetic_binary_element_mul_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 xxxxxxxx 1010x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(idxdsize)   operand2 = V[m];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        
        element2 = Int(Elem[operand2, index, esize], unsigned);
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            product = (element1 * element2)<2*esize-1:0>;
            Elem[result, e, 2*esize] = product;
        
        V[d] = result;

__instruction aarch64_vector_shift_conv_float_sisd
    __encoding aarch64_vector_shift_conv_float_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
            integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
            integer datasize = esize;
            integer elements = 1;
            
            integer fracbits = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            FPRounding rounding = FPRounding_ZERO;

    __encoding aarch64_vector_shift_conv_float_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer fracbits = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            FPRounding rounding = FPRounding_ZERO;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_div_fp16
    __encoding aarch64_vector_arithmetic_binary_uniform_div_fp16
        __instruction_set A64
        __field Q 30 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 010xxxxx 001111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __encoding aarch64_vector_arithmetic_binary_uniform_div
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 0x1xxxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPDiv(element1, element2, FPCR);
        
        V[d] = result;

__instruction ST1W_Z.P.BI__
    __encoding ST1W_Z.P.BI__
        __instruction_set A64
        __field size 21 +: 2
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 0xx0xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size != '1x' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8 << UInt(size);
            integer msize = 32;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) src = Z[t];
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;
            addr = addr + mbytes;

__instruction PRFW_I.P.BI_S
    __encoding PRFW_I.P.BI_S
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000101 11xxxxxx 010xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 2;
            integer offset = SInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) addr;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        
        addr = base + ((offset * elements) << scale);
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Hint_Prefetch(addr, pref_hint, level, stream);
            addr = addr + (1 << scale);

__instruction aarch64_memory_single_general_immediate_signed_offset_unpriv
    __encoding aarch64_memory_single_general_immediate_signed_offset_unpriv
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        
        unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
        unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
        
        user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
        if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
            acctype = AccType_UNPRIV;
        else
            acctype = AccType_NORMAL;
        
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction LDNF1W_Z.P.BI_U32
    __encoding LDNF1W_Z.P.BI_U32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0101xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LDNF1W_Z.P.BI_U64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0111xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                // MemNF[] will return fault=TRUE if access is not performed for any reason
                (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction CLZ_Z.P.Z__
    __encoding CLZ_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx011001 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = CountLeadingZeroBits(element)<esize-1:0>;
        
        Z[d] = result;

__instruction FMAXNM_Z.P.ZZ__
    __encoding FMAXNM_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx000100 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 010xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 0x1xxxxx 110111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 010xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 0x1xxxxx 110111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
        V[d] = result;

__instruction FMAX_Z.P.ZS__
    __encoding FMAX_Z.P.ZS__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field i1 5 +: 1
        __field Zdn 0 +: 5
        __opcode '01100101 xx011110 100xxx00 00xxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMax(element1, imm, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction ST3B_Z.P.BI_Contiguous
    __encoding ST3B_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 0101xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer offset = SInt(imm4);
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction aarch64_branch_unconditional_register
    __encoding aarch64_branch_unconditional_register
        __instruction_set A64
        __field Z 24 +: 1
        __field op 21 +: 2
        __field A 11 +: 1
        __field M 10 +: 1
        __field Rn 5 +: 5
        __field Rm 0 +: 5
        __opcode '1101011x 0xx11111 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            BranchType branch_type;
            integer m = UInt(Rm);
            boolean pac = (A == '1');
            boolean use_key_a = (M == '0');
            boolean source_is_sp = ((Z == '1') && (m == 31));
            
            if !pac && m != 0 then 
                UNDEFINED;
            elsif pac && !HavePACExt() then 
                UNDEFINED;
            
            case op of
                when '00' branch_type = BranchType_INDIR;
                when '01' branch_type = BranchType_INDCALL;
                when '10' branch_type = BranchType_RET;
                otherwise UNDEFINED;
            
            if pac then
                if Z == '0' && m != 31 then
                    UNDEFINED;
            
                if branch_type == BranchType_RET then
                    if n != 31 then UNDEFINED;
                    n = 30;
                    source_is_sp = TRUE;

    __execute
        bits(64) target = X[n];
        if pac then
            bits(64) modifier = if source_is_sp then SP[] else X[m];
        
            if use_key_a then
                target = AuthIA(target, modifier);
            else
                target = AuthIB(target, modifier);
        
        if branch_type == BranchType_INDCALL then X[30] = PC[] + 4;
        
        // Value in BTypeNext will be used to set PSTATE.BTYPE
        case branch_type of
            when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ
                if InGuardedPage then
                    if n == 16 || n == 17 then
                        BTypeNext = '01';
                    else
                        BTypeNext = '11';
                else
                    BTypeNext = '01';
            when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ
                BTypeNext = '10';
            when BranchType_RET             // RET, RETAA, RETAB 
                BTypeNext = '00';
        
        BranchTo(target, branch_type);

__instruction aarch64_vector_crypto_sha512_sha512h
    __encoding aarch64_vector_crypto_sha512_sha512h
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 011xxxxx 100000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSHA512Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vtmp;  
        bits(64)  MSigma1;
        bits(64)  tmp;
        bits(128) X = V[n];
        bits(128) Y = V[m];
        bits(128) W = V[d];
        
        MSigma1 =  ROR(Y<127:64>, 14) EOR ROR(Y<127:64>,18) EOR ROR(Y<127:64>,41);
        Vtmp<127:64> =  (Y<127:64> AND X<63:0>) EOR (NOT(Y<127:64>) AND X<127:64>);
        Vtmp<127:64> = (Vtmp<127:64> + MSigma1 +  W<127:64>);
        tmp = Vtmp<127:64> + Y<63:0>;
        MSigma1 = ROR(tmp, 14) EOR ROR(tmp,18) EOR ROR(tmp,41);
        Vtmp<63:0> = (tmp AND Y<127:64>) EOR (NOT(tmp) AND X<63:0>);
        Vtmp<63:0> = (Vtmp<63:0> + MSigma1 + W<63:0>);
        V[d] =  Vtmp;

__instruction ST4B_Z.P.BR_Contiguous
    __encoding ST4B_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 011xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction aarch64_integer_conditional_select
    __encoding aarch64_integer_conditional_select
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field Rm 16 +: 5
        __field cond 12 +: 4
        __field o2 10 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xx011010 100xxxxx xxxx0xxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            bits(4) condition = cond;
            boolean else_inv = (op == '1');
            boolean else_inc = (o2 == '1');

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        
        if ConditionHolds(condition) then
            result = operand1;
        else
            result = operand2;
            if else_inv then result = NOT(result);
            if else_inc then result = result + 1;
        
        X[d] = result;

__instruction aarch64_memory_literal_simdfp
    __encoding aarch64_memory_literal_simdfp
        __instruction_set A64
        __field opc 30 +: 2
        __field imm19 5 +: 19
        __field Rt 0 +: 5
        __opcode 'xx011100 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer size;
            bits(64) offset;
            
            case opc of
                when '00'
                    size = 4;
                when '01'
                    size = 8;
                when '10'
                    size = 16;
                when '11'
                    UNDEFINED;
            
            offset = SignExtend(imm19:'00', 64);
            boolean tag_checked = FALSE;

    __execute
        bits(64) address = PC[] + offset;
        bits(size*8) data;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        data = Mem[address, size, AccType_VEC];
        V[t] = data;

__instruction aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
    __encoding aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 xx1xxxxx 10x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '00' || size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;
            
            boolean sub_op = (o1 == '1');

    __encoding aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 10x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '00' || size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        integer accum;
        boolean sat1;
        boolean sat2;
        
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            element2 = SInt(Elem[operand2, e, esize]);
            (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
            if sub_op then
                accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
            else
                accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
            (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
            if sat1 || sat2 then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_round
    __encoding aarch64_vector_arithmetic_unary_fp16_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __encoding aarch64_vector_arithmetic_unary_float_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_add_fp16
    __encoding aarch64_vector_arithmetic_binary_uniform_add_fp16
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 010xxxxx 000101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_add_fp
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 0x1xxxxx 110101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            if pair then
                element1 = Elem[concat, 2*e, esize];
                element2 = Elem[concat, (2*e)+1, esize];
            else
                element1 = Elem[operand1, e, esize];
                element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPAdd(element1, element2, FPCR);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field S 13 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111111 xxxxxxxx 11x1x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            boolean rounding = TRUE;
            boolean sub_op = (S  == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field S 13 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 xxxxxxxx 11x1x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean rounding = TRUE;
            boolean sub_op = (S  == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        integer rounding_const = if rounding then 1 << (esize - 1) else 0;
        integer element1;
        integer element2;
        integer element3;
        integer product;
        boolean sat;
        
        element2 = SInt(Elem[operand2, index, esize]);
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            element3 = SInt(Elem[operand3, e, esize]);
            if sub_op then
                accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
            else
                accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
            (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_integer_crc
    __encoding aarch64_integer_crc
        __instruction_set A64
        __field sf 31 +: 1
        __field Rm 16 +: 5
        __field C 12 +: 1
        __field sz 10 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011010 110xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveCRCExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sf == '1' && sz != '11' then UNDEFINED;
            if sf == '0' && sz == '11' then UNDEFINED;
            integer size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64
            boolean crc32c = (C == '1');

    __execute
        bits(32)      acc     = X[n];   // accumulator
        bits(size)    val     = X[m];   // input value
        bits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;
        
        bits(32+size) tempacc = BitReverse(acc) : Zeros(size);
        bits(size+32) tempval = BitReverse(val) : Zeros(32);
        
        // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
        X[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));

__instruction aarch64_float_convert_fix
    __encoding aarch64_float_convert_fix
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field scale 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            
            case type1 of
                when '00' fltsize = 32;
                when '01' fltsize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            if sf == '0' && scale<5> == '0' then UNDEFINED;
            integer fracbits = 64 - UInt(scale);
            
            case opcode<2:1>:rmode of
                when '00 11'        // FCVTZ
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                otherwise
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
                V[d] = fltval;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction SQINCW_Z.ZS__
    __encoding SQINCW_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1010xxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction EOR_P.P.PP_Z
    __encoding EOR_P.P.PP_Z
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0000xxxx 01xxxx1x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = FALSE;

    __encoding EORS_P.P.PP_Z
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0100xxxx 01xxxx1x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            bit element1 = ElemP[operand1, e, esize];
            bit element2 = ElemP[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                ElemP[result, e, esize] = element1 EOR element2;
            else
                ElemP[result, e, esize] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction UMAX_Z.P.ZZ__
    __encoding UMAX_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx001001 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer maximum = Max(element1, element2);
                Elem[result, e, esize] = maximum<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction ASR_Z.P.ZI__
    __encoding ASR_Z.P.ZI__
        __instruction_set A64
        __field tszh 22 +: 2
        __field Pg 10 +: 3
        __field tszl 8 +: 2
        __field imm3 5 +: 3
        __field Zdn 0 +: 5
        __opcode '00000100 xx000000 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            bits(4) tsize = tszh:tszl;
            case tsize of
                when '0000' UNDEFINED;
                when '0001' esize = 8;
                when '001x' esize = 16;
                when '01xx' esize = 32;
                when '1xxx' esize = 64;
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer shift = (2 * esize) - UInt(tsize:imm3);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(PL) mask = P[g];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = ASR(element1, shift);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_memory_single_general_register
    __encoding aarch64_memory_single_general_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_memory_single_simdfp_register
    __encoding aarch64_memory_single_simdfp_register
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field S 12 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111100 xx1xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(opc<1>:size);
            if scale > 4 then UNDEFINED;
            if option<1> == '0' then UNDEFINED;             // sub-word index
            ExtendType extend_type = DecodeRegExtend(option);
            integer shift = if S == '1' then scale else 0;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer m = UInt(Rm);
        AccType acctype = AccType_VEC;
        MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH;
    __execute
        bits(64) offset = ExtendReg(m, extend_type, shift);
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        bits(64) address;
        bits(datasize) data;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                data = V[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                V[t] = data;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_integer_ins_ext_insert_movewide
    __encoding aarch64_integer_ins_ext_insert_movewide
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field hw 21 +: 2
        __field imm16 5 +: 16
        __field Rd 0 +: 5
        __opcode 'xxx10010 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer datasize = if sf == '1' then 64 else 32;
            bits(16) imm = imm16;
            integer pos;
            MoveWideOp opcode;
            
            case opc of
                when '00' opcode = MoveWideOp_N;
                when '10' opcode = MoveWideOp_Z;
                when '11' opcode = MoveWideOp_K;
                otherwise UNDEFINED;
            
            if sf == '0' && hw<1> == '1' then UNDEFINED;
            pos = UInt(hw:'0000');

    __execute
        bits(datasize) result;
        
        if opcode == MoveWideOp_K then
            result = X[d];
        else
            result = Zeros();
        
        result<pos+15:pos> = imm;
        if opcode == MoveWideOp_N then
            result = NOT(result);
        X[d] = result;

__instruction aarch64_memory_vector_multiple_no_wb
    __encoding aarch64_memory_vector_multiple_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 0x000000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_multiple_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field Rm 16 +: 5
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << UInt(size);
        integer elements = datasize DIV esize;
        
        integer rpt;    // number of iterations
        integer selem;  // structure elements 
        
        case opcode of
            when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
            when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
            when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
            when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
            when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
            when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
            when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
            otherwise UNDEFINED;
        
        // .1D format only permitted with LD1 & ST1
        if size:Q == '110' && selem != 1 then UNDEFINED;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(datasize) rval;
        integer tt;
        constant integer ebytes = esize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        for r = 0 to rpt-1
            for e = 0 to elements-1
                tt = (t + r) MOD 32;
                for s = 0 to selem-1
                    rval = V[tt];
                    if memop == MemOp_LOAD then
                        Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                        V[tt] = rval;
                    else // memop == MemOp_STORE
                        Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                    offs = offs + ebytes;
                    tt = (tt + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_branch_conditional_compare
    __encoding aarch64_branch_conditional_compare
        __instruction_set A64
        __field sf 31 +: 1
        __field op 24 +: 1
        __field imm19 5 +: 19
        __field Rt 0 +: 5
        __opcode 'x011010x xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer datasize = if sf == '1' then 64 else 32;
            boolean iszero = (op == '0');
            bits(64) offset = SignExtend(imm19:'00', 64);

    __execute
        bits(datasize) operand1 = X[t];
        
        if IsZero(operand1) == iszero then
            BranchTo(PC[] + offset, BranchType_DIR);

__instruction LDNF1SH_Z.P.BI_S32
    __encoding LDNF1SH_Z.P.BI_S32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0011xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __encoding LDNF1SH_Z.P.BI_S64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0001xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                // MemNF[] will return fault=TRUE if access is not performed for any reason
                (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_unary_cmp_int_lessthan_sisd
    __encoding aarch64_vector_arithmetic_unary_cmp_int_lessthan_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 xx100000 101010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison = CompareOp_LT;

    __encoding aarch64_vector_arithmetic_unary_cmp_int_lessthan_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx100000 101010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison = CompareOp_LT;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element;
        boolean test_passed;
        
        for e = 0 to elements-1
            element = SInt(Elem[operand, e, esize]);
            case comparison of
                when CompareOp_GT test_passed = element > 0;
                when CompareOp_GE test_passed = element >= 0;
                when CompareOp_EQ test_passed = element == 0;
                when CompareOp_LE test_passed = element <= 0;
                when CompareOp_LT test_passed = element < 0;
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_int_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field eq 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 0011x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean cmp_eq = (eq == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field eq 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0011x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean cmp_eq = (eq == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_branch_unconditional_eret
    __encoding aarch64_branch_unconditional_eret
        __instruction_set A64
        __field A 11 +: 1
        __field M 10 +: 1
        __field Rn 5 +: 5
        __field op4 0 +: 5
        __opcode '11010110 10011111 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if PSTATE.EL == EL0 then UNDEFINED;
            boolean pac = (A == '1');
            boolean use_key_a = (M == '0');
            
            if !pac && op4 != '00000' then
                UNDEFINED;
            elsif pac && (!HavePACExt() || op4 != '11111') then
                UNDEFINED;
            
            if Rn != '11111' then 
                UNDEFINED;

    __execute
        AArch64.CheckForERetTrap(pac, use_key_a);
        bits(64) target = ELR[];
        
        if pac then
            if use_key_a then
                target = AuthIA(ELR[], SP[]);
            else
                target = AuthIB(ELR[], SP[]);
        
        AArch64.ExceptionReturn(target, SPSR[]);

__instruction aarch64_vector_arithmetic_binary_disparate_diff
    __encoding aarch64_vector_arithmetic_binary_disparate_diff
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field op 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 01x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean accumulate = (op == '0');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) absdiff;
        
        result = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            absdiff = Abs(element1 - element2)<2*esize-1:0>;
            Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
        V[d] = result;

__instruction aarch64_integer_conditional_compare_register
    __encoding aarch64_integer_conditional_compare_register
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field Rm 16 +: 5
        __field cond 12 +: 4
        __field Rn 5 +: 5
        __field nzcv 0 +: 4
        __opcode 'xx111010 010xxxxx xxxx00xx xxx0xxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            bits(4) condition = cond;
            bits(4) flags = nzcv;

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bit carry_in = '0';
        
        if ConditionHolds(condition) then
            if sub_op then
                operand2 = NOT(operand2);
                carry_in = '1';
            (-, flags) = AddWithCarry(operand1, operand2, carry_in);
        PSTATE.<N,Z,C,V> = flags;

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
    __encoding aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100000 011110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean neg = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_diff_neg_sat_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 011110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean neg = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = SInt(Elem[operand, e, esize]);
            if neg then
                element = -element;
            else
                element = Abs(element);
            (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_system_barriers
    __encoding aarch64_system_barriers
        __instruction_set A64
        __field CRm 8 +: 4
        __field opc 5 +: 2
        __opcode '11010101 00000011 0011xxxx 1xx11111'
        __guard TRUE
        __decode
            MemBarrierOp op;
            MBReqDomain domain;
            MBReqTypes types;
            
            case opc of
                when '00' op = MemBarrierOp_DSB;
                when '01' op = MemBarrierOp_DMB;
                when '10' op = MemBarrierOp_ISB;
                otherwise 
                    if HaveSBExt() && CRm<3:0> == '0000' then 
                        op = MemBarrierOp_SB;
                    else
                        UNDEFINED;
            
            case CRm<3:2> of
                when '00' domain = MBReqDomain_OuterShareable;
                when '01' domain = MBReqDomain_Nonshareable;
                when '10' domain = MBReqDomain_InnerShareable;
                when '11' domain = MBReqDomain_FullSystem;
            
            case CRm<1:0> of
                when '01' types = MBReqTypes_Reads;
                when '10' types = MBReqTypes_Writes;
                when '11' types = MBReqTypes_All;
                otherwise
                    if CRm<3:2> == '01' then
                        op = MemBarrierOp_PSSBB;
                    elsif CRm<3:2> == '00' && opc == '00' then 
                        op = MemBarrierOp_SSBB;
                    elsif HaveSBExt() && CRm<3:2> == '00' && opc == '11' then 
                        op = MemBarrierOp_SB;
                    else
                        types  = MBReqTypes_All;
                        domain = MBReqDomain_FullSystem;

    __execute
        case op of
            when MemBarrierOp_DSB
                DataSynchronizationBarrier(domain, types);
            when MemBarrierOp_DMB
                DataMemoryBarrier(domain, types);
            when MemBarrierOp_ISB
                InstructionSynchronizationBarrier();
            when MemBarrierOp_SSBB
                SpeculativeStoreBypassBarrierToVA();
            when MemBarrierOp_PSSBB
                SpeculativeStoreBypassBarrierToPA();
            when MemBarrierOp_SB
                SpeculationBarrier();

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction aarch64_memory_single_simdfp_immediate_signed_post_idx
    __encoding aarch64_memory_single_simdfp_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111100 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(opc<1>:size);
            if scale > 4 then UNDEFINED;
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_simdfp_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111100 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(opc<1>:size);
            if scale > 4 then UNDEFINED;
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_simdfp_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111101 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(opc<1>:size);
            if scale > 4 then UNDEFINED;
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_VEC;
        MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        bits(64) address;
        bits(datasize) data;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                data = V[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                V[t] = data;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
        __instruction_set A64
        __field Q 30 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 010xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp_product
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 0x1xxxxx 110111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPMul(element1, element2, FPCR);
        
        V[d] = result;

__instruction aarch64_integer_shift_variable
    __encoding aarch64_integer_shift_variable
        __instruction_set A64
        __field sf 31 +: 1
        __field Rm 16 +: 5
        __field op2 10 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011010 110xxxxx 0010xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            ShiftType shift_type = DecodeShift(op2);

    __execute
        bits(datasize) result;
        bits(datasize) operand2 = X[m];
        
        result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
        X[d] = result;

__instruction aarch64_vector_arithmetic_unary_cmp_fp16_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_cmp_fp16_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 11111000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 1x100000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_fp16_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 11111000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 1x100000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) zero = FPZero('0');
        bits(esize) element;
        boolean test_passed;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            case comparison of
                when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
                when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
                when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
                when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
                when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_shift_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_shift_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');
            if S == '0' && size != '11' then UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_shift_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        integer round_const = 0;
        integer shift;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            shift = SInt(Elem[operand2, e, esize]<7:0>);
            if rounding then
                round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift 
            element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
            if saturating then
                (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                if sat then FPSR.QC = '1';
            else
                Elem[result, e, esize] = element<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_vector_shift_right_narrow_logical
    __encoding aarch64_vector_shift_right_narrow_logical
        __instruction_set A64
        __field Q 30 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 0xxxxxxx 1000x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize*2) operand = V[n];
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        
        for e = 0 to elements-1
            element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
            Elem[result, e, esize] = element<esize-1:0>;
        
        Vpart[d, part] = result;

__instruction aarch64_memory_exclusive_pair
    __encoding aarch64_memory_exclusive_pair
        __instruction_set A64
        __field sz 30 +: 1
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '1x001000 0x1xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = TRUE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 32 << UInt(sz);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction UMAX_Z.ZI__
    __encoding UMAX_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx101001 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            boolean unsigned = TRUE;
            integer imm = Int(imm8, unsigned);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            Elem[result, e, esize] = Max(element1, imm)<esize-1:0>;
        
        Z[dn] = result;

__instruction AND_Z.ZZ__
    __encoding AND_Z.ZZ__
        __instruction_set A64
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 001xxxxx 001100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        
        Z[d] = operand1 AND operand2;

__instruction SQINCP_R.P.R_SX
    __encoding SQINCP_R.P.R_SX
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Rdn 0 +: 5
        __opcode '00100101 xx101000 1000100x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);
            boolean unsigned = FALSE;
            integer ssize = 32;

    __encoding SQINCP_R.P.R_X
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Rdn 0 +: 5
        __opcode '00100101 xx101000 1000110x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);
            boolean unsigned = FALSE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(ssize) operand = X[dn];
        bits(ssize) result;
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        integer element = Int(operand, unsigned);
        (result, -) = SatQ(element + count, ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction LD1SB_Z.P.BZ_D.x32.unscaled
    __encoding LD1SB_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 0x0xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1SB_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 0x0xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1SB_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 010xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offs_size = 64;
            boolean unsigned = FALSE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset = Z[m];
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_integer_flags_axflag
    __encoding aarch64_integer_flags_axflag
        __instruction_set A64
        __field CRm 8 +: 4
        __opcode '11010101 00000000 0100xxxx 01011111'
        __guard TRUE
        __decode
            if !HaveFlagFormatExt() then UNDEFINED;

    __execute
        bit N = '0';
        bit Z = PSTATE.Z OR PSTATE.V;
        bit C = PSTATE.C AND NOT(PSTATE.V);
        bit V = '0';
        
        PSTATE.N = N;
        PSTATE.Z = Z;
        PSTATE.C = C;
        PSTATE.V = V;

__instruction BIC_P.P.PP_Z
    __encoding BIC_P.P.PP_Z
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0000xxxx 01xxxx0x xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = FALSE;

    __encoding BICS_P.P.PP_Z
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0100xxxx 01xxxx0x xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            bit element1 = ElemP[operand1, e, esize];
            bit element2 = ElemP[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                ElemP[result, e, esize] = element1 AND (NOT element2);
            else
                ElemP[result, e, esize] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction aarch64_vector_crypto_aes_mix
    __encoding aarch64_vector_crypto_aes_mix
        __instruction_set A64
        __field D 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01001110 00101000 011x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            if !HaveAESExt() then UNDEFINED;
            boolean decrypt = (D == '1');

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) operand = V[n];
        bits(128) result;
        if decrypt then
            result = AESInvMixColumns(operand);
        else
            result = AESMixColumns(operand);
        V[d] = result;

__instruction aarch64_integer_logical_shiftedreg
    __encoding aarch64_integer_logical_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field shift 22 +: 2
        __field N 21 +: 1
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01010 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);
            boolean invert = (N == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        X[d] = result;

__instruction STNT1B_Z.P.BR_Contiguous
    __encoding STNT1B_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 000xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(64) offset = X[m];
        bits(VL) src;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        src = Z[t];
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
            offset = offset + 1;

__instruction UQINCB_R.RS_UW
    __encoding UQINCB_R.RS_UW
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0010xxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 32;

    __encoding UQINCB_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0011xxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction PFALSE_P__
    __encoding PFALSE_P__
        __instruction_set A64
        __field Pd 0 +: 4
        __opcode '00100101 00011000 11100100 0000xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer d = UInt(Pd);

    __execute
        CheckSVEEnabled();
        P[d] = Zeros(PL);

__instruction aarch64_vector_arithmetic_binary_uniform_sub_saturating_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_sub_saturating_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 001011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_sub_saturating_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 001011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer diff;
        boolean sat;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            diff = element1 - element2;
            (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction LD1B_Z.P.BZ_D.x32.unscaled
    __encoding LD1B_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 0x0xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1B_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 0x0xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1B_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 010xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset = Z[m];
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_branch_conditional_test
    __encoding aarch64_branch_conditional_test
        __instruction_set A64
        __field b5 31 +: 1
        __field op 24 +: 1
        __field b40 19 +: 5
        __field imm14 5 +: 14
        __field Rt 0 +: 5
        __opcode 'x011011x xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            
            integer datasize = if b5 == '1' then 64 else 32;
            integer bit_pos = UInt(b5:b40);
            bit bit_val = op;
            bits(64) offset = SignExtend(imm14:'00', 64);

    __execute
        bits(datasize) operand = X[t];
        
        if operand<bit_pos> == bit_val then
            BranchTo(PC[] + offset, BranchType_DIR);

__instruction SQDECD_Z.ZS__
    __encoding SQDECD_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1110xxxx 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction REVB_Z.Z__
    __encoding REVB_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx100100 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer swsize = 8;

    __encoding REVH_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx100101 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size != '1x' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer swsize = 16;

    __encoding REVW_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx100110 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer swsize = 32;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                bits(esize) element = Elem[operand, e, esize];
                Elem[result, e, esize] = Reverse(element, swsize);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_mul_poly
    __encoding aarch64_vector_arithmetic_binary_disparate_mul_poly
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 111000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '01' || size == '10' then UNDEFINED;
            if size == '11' && !HaveBit128PMULLExt() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            Elem[result, e, 2*esize] = PolynomialMult(element1, element2);
        
        V[d] = result;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction aarch64_vector_shift_left_sat_sisd
    __encoding aarch64_vector_shift_left_sat_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 011x01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = UInt(immh:immb) - esize;
            
            boolean src_unsigned;
            boolean dst_unsigned;
            case op:U of
                when '00' UNDEFINED;
                when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

    __encoding aarch64_vector_shift_left_sat_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 011x01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = UInt(immh:immb) - esize;
            
            boolean src_unsigned;
            boolean dst_unsigned;
            case op:U of
                when '00' UNDEFINED;
                when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) result;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = Int(Elem[operand, e, esize], src_unsigned) << shift;
            (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction PUNPKHI_P.P__
    __encoding PUNPKHI_P.P__
        __instruction_set A64
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00000101 00110001 0100000x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer n = UInt(Pn);
            integer d = UInt(Pd);
            boolean hi = TRUE;

    __encoding PUNPKLO_P.P__
        __instruction_set A64
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00000101 00110000 0100000x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer n = UInt(Pn);
            integer d = UInt(Pd);
            boolean hi = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) operand = P[n];
        bits(PL) result;
        
        for e = 0 to elements-1
            ElemP[result, e, esize] = ElemP[operand, if hi then e + elements else e, esize DIV 2];
        
        P[d] = result;

__instruction CLASTA_Z.P.ZZ__
    __encoding CLASTA_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000101 xx101000 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean isBefore = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        integer last = LastActiveElement(mask, esize);
        
        if last < 0 then
            result = operand1;
        else
            if !isBefore then
                last = last + 1;
                if last >= elements then last = 0;
            for e = 0 to elements-1
                Elem[result, e, esize] = Elem[operand2, last, esize];
        
        Z[dn] = result;

__instruction FNMAD_Z.P.ZZZ__
    __encoding FNMAD_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Za 16 +: 5
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx1xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            integer a = UInt(Za);
            boolean op1_neg = TRUE;
            boolean op3_neg = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[a];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            bits(esize) element3 = Elem[operand3, e, esize];
            
            if ElemP[mask, e, esize] == '1' then
                if op1_neg then element1 = FPNeg(element1);
                if op3_neg then element3 = FPNeg(element3);
                Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field a 23 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (a == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            if pair then
                element1 = Elem[concat, 2*e, esize];
                element2 = Elem[concat, (2*e)+1, esize];
            else
                element1 = Elem[operand1, e, esize];
                element2 = Elem[operand2, e, esize];
        
            if minimum then
                Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
            else
                Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);
        
        V[d] = result;

__instruction SUB_Z.ZZ__
    __encoding SUB_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = element1 - element2;
        
        Z[d] = result;

__instruction aarch64_integer_logical_shiftedreg
    __encoding aarch64_integer_logical_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field shift 22 +: 2
        __field N 21 +: 1
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01010 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);
            boolean invert = (N == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        X[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_shift_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_shift_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');
            if S == '0' && size != '11' then UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_shift_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        integer round_const = 0;
        integer shift;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            shift = SInt(Elem[operand2, e, esize]<7:0>);
            if rounding then
                round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift 
            element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
            if saturating then
                (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                if sat then FPSR.QC = '1';
            else
                Elem[result, e, esize] = element<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction aarch64_integer_logical_shiftedreg
    __encoding aarch64_integer_logical_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field shift 22 +: 2
        __field N 21 +: 1
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01010 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);
            boolean invert = (N == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        X[d] = result;

__instruction LD1W_Z.P.AI_S
    __encoding LD1W_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 001xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __encoding LD1W_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 001xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction LD1W_Z.P.BR_U32
    __encoding LD1W_Z.P.BR_U32
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 010xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            boolean unsigned = TRUE;

    __encoding LD1W_Z.P.BR_U64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 011xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction WHILELE_P.P.RR__
    __encoding WHILELE_P.P.RR__
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field sf 12 +: 1
        __field Rn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx1xxxxx 000x01xx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer rsize = 32 << UInt(sf);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer d = UInt(Pd);
            boolean unsigned = FALSE;
            SVECmp op = Cmp_LE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = Ones(PL);
        bits(rsize) operand1 = X[n];
        bits(rsize) operand2 = X[m];
        bits(PL) result;
        boolean last = TRUE;
        
        for e = 0 to elements-1
            boolean cond;
            case op of
                when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));
                when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));
        
            last = last && cond;
            ElemP[result, e, esize] = if last then '1' else '0';
            operand1 = operand1 + 1;
        
        PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction ST1D_Z.P.BI__
    __encoding ST1D_Z.P.BI__
        __instruction_set A64
        __field size 21 +: 2
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 1xx0xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size != '11' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8 << UInt(size);
            integer msize = 64;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) src = Z[t];
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;
            addr = addr + mbytes;

__instruction aarch64_memory_single_general_immediate_signed_offset_unpriv
    __encoding aarch64_memory_single_general_immediate_signed_offset_unpriv
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        
        unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
        unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
        
        user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
        if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
            acctype = AccType_UNPRIV;
        else
            acctype = AccType_NORMAL;
        
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_crypto_sha3_bcax
    __encoding aarch64_vector_crypto_sha3_bcax
        __instruction_set A64
        __field Rm 16 +: 5
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 001xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSHA3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer a = UInt(Ra);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        bits(128) Va = V[a];
        V[d] = Vn EOR (Vm AND NOT(Va));

__instruction MLA_Z.P.ZZZ__
    __encoding MLA_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '00000100 xx0xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean sub_op = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = UInt(Elem[operand1, e, esize]);
            integer element2 = UInt(Elem[operand2, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                integer product = element1 * element2;
                if sub_op then
                    Elem[result, e, esize] = Elem[operand3, e, esize] - product;
                else
                    Elem[result, e, esize] = Elem[operand3, e, esize] + product;
            else
                Elem[result, e, esize] = Elem[operand3, e, esize];
        
        Z[da] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_normal
    __encoding aarch64_memory_single_general_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_integer_ins_ext_insert_movewide
    __encoding aarch64_integer_ins_ext_insert_movewide
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field hw 21 +: 2
        __field imm16 5 +: 16
        __field Rd 0 +: 5
        __opcode 'xxx10010 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer datasize = if sf == '1' then 64 else 32;
            bits(16) imm = imm16;
            integer pos;
            MoveWideOp opcode;
            
            case opc of
                when '00' opcode = MoveWideOp_N;
                when '10' opcode = MoveWideOp_Z;
                when '11' opcode = MoveWideOp_K;
                otherwise UNDEFINED;
            
            if sf == '0' && hw<1> == '1' then UNDEFINED;
            pos = UInt(hw:'0000');

    __execute
        bits(datasize) result;
        
        if opcode == MoveWideOp_K then
            result = X[d];
        else
            result = Zeros();
        
        result<pos+15:pos> = imm;
        if opcode == MoveWideOp_N then
            result = NOT(result);
        X[d] = result;

__instruction aarch64_integer_conditional_select
    __encoding aarch64_integer_conditional_select
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field Rm 16 +: 5
        __field cond 12 +: 4
        __field o2 10 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xx011010 100xxxxx xxxx0xxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            bits(4) condition = cond;
            boolean else_inv = (op == '1');
            boolean else_inc = (o2 == '1');

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        
        if ConditionHolds(condition) then
            result = operand1;
        else
            result = operand2;
            if else_inv then result = NOT(result);
            if else_inc then result = result + 1;
        
        X[d] = result;

__instruction FNEG_Z.P.Z__
    __encoding FNEG_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx011101 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPNeg(element);
        
        Z[d] = result;

__instruction BRKN_P.P.PP__
    __encoding BRKN_P.P.PP__
        __instruction_set A64
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pdm 0 +: 4
        __opcode '00100101 00011000 01xxxx0x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer dm = UInt(Pdm);
            boolean setflags = FALSE;

    __encoding BRKNS_P.P.PP__
        __instruction_set A64
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pdm 0 +: 4
        __opcode '00100101 01011000 01xxxx0x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer dm = UInt(Pdm);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[dm];
        bits(PL) result;
        
        if LastActive(mask, operand1, 8) == '1' then
            result = operand2;
        else
            result = Zeros();
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(Ones(PL), result, 8);
        P[dm] = result;

__instruction aarch64_float_arithmetic_round_frint
    __encoding aarch64_float_arithmetic_round_frint
        __instruction_set A64
        __field type1 22 +: 2
        __field rmode 15 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1001xx x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case rmode of
                when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundInt(operand, FPCR, rounding, exact);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_add_halving_truncating
    __encoding aarch64_vector_arithmetic_binary_uniform_add_halving_truncating
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer sum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            sum = element1 + element2;
            Elem[result, e, esize] = sum<esize:1>;
        
        V[d] = result;

__instruction aarch64_vector_shift_right_narrow_uniform_sisd
    __encoding aarch64_vector_shift_right_narrow_uniform_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 1001x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then UNDEFINED;
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_shift_right_narrow_uniform_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 1001x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize*2) operand = V[n];
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
            (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
            if sat then FPSR.QC = '1';
        
        Vpart[d, part] = result;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction aarch64_memory_single_general_immediate_signed_offset_unpriv
    __encoding aarch64_memory_single_general_immediate_signed_offset_unpriv
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        
        unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
        unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
        
        user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
        if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
            acctype = AccType_UNPRIV;
        else
            acctype = AccType_NORMAL;
        
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction LD3B_Z.P.BR_Contiguous
    __encoding LD3B_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 010xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_integer_tags_mcsettaganddatapairpost
    __encoding aarch64_integer_tags_mcsettaganddatapairpost
        __instruction_set A64
        __field simm7 15 +: 7
        __field Xt2 10 +: 5
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '01101000 10xxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            integer t = UInt(Xt);
            integer t2 = UInt(Xt2);
            bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
            boolean writeback = TRUE;
            boolean postindex = TRUE;

    __encoding aarch64_integer_tags_mcsettaganddatapairpre
        __instruction_set A64
        __field simm7 15 +: 7
        __field Xt2 10 +: 5
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '01101001 10xxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            integer t = UInt(Xt);
            integer t2 = UInt(Xt2);
            bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
            boolean writeback = TRUE;
            boolean postindex = FALSE;

    __encoding aarch64_integer_tags_mcsettaganddatapair
        __instruction_set A64
        __field simm7 15 +: 7
        __field Xt2 10 +: 5
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '01101001 00xxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Xn);
            integer t = UInt(Xt);
            integer t2 = UInt(Xt2);
            bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
            boolean writeback = FALSE;
            boolean postindex = FALSE;

    __execute
        bits(64) address;
        bits(64) data1;
        bits(64) data2;
        
        SetNotTagCheckedInstruction(TRUE);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        data1 = X[t];
        data2 = X[t2];
        
        if !postindex then
            address = address + offset;
        
        Mem[address, 8, AccType_NORMAL] = data1;
        Mem[address+8, 8, AccType_NORMAL] = data2;
        
        MemTag[address] = AllocationTagFromAddress(address);
        
        if writeback then
            if postindex then
                address = address + offset;
        
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction LD4B_Z.P.BI_Contiguous
    __encoding LD4B_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0110xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer offset = SInt(imm4);
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_float_arithmetic_mul_add_sub
    __encoding aarch64_float_arithmetic_mul_add_sub
        __instruction_set A64
        __field type1 22 +: 2
        __field o1 21 +: 1
        __field Rm 16 +: 5
        __field o0 15 +: 1
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011111 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer a = UInt(Ra);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean opa_neg = (o1 == '1');
            boolean op1_neg = (o0 != o1);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operanda = V[a];
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        if opa_neg then operanda = FPNeg(operanda);
        if op1_neg then operand1 = FPNeg(operand1);
        result = FPMulAdd(operanda, operand1, operand2, FPCR);
        
        V[d] = result;

__instruction SADDV_R.P.Z__
    __encoding SADDV_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000100 xx000000 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        integer sum = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer element = SInt(Elem[operand, e, esize]);
                sum = sum + element;
        
        V[d] = sum<63:0>;

__instruction PRFD_I.P.BI_S
    __encoding PRFD_I.P.BI_S
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000101 11xxxxxx 011xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 3;
            integer offset = SInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) addr;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        
        addr = base + ((offset * elements) << scale);
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Hint_Prefetch(addr, pref_hint, level, stream);
            addr = addr + (1 << scale);

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction LD1SW_Z.P.AI_D
    __encoding LD1SW_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 001xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = FALSE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction LD1SW_Z.P.BR_S64
    __encoding LD1SW_Z.P.BR_S64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 100xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction LDNF1D_Z.P.BI_U64
    __encoding LDNF1D_Z.P.BI_U64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1111xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                // MemNF[] will return fault=TRUE if access is not performed for any reason
                (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction ADR_Z.AZ_SD.same.scaled
    __encoding ADR_Z.AZ_SD.same.scaled
        __instruction_set A64
        __field sz 22 +: 1
        __field Zm 16 +: 5
        __field msz 10 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 1x1xxxxx 1010xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            integer osize = esize;
            boolean unsigned = TRUE;
            integer mbytes = 1 << UInt(msz);

    __encoding ADR_Z.AZ_D.s32.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field msz 10 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 001xxxxx 1010xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            integer osize = 32;
            boolean unsigned = FALSE;
            integer mbytes = 1 << UInt(msz);

    __encoding ADR_Z.AZ_D.u32.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field msz 10 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 011xxxxx 1010xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            integer osize = 32;
            boolean unsigned = TRUE;
            integer mbytes = 1 << UInt(msz);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(VL) offs = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) addr = Elem[base, e, esize];
            integer offset = Int(Elem[offs, e, esize]<osize-1:0>, unsigned);
            Elem[result, e, esize] = addr + (offset * mbytes);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_sub_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_sub_fp16_sisd
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 110xxxxx 000101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            boolean abs = TRUE;

    __encoding aarch64_vector_arithmetic_binary_uniform_sub_fp_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 1x1xxxxx 110101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            boolean abs = TRUE;

    __encoding aarch64_vector_arithmetic_binary_uniform_sub_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 110xxxxx 000101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean abs = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_sub_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 1x1xxxxx 110101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean abs = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        bits(esize) diff;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            diff = FPSub(element1, element2, FPCR);
            Elem[result, e, esize] = if abs then FPAbs(diff) else diff;
        
        V[d] = result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_crypto_aes_round
    __encoding aarch64_vector_crypto_aes_round
        __instruction_set A64
        __field D 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01001110 00101000 010x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            if !HaveAESExt() then UNDEFINED;
            boolean decrypt = (D == '1');

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) operand1 = V[d];
        bits(128) operand2 = V[n];
        bits(128) result;
        result = operand1 EOR operand2;
        if decrypt then
            result = AESInvSubBytes(AESInvShiftRows(result));
        else
            result = AESSubBytes(AESShiftRows(result));
        
        V[d] = result;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction PRFD_I.P.BZ_S.x32.scaled
    __encoding PRFD_I.P.BZ_S.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000100 0x1xxxxx 011xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 32;
            boolean offs_unsigned = (xs == '0');
            integer scale = 3;

    __encoding PRFD_I.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000100 0x1xxxxx 011xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 32;
            boolean offs_unsigned = (xs == '0');
            integer scale = 3;

    __encoding PRFD_I.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000100 011xxxxx 111xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);

__instruction aarch64_vector_crypto_aes_mix
    __encoding aarch64_vector_crypto_aes_mix
        __instruction_set A64
        __field D 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01001110 00101000 011x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            if !HaveAESExt() then UNDEFINED;
            boolean decrypt = (D == '1');

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) operand = V[n];
        bits(128) result;
        if decrypt then
            result = AESInvMixColumns(operand);
        else
            result = AESMixColumns(operand);
        V[d] = result;

__instruction MUL_Z.P.ZZ__
    __encoding MUL_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010000 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = UInt(Elem[operand1, e, esize]);
            integer element2 = UInt(Elem[operand2, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                integer product = element1 * element2;
                Elem[result, e, esize] = product<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction WRFFR_F.P__
    __encoding WRFFR_F.P__
        __instruction_set A64
        __field Pn 5 +: 4
        __opcode '00100101 00101000 1001000x xxx00000'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer n = UInt(Pn);

    __execute
        CheckSVEEnabled();
        bits(PL) operand = P[n];
        
        hsb = HighestSetBit(operand);
        if hsb < 0 || IsOnes(operand<hsb:0>) then  
            FFR[] = operand;
        else // not a monotonic predicate
            FFR[] = bits(PL) UNKNOWN;

__instruction RDVL_R.I__
    __encoding RDVL_R.I__
        __instruction_set A64
        __field imm6 5 +: 6
        __field Rd 0 +: 5
        __opcode '00000100 10111111 01010xxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer d = UInt(Rd);
            integer imm = SInt(imm6);

    __execute
        CheckSVEEnabled();
        integer len = imm * (VL DIV 8);
        X[d] = len<63:0>;

__instruction aarch64_memory_single_general_immediate_signed_offset_normal
    __encoding aarch64_memory_single_general_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction FDUP_Z.I__
    __encoding FDUP_Z.I__
        __instruction_set A64
        __field size 22 +: 2
        __field imm8 5 +: 8
        __field Zd 0 +: 5
        __opcode '00100101 xx111001 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer d = UInt(Zd);
            bits(esize) imm = VFPExpandImm(imm8);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) result;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = imm;
        
        Z[d] = result;

__instruction FRINTI_Z.P.Z__
    __encoding FRINTI_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx000111 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean exact = FALSE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding FRINTX_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx000110 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean exact = TRUE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding FRINTA_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx000100 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean exact = FALSE;
            FPRounding rounding = FPRounding_TIEAWAY;

    __encoding FRINTN_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx000000 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean exact = FALSE;
            FPRounding rounding = FPRounding_TIEEVEN;

    __encoding FRINTZ_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx000011 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean exact = FALSE;
            FPRounding rounding = FPRounding_ZERO;

    __encoding FRINTM_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx000010 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean exact = FALSE;
            FPRounding rounding = FPRounding_NEGINF;

    __encoding FRINTP_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx000001 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean exact = FALSE;
            FPRounding rounding = FPRounding_POSINF;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
        
        Z[d] = result;

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_pair
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_pair
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 1010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        integer element1;
        integer element2;
        integer maxmin;
        
        for e = 0 to elements-1
            element1 = Int(Elem[concat, 2*e, esize], unsigned);
            element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
            maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
            Elem[result, e, esize] = maxmin<esize-1:0>;
        
        V[d] = result;

__instruction FRECPX_Z.P.Z__
    __encoding FRECPX_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx001100 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPRecpX(element, FPCR);
        
        Z[d] = result;

__instruction TBL_Z.ZZ_1
    __encoding TBL_Z.ZZ_1
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx1xxxxx 001100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            boolean double_table = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) indexes = Z[m];
        bits(VL) result;
        integer table_size = if double_table then VL*2 else VL;
        integer table_elems = table_size DIV esize;
        bits(table_size) table;
        
        if double_table then
            bits(VL) top = Z[(n + 1) MOD 32];
            bits(VL) bottom = Z[n];
            table = (top:bottom)<table_size-1:0>;
        else
            table = Z[n];
        
        for e = 0 to elements-1
            integer idx = UInt(Elem[indexes, e, esize]);
            Elem[result, e, esize] = if idx < table_elems then Elem[table, idx, esize] else Zeros();
        
        Z[d] = result;

__instruction aarch64_integer_arithmetic_mul_widening_32_64
    __encoding aarch64_integer_arithmetic_mul_widening_32_64
        __instruction_set A64
        __field U 23 +: 1
        __field Rm 16 +: 5
        __field o0 15 +: 1
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '10011011 x01xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer a = UInt(Ra);
            integer destsize = 64;
            integer datasize = 32;
            boolean sub_op = (o0 == '1');
            boolean unsigned = (U == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(destsize) operand3 = X[a];
        
        integer result;
        
        if sub_op then
            result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));
        else
            result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));
        
        X[d] = result<63:0>;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
        __instruction_set A64
        __field Q 30 +: 1
        __field S 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 111011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz == '1' then UNDEFINED;
            integer esize = 32;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean sub_op = (S == '1');
            integer part = 0;

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
        __instruction_set A64
        __field Q 30 +: 1
        __field S 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx1xxxxx 110011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz == '1' then UNDEFINED;
            integer esize = 32;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean sub_op = (S == '1');
            integer part = 1;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize DIV 2) operand1 = Vpart[n,part];
        bits(datasize DIV 2) operand2 = Vpart[m,part];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize DIV 2) element1;
        bits(esize DIV 2) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize DIV 2];
            element2 = Elem[operand2, e, esize DIV 2];
            if sub_op then element1 = FPNeg(element1);
            Elem[result,e,esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
        V[d] = result;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction aarch64_branch_unconditional_register
    __encoding aarch64_branch_unconditional_register
        __instruction_set A64
        __field Z 24 +: 1
        __field op 21 +: 2
        __field A 11 +: 1
        __field M 10 +: 1
        __field Rn 5 +: 5
        __field Rm 0 +: 5
        __opcode '1101011x 0xx11111 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            BranchType branch_type;
            integer m = UInt(Rm);
            boolean pac = (A == '1');
            boolean use_key_a = (M == '0');
            boolean source_is_sp = ((Z == '1') && (m == 31));
            
            if !pac && m != 0 then 
                UNDEFINED;
            elsif pac && !HavePACExt() then 
                UNDEFINED;
            
            case op of
                when '00' branch_type = BranchType_INDIR;
                when '01' branch_type = BranchType_INDCALL;
                when '10' branch_type = BranchType_RET;
                otherwise UNDEFINED;
            
            if pac then
                if Z == '0' && m != 31 then
                    UNDEFINED;
            
                if branch_type == BranchType_RET then
                    if n != 31 then UNDEFINED;
                    n = 30;
                    source_is_sp = TRUE;

    __execute
        bits(64) target = X[n];
        if pac then
            bits(64) modifier = if source_is_sp then SP[] else X[m];
        
            if use_key_a then
                target = AuthIA(target, modifier);
            else
                target = AuthIB(target, modifier);
        
        if branch_type == BranchType_INDCALL then X[30] = PC[] + 4;
        
        // Value in BTypeNext will be used to set PSTATE.BTYPE
        case branch_type of
            when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ
                if InGuardedPage then
                    if n == 16 || n == 17 then
                        BTypeNext = '01';
                    else
                        BTypeNext = '11';
                else
                    BTypeNext = '01';
            when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ
                BTypeNext = '10';
            when BranchType_RET             // RET, RETAA, RETAB 
                BTypeNext = '00';
        
        BranchTo(target, branch_type);

__instruction FDIV_Z.P.ZZ__
    __encoding FDIV_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx001101 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPDiv(element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction DECD_Z.ZS__
    __encoding DECD_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1111xxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding DECH_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 0111xxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding DECW_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1011xxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = Elem[operand1, e, esize] - (count * imm);
        
        Z[dn] = result;

__instruction aarch64_vector_crypto_sha3op_sha256_hash
    __encoding aarch64_vector_crypto_sha3op_sha256_hash
        __instruction_set A64
        __field Rm 16 +: 5
        __field P 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 000xxxxx 010x00xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if !HaveSHA256Ext() then UNDEFINED;
            boolean part1 = (P == '0');

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) result;
        if part1 then
            result = SHA256hash(V[d], V[n], V[m], TRUE);
        else
            result = SHA256hash(V[n], V[d], V[m], FALSE);
        V[d] = result;

__instruction aarch64_integer_conditional_compare_immediate
    __encoding aarch64_integer_conditional_compare_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field imm5 16 +: 5
        __field cond 12 +: 4
        __field Rn 5 +: 5
        __field nzcv 0 +: 4
        __opcode 'xx111010 010xxxxx xxxx10xx xxx0xxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            bits(4) condition = cond;
            bits(4) flags = nzcv;
            bits(datasize) imm = ZeroExtend(imm5, datasize);

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = imm;
        bit carry_in = '0';
        
        if ConditionHolds(condition) then
            if sub_op then
                operand2 = NOT(operand2);
                carry_in = '1';
            (-, flags) = AddWithCarry(operand1, operand2, carry_in);
        PSTATE.<N,Z,C,V> = flags;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_int_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field eq 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 0011x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean cmp_eq = (eq == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field eq 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0011x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean cmp_eq = (eq == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction FMAD_Z.P.ZZZ__
    __encoding FMAD_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Za 16 +: 5
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx1xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            integer a = UInt(Za);
            boolean op1_neg = FALSE;
            boolean op3_neg = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[a];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            bits(esize) element3 = Elem[operand3, e, esize];
            
            if ElemP[mask, e, esize] == '1' then
                if op1_neg then element1 = FPNeg(element1);
                if op3_neg then element3 = FPNeg(element3);
                Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_add_saturating_sisd
    __encoding aarch64_vector_arithmetic_unary_add_saturating_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100000 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_add_saturating_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        
        bits(datasize) operand2 = V[d];
        integer op1;
        integer op2;
        boolean sat;
        
        for e = 0 to elements-1
            op1 = Int(Elem[operand, e, esize], !unsigned);
            op2 = Int(Elem[operand2, e, esize], unsigned);
            (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);
            if sat then FPSR.QC = '1';
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_cmp_fp16_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_cmp_fp16_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 11111000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 1x100000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_fp16_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 11111000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 1x100000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) zero = FPZero('0');
        bits(esize) element;
        boolean test_passed;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            case comparison of
                when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
                when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
                when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
                when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
                when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_float_arithmetic_mul_add_sub
    __encoding aarch64_float_arithmetic_mul_add_sub
        __instruction_set A64
        __field type1 22 +: 2
        __field o1 21 +: 1
        __field Rm 16 +: 5
        __field o0 15 +: 1
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011111 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer a = UInt(Ra);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean opa_neg = (o1 == '1');
            boolean op1_neg = (o0 != o1);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operanda = V[a];
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        if opa_neg then operanda = FPNeg(operanda);
        if op1_neg then operand1 = FPNeg(operand1);
        result = FPMulAdd(operanda, operand1, operand2, FPCR);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_pair
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_pair
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 1010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        integer element1;
        integer element2;
        integer maxmin;
        
        for e = 0 to elements-1
            element1 = Int(Elem[concat, 2*e, esize], unsigned);
            element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
            maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
            Elem[result, e, esize] = maxmin<esize-1:0>;
        
        V[d] = result;

__instruction UQDECD_R.RS_UW
    __encoding UQDECD_R.RS_UW
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1110xxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 32;

    __encoding UQDECD_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1111xxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction ST1D_Z.P.BZ_D.x32.scaled
    __encoding ST1D_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 101xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 3;

    __encoding ST1D_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 100xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding ST1D_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 101xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 3;

    __encoding ST1D_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 100xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(VL) offset = Z[m];
        bits(VL) src = Z[t];
        bits(PL) mask = P[g];
        bits(64) addr;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;

__instruction TRN1_Z.ZZ__
    __encoding TRN1_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx1xxxxx 011100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            integer part = 0;

    __encoding TRN2_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx1xxxxx 011101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);
            integer part = 1;

    __execute
        CheckSVEEnabled();
        integer pairs = VL DIV (esize * 2);
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for p = 0 to pairs-1
            Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];
            Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];
        
        Z[d] = result;

__instruction aarch64_vector_shift_right_sisd
    __encoding aarch64_vector_shift_right_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __encoding aarch64_vector_shift_right_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) operand2;
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        
        operand2 = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
            Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
        
        V[d] = result;

__instruction ST2H_Z.P.BR_Contiguous
    __encoding ST2H_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 101xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction STNT1W_Z.P.BI_Contiguous
    __encoding STNT1W_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 0001xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        constant integer mbytes = esize DIV 8;
        bits(VL) src;
        bits(PL) mask = P[g];
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        src = Z[t];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
            addr = addr + mbytes;

__instruction FADD_Z.P.ZS__
    __encoding FADD_Z.P.ZS__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field i1 5 +: 1
        __field Zdn 0 +: 5
        __opcode '01100101 xx011000 100xxx00 00xxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPAdd(element1, imm, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction SUB_Z.ZI__
    __encoding SUB_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field sh 13 +: 1
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx100001 11xxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size:sh == '001' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer imm = UInt(imm8);
            if sh == '1' then imm = imm << 8;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            Elem[result, e, esize] = element1 - imm;
        
        Z[dn] = result;

__instruction BRKB_P.P.P__
    __encoding BRKB_P.P.P__
        __instruction_set A64
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field M 4 +: 1
        __field Pd 0 +: 4
        __opcode '00100101 10010000 01xxxx0x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer d = UInt(Pd);
            boolean merging = (M == '1');
            boolean setflags = FALSE;

    __encoding BRKBS_P.P.P_Z
        __instruction_set A64
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 11010000 01xxxx0x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer d = UInt(Pd);
            boolean merging = FALSE;
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand  = P[n];
        bits(PL) operand2 = P[d];
        boolean break = FALSE;
        bits(PL) result;
        
        for e = 0 to elements-1
            boolean element = ElemP[operand, e, esize] == '1';
            if ElemP[mask, e, esize] == '1' then
                break = break || element;
                ElemP[result, e, esize] = if !break then '1' else '0';
            elsif merging then
                ElemP[result, e, esize] = ElemP[operand2, e, esize];
            else
                ElemP[result, e, esize] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_integer_arithmetic_cnt
    __encoding aarch64_integer_arithmetic_cnt
        __instruction_set A64
        __field sf 31 +: 1
        __field op 10 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x1011010 11000000 00010xxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            CountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;

    __execute
        integer result;
        bits(datasize) operand1 = X[n];
        
        if opcode == CountOp_CLZ then
            result = CountLeadingZeroBits(operand1);
        else
            result = CountLeadingSignBits(operand1);
        
        X[d] = result<datasize-1:0>;

__instruction SDOT_Z.ZZZi_S
    __encoding SDOT_Z.ZZZi_S
        __instruction_set A64
        __field i2 19 +: 2
        __field Zm 16 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01000100 101xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer index = UInt(i2);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);

    __encoding SDOT_Z.ZZZi_D
        __instruction_set A64
        __field i1 20 +: 1
        __field Zm 16 +: 4
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01000100 111xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer index = UInt(i1);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer eltspersegment = 128 DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer segmentbase = e - e MOD eltspersegment;
            integer s = segmentbase + index;
            bits(esize) res = Elem[operand3, e, esize];
            for i = 0 to 3
                integer element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                integer element2 = SInt(Elem[operand2, 4 * s + i, esize DIV 4]);
                res = res + element1 * element2;
            Elem[result, e, esize] = res;
        
        Z[da] = result;

__instruction aarch64_integer_conditional_select
    __encoding aarch64_integer_conditional_select
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field Rm 16 +: 5
        __field cond 12 +: 4
        __field o2 10 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xx011010 100xxxxx xxxx0xxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            bits(4) condition = cond;
            boolean else_inv = (op == '1');
            boolean else_inc = (o2 == '1');

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        
        if ConditionHolds(condition) then
            result = operand1;
        else
            result = operand2;
            if else_inv then result = NOT(result);
            if else_inc then result = result + 1;
        
        X[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_int_product
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_product
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 100111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if U == '1' && size != '00' then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean poly = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        bits(esize) product;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if poly then
                product = PolynomialMult(element1, element2)<esize-1:0>;
            else
                product = (UInt(element1) * UInt(element2))<esize-1:0>;
            Elem[result, e, esize] = product;
        
        V[d] = result;

__instruction aarch64_float_arithmetic_add_sub
    __encoding aarch64_float_arithmetic_add_sub
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx 001x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean sub_op = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        if sub_op then
            result = FPSub(operand1, operand2, FPCR);
        else
            result = FPAdd(operand1, operand2, FPCR);
        
        V[d] = result;

__instruction aarch64_float_move_fp_imm
    __encoding aarch64_float_move_fp_imm
        __instruction_set A64
        __field type1 22 +: 2
        __field imm8 13 +: 8
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx xxx10000 000xxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            bits(datasize) imm = VFPExpandImm(imm8);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        V[d] = imm;

__instruction LD1B_Z.P.BI_U8
    __encoding LD1B_Z.P.BI_U8
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0000xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LD1B_Z.P.BI_U16
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0010xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LD1B_Z.P.BI_U32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0100xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LD1B_Z.P.BI_U64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0110xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction FMINNMV_V.P.Z__
    __encoding FMINNMV_V.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '01100101 xx000101 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);

    __execute
        CheckSVEEnabled();
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(esize) identity = FPDefaultNaN();
        
        V[d] = ReducePredicated(ReduceOp_FMINNUM, operand, mask, identity);

__instruction FTSSEL_Z.ZZ__
    __encoding FTSSEL_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 101100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPTrigSSel(element1, element2);
        
        Z[d] = result;

__instruction aarch64_integer_ins_ext_insert_movewide
    __encoding aarch64_integer_ins_ext_insert_movewide
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field hw 21 +: 2
        __field imm16 5 +: 16
        __field Rd 0 +: 5
        __opcode 'xxx10010 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer datasize = if sf == '1' then 64 else 32;
            bits(16) imm = imm16;
            integer pos;
            MoveWideOp opcode;
            
            case opc of
                when '00' opcode = MoveWideOp_N;
                when '10' opcode = MoveWideOp_Z;
                when '11' opcode = MoveWideOp_K;
                otherwise UNDEFINED;
            
            if sf == '0' && hw<1> == '1' then UNDEFINED;
            pos = UInt(hw:'0000');

    __execute
        bits(datasize) result;
        
        if opcode == MoveWideOp_K then
            result = X[d];
        else
            result = Zeros();
        
        result<pos+15:pos> = imm;
        if opcode == MoveWideOp_N then
            result = NOT(result);
        X[d] = result;

__instruction BRKPA_P.P.PP__
    __encoding BRKPA_P.P.PP__
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0000xxxx 11xxxx0x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = FALSE;

    __encoding BRKPAS_P.P.PP__
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0100xxxx 11xxxx0x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        boolean last = (LastActive(mask, operand1, 8) == '1');
        
        for e = 0 to elements-1
            if ElemP[mask, e, 8] == '1' then
                ElemP[result, e, 8] = if last then '1' else '0';
                last = last && (ElemP[operand2, e, 8] == '0');
            else
                ElemP[result, e, 8] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_extract_nosat
    __encoding aarch64_vector_arithmetic_unary_extract_nosat
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx100001 001010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand = V[n];
        bits(datasize) result;
        bits(2*esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, 2*esize];
            Elem[result, e, esize] = element<esize-1:0>;
        Vpart[d, part] = result;

__instruction aarch64_vector_shift_left_sat_sisd
    __encoding aarch64_vector_shift_left_sat_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 011x01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = UInt(immh:immb) - esize;
            
            boolean src_unsigned;
            boolean dst_unsigned;
            case op:U of
                when '00' UNDEFINED;
                when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

    __encoding aarch64_vector_shift_left_sat_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 011x01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = UInt(immh:immb) - esize;
            
            boolean src_unsigned;
            boolean dst_unsigned;
            case op:U of
                when '00' UNDEFINED;
                when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) result;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = Int(Elem[operand, e, esize], src_unsigned) << shift;
            (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction LD1SB_Z.P.BI_S16
    __encoding LD1SB_Z.P.BI_S16
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1100xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __encoding LD1SB_Z.P.BI_S32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1010xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __encoding LD1SB_Z.P.BI_S64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1000xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_round
    __encoding aarch64_vector_arithmetic_unary_fp16_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __encoding aarch64_vector_arithmetic_unary_float_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
        
        V[d] = result;

__instruction aarch64_vector_transfer_vector_cpy_dup_sisd
    __encoding aarch64_vector_transfer_vector_cpy_dup_sisd
        __instruction_set A64
        __field imm5 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 000xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer size = LowestSetBit(imm5);
            if size > 3 then UNDEFINED;
            
            integer index = UInt(imm5<4:size+1>);
            integer idxdsize = if imm5<4> == '1' then 128 else 64; 
            
            integer esize = 8 << size;
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_transfer_vector_cpy_dup_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field imm5 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 000xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer size = LowestSetBit(imm5);
            if size > 3 then UNDEFINED;
            
            integer index = UInt(imm5<4:size+1>);
            integer idxdsize = if imm5<4> == '1' then 128 else 64; 
            
            if size == 3 && Q == '0' then UNDEFINED;
            integer esize = 8 << size;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(idxdsize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        element = Elem[operand, index, esize];
        for e = 0 to elements-1
            Elem[result, e, esize] = element;
        V[d] = result;

__instruction AND_Z.ZI__
    __encoding AND_Z.ZI__
        __instruction_set A64
        __field imm13 5 +: 13
        __field Zdn 0 +: 5
        __opcode '00000101 100000xx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer dn = UInt(Zdn);
            bits(64) imm;
            (imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV 64;
        bits(VL) operand = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(64) element1 = Elem[operand, e, 64];
            Elem[result, e, 64] = element1 AND imm;
        
        Z[dn] = result;

__instruction FMAXNMV_V.P.Z__
    __encoding FMAXNMV_V.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '01100101 xx000100 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);

    __execute
        CheckSVEEnabled();
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(esize) identity = FPDefaultNaN();
        
        V[d] = ReducePredicated(ReduceOp_FMAXNUM, operand, mask, identity);

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction SUNPKHI_Z.Z__
    __encoding SUNPKHI_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx110001 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean unsigned = FALSE;
            boolean hi = TRUE;

    __encoding SUNPKLO_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx110000 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            boolean unsigned = FALSE;
            boolean hi = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer hsize = esize DIV 2;
        bits(VL) operand = Z[n];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(hsize) element = if hi then Elem[operand, e + elements, hsize] else Elem[operand, e, hsize];
            Elem[result, e, esize] = Extend(element, esize, unsigned);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_add_fp_complex
    __encoding aarch64_vector_arithmetic_binary_uniform_add_fp_complex
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field rot 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx0xxxxx 111x01xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFCADDExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '00' then UNDEFINED;
            if Q == '0' && size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            if !HaveFP16Ext() && esize == 16 then UNDEFINED;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element3;
        
        for e = 0 to (elements DIV 2) -1 
            case rot of 
                when '0'
                    element1 = FPNeg(Elem[operand2, e*2+1, esize]); 
                    element3 = Elem[operand2, e*2, esize];
                when '1'
                    element1 = Elem[operand2, e*2+1, esize]; 
                    element3 = FPNeg(Elem[operand2, e*2, esize]);   
            Elem[result, e*2,   esize] = FPAdd(Elem[operand1, e*2, esize], element1, FPCR);
            Elem[result, e*2+1, esize] = FPAdd(Elem[operand1, e*2+1, esize], element3, FPCR);
        
        V[d] = result;

__instruction aarch64_vector_transfer_vector_permute_unzip
    __encoding aarch64_vector_transfer_vector_permute_unzip
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field op 14 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx0xxxxx 0x0110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            integer part = UInt(op);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operandl = V[n];
        bits(datasize) operandh = V[m];
        bits(datasize) result;
        
        bits(datasize*2) zipped = operandh:operandl;
        for e = 0 to elements-1
            Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];
        
        V[d] = result;

__instruction aarch64_integer_arithmetic_add_sub_immediate
    __encoding aarch64_integer_arithmetic_add_sub_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field sh 22 +: 1
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10001 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            bits(datasize) imm;
            
            case sh of
                when '0' imm = ZeroExtend(imm12, datasize);
                when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = if n == 31 then SP[] else X[n];
        bits(datasize) operand2 = imm;
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction LD4W_Z.P.BR_Contiguous
    __encoding LD4W_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 011xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction ST4D_Z.P.BI_Contiguous
    __encoding ST4D_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 1111xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer offset = SInt(imm4);
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction aarch64_memory_exclusive_pair
    __encoding aarch64_memory_exclusive_pair
        __instruction_set A64
        __field sz 30 +: 1
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '1x001000 0x1xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = TRUE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 32 << UInt(sz);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction LD3W_Z.P.BI_Contiguous
    __encoding LD3W_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0100xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer offset = SInt(imm4);
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction ST3D_Z.P.BR_Contiguous
    __encoding ST3D_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 110xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction aarch64_vector_arithmetic_unary_rev
    __encoding aarch64_vector_arithmetic_unary_rev
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 000x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            // size=esize:   B(0),  H(1),  S(1), D(S)
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            
            // op=REVx: 64(0), 32(1), 16(2)
            bits(2) op = o0:U; 
            
            // => op+size: 
            //    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X
            //    32+B = 1, 32+H = 2, 32+S = X, 32+D = X
            //    16+B = 2, 16+H = X, 16+S = X, 16+D = X
            //     8+B = X,  8+H = X,  8+S = X,  8+D = X
            // => 3-(op+size) (index bits in group)
            //    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X
            //    32+B = 2, 32+H = 1, 32+S = X, 32+D = X
            //    16+B = 1, 16+H = X, 16+S = X, 16+D = X
            //     8+B = X,  8+H = X,  8+S = X,  8+D = X
            
            // index bits within group: 1, 2, 3
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            
            integer containers = datasize DIV container_size;
            integer elements_per_container = container_size DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element = 0;
        integer rev_element;
        for c = 0 to containers-1
            rev_element = element + elements_per_container - 1;
            for e = 0 to elements_per_container-1
                Elem[result, rev_element, esize] = Elem[operand, element, esize];
                element = element + 1;
                rev_element = rev_element - 1;
        
        V[d] = result;

__instruction ST1B_Z.P.BR__
    __encoding ST1B_Z.P.BR__
        __instruction_set A64
        __field size 21 +: 2
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 0xxxxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8 << UInt(size);
            integer msize = 8;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        bits(VL) src = Z[t];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;
            offset = offset + 1;

__instruction DUPM_Z.I__
    __encoding DUPM_Z.I__
        __instruction_set A64
        __field imm13 5 +: 13
        __field Zd 0 +: 5
        __opcode '00000101 110000xx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer d = UInt(Zd);
            bits(esize) imm;
            (imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);

    __execute
        CheckSVEEnabled();
        bits(VL) result = Replicate(imm);
        Z[d] = result;

__instruction ST1B_Z.P.AI_S
    __encoding ST1B_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 011xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            integer offset = UInt(imm5);

    __encoding ST1B_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 010xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(VL) src = Z[t];
        bits(PL) mask = P[g];
        bits(64) addr;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;

__instruction DUP_Z.I__
    __encoding DUP_Z.I__
        __instruction_set A64
        __field size 22 +: 2
        __field sh 13 +: 1
        __field imm8 5 +: 8
        __field Zd 0 +: 5
        __opcode '00100101 xx111000 11xxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size:sh == '001' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer d = UInt(Zd);
            integer imm = SInt(imm8);
            if sh == '1' then imm = imm << 8;

    __execute
        CheckSVEEnabled();
        bits(VL) result = Replicate(imm<esize-1:0>);
        Z[d] = result;

__instruction aarch64_memory_pair_simdfp_post_idx
    __encoding aarch64_memory_pair_simdfp_post_idx
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101100 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = TRUE;
            boolean postindex = TRUE;

    __encoding aarch64_memory_pair_simdfp_pre_idx
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = TRUE;
            boolean postindex = FALSE;

    __encoding aarch64_memory_pair_simdfp_offset
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101101 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = FALSE;
            boolean postindex = FALSE;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer t2 = UInt(Rt2);
        AccType acctype = AccType_VEC;
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        if opc == '11' then UNDEFINED;
        integer scale = 2 + UInt(opc);
        integer datasize = 8 << scale;
        bits(64) offset = LSL(SignExtend(imm7, 64), scale);
        boolean tag_checked = wback || n != 31;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(datasize) data1;
        bits(datasize) data2;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                data1 = V[t];
                data2 = V[t2];
                Mem[address + 0     , dbytes, acctype] = data1;
                Mem[address + dbytes, dbytes, acctype] = data2;
        
            when MemOp_LOAD
                data1 = Mem[address + 0     , dbytes, acctype];
                data2 = Mem[address + dbytes, dbytes, acctype];
                if rt_unknown then
                    data1 = bits(datasize) UNKNOWN;
                    data2 = bits(datasize) UNKNOWN;
                V[t]  = data1;
                V[t2] = data2;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_binary_uniform_shift_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_shift_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');
            if S == '0' && size != '11' then UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_shift_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        integer round_const = 0;
        integer shift;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            shift = SInt(Elem[operand2, e, esize]<7:0>);
            if rounding then
                round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift 
            element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
            if saturating then
                (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                if sat then FPSR.QC = '1';
            else
                Elem[result, e, esize] = element<esize-1:0>;
        
        V[d] = result;

__instruction SQINCH_Z.ZS__
    __encoding SQINCH_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 0110xxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_unary_cmp_fp16_lessthan_sisd
    __encoding aarch64_vector_arithmetic_unary_cmp_fp16_lessthan_sisd
        __instruction_set A64
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 11111000 111010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison = CompareOp_LT;

    __encoding aarch64_vector_arithmetic_unary_cmp_float_lessthan_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 1x100000 111010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison = CompareOp_LT;

    __encoding aarch64_vector_arithmetic_unary_cmp_fp16_lessthan_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 11111000 111010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison = CompareOp_LT;

    __encoding aarch64_vector_arithmetic_unary_cmp_float_lessthan_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 1x100000 111010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison = CompareOp_LT;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) zero = FPZero('0');
        bits(esize) element;
        boolean test_passed;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            case comparison of
                when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
                when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
                when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
                when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
                when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_float_arithmetic_round_frint_32_64
    __encoding aarch64_float_arithmetic_round_frint_32_64
        __instruction_set A64
        __field type1 22 +: 2
        __field op 15 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx10100x x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFrintExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '1x' UNDEFINED;
            
            integer intsize = if op<1> == '0' then 32 else 64;
            
            FPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundIntN(operand, FPCR, rounding, intsize);
        
        V[d] = result;

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction SMIN_Z.ZI__
    __encoding SMIN_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx101010 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            boolean unsigned = FALSE;
            integer imm = Int(imm8, unsigned);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            Elem[result, e, esize] = Min(element1, imm)<esize-1:0>;
        
        Z[dn] = result;

__instruction aarch64_vector_reduce_add_long
    __encoding aarch64_vector_reduce_add_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx110000 001110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '100' then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        integer sum;
        
        sum = Int(Elem[operand, 0, esize], unsigned);
        for e = 1 to elements-1
            sum = sum + Int(Elem[operand, e, esize], unsigned);
        
        V[d] = sum<2*esize-1:0>;

__instruction aarch64_integer_arithmetic_add_sub_extendedreg
    __encoding aarch64_integer_arithmetic_add_sub_extendedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field Rm 16 +: 5
        __field option 13 +: 3
        __field imm3 10 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01011 001xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');
            ExtendType extend_type = DecodeRegExtend(option);       
            integer shift = UInt(imm3);
            if shift > 4 then UNDEFINED;

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = if n == 31 then SP[] else X[n];
        bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
        bits(4) nzcv;
        bit carry_in;
        
        if sub_op then
            operand2 = NOT(operand2);
            carry_in = '1';
        else
            carry_in = '0';
        
        (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
        __instruction_set A64
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011111 00xxxxxx 0x01x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64;
            integer index;
            index = UInt(H:L:M);
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            boolean sub_op = (o2 == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011111 1xxxxxxx 0x01x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi = M;
            case sz:L of
                when '0x' index = UInt(H:L);
                when '10' index = UInt(H);
                when '11' UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            boolean sub_op = (o2 == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 00xxxxxx 0x01x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64;
            integer index;
            index = UInt(H:L:M);
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean sub_op = (o2 == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 1xxxxxxx 0x01x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi = M;
            case sz:L of
                when '0x' index = UInt(H:L);
                when '10' index = UInt(H);
                when '11' UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean sub_op = (o2 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2 = Elem[operand2, index, esize];
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            if sub_op then element1 = FPNeg(element1);
            Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
        V[d] = result;

__instruction INCP_R.P.R__
    __encoding INCP_R.P.R__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Rdn 0 +: 5
        __opcode '00100101 xx101100 1000100x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) operand = X[dn];
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        X[dn] = operand + count;

__instruction aarch64_vector_crypto_sha3_xar
    __encoding aarch64_vector_crypto_sha3_xar
        __instruction_set A64
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 100xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSHA3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        bits(128) tmp;
        tmp = Vn EOR Vm; 
        V[d] = ROR(tmp<127:64>, UInt(imm6)):ROR(tmp<63:0>, UInt(imm6));

__instruction FCMLA_Z.P.ZZZ__
    __encoding FCMLA_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field rot 13 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100100 xx0xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            integer sel_a = UInt(rot<0>);
            integer sel_b = UInt(NOT(rot<0>));
            boolean neg_i = (rot<1> == '1');
            boolean neg_r = (rot<0> != rot<1>);

    __execute
        CheckSVEEnabled();
        integer pairs = VL DIV (2 * esize);
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for p = 0 to pairs-1
            addend_r = Elem[operand3, 2 * p + 0, esize];
            addend_i = Elem[operand3, 2 * p + 1, esize];
            elt1_a   = Elem[operand1, 2 * p + sel_a, esize];
            elt2_a   = Elem[operand2, 2 * p + sel_a, esize];
            elt2_b   = Elem[operand2, 2 * p + sel_b, esize];
            if ElemP[mask, 2 * p + 0, esize] == '1' then
                if neg_r then elt2_a = FPNeg(elt2_a);
                addend_r = FPMulAdd(addend_r, elt1_a, elt2_a, FPCR);
            if ElemP[mask, 2 * p + 1, esize] == '1' then
                if neg_i then elt2_b = FPNeg(elt2_b);
                addend_i = FPMulAdd(addend_i, elt1_a, elt2_b, FPCR);
            Elem[result, 2 * p + 0, esize] = addend_r;
            Elem[result, 2 * p + 1, esize] = addend_i;
        
        Z[da] = result;

__instruction aarch64_integer_tags_mcaddtag
    __encoding aarch64_integer_tags_mcaddtag
        __instruction_set A64
        __field uimm6 16 +: 6
        __field op3 14 +: 2
        __field uimm4 10 +: 4
        __field Xn 5 +: 5
        __field Xd 0 +: 5
        __opcode '10010001 10xxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Xd);
            integer n = UInt(Xn);
            bits(4) tag_offset = uimm4;
            bits(64) offset = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);
            boolean ADD = TRUE;

    __execute
        bits(64) operand1 = if n == 31 then SP[] else X[n];
        bits(4) start_tag = AllocationTagFromAddress(operand1);
        bits(16) exclude = GCR_EL1.Exclude;
        bits(64) result;
        bits(4) rtag;
        
        if AllocationTagAccessIsEnabled() then
            rtag = ChooseNonExcludedTag(start_tag, tag_offset, exclude);
        else
            rtag = '0000';
        
        if ADD then
            (result, -) = AddWithCarry(operand1, offset, '0');
        else
            (result, -) = AddWithCarry(operand1, NOT(offset), '1');
        
        result = AddressWithAllocationTag(result, rtag);
        
        if d == 31 then
            SP[] = result;
        else
            X[d] = result;

__instruction FNMSB_Z.P.ZZZ__
    __encoding FNMSB_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Za 16 +: 5
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx1xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            integer a = UInt(Za);
            boolean op1_neg = FALSE;
            boolean op3_neg = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[a];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            bits(esize) element3 = Elem[operand3, e, esize];
            
            if ElemP[mask, e, esize] == '1' then
                if op1_neg then element1 = FPNeg(element1);
                if op3_neg then element3 = FPNeg(element3);
                Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction LDNT1H_Z.P.BR_Contiguous
    __encoding LDNT1H_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 100xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(64) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = X[m];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_double_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_double_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011111 xxxxxxxx 1011x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;

    __encoding aarch64_vector_arithmetic_binary_element_mul_double_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 xxxxxxxx 1011x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize)   operand1 = Vpart[n, part];
        bits(idxdsize)   operand2 = V[m];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        boolean sat;
        
        element2 = SInt(Elem[operand2, index, esize]);
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);
            Elem[result, e, 2*esize] = product;
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_vector_shift_right_narrow_nonuniform_sisd
    __encoding aarch64_vector_shift_right_narrow_nonuniform_sisd
        __instruction_set A64
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111111 0xxxxxxx 1000x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then UNDEFINED;
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');

    __encoding aarch64_vector_shift_right_narrow_nonuniform_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 0xxxxxxx 1000x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize*2) operand = V[n];
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
            (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);
            if sat then FPSR.QC = '1';
        
        Vpart[d, part] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_int_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field eq 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 0011x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean cmp_eq = (eq == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field eq 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0011x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean cmp_eq = (eq == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 101101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' || size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean rounding = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 101101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' || size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean rounding = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer round_const = if rounding then 1 << (esize - 1) else 0;
        integer element1;
        integer element2;
        integer product;
        boolean sat;
        
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            element2 = SInt(Elem[operand2, e, esize]);
            product = (2 * element1 * element2) + round_const;
            (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_vector_reduce_int_max
    __encoding aarch64_vector_reduce_int_max
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 16 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx11000x 101010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '100' then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean min = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        integer maxmin;
        integer element;
        
        maxmin = Int(Elem[operand, 0, esize], unsigned);
        for e = 1 to elements-1
            element = Int(Elem[operand, e, esize], unsigned);
            maxmin = if min then Min(maxmin, element) else Max(maxmin, element);
        
        V[d] = maxmin<esize-1:0>;

__instruction aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 01111001 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPRounding_TIEAWAY;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 0x100001 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPRounding_TIEAWAY;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 01111001 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPRounding_TIEAWAY;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 0x100001 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPRounding_TIEAWAY;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_vector_reduce_int_max
    __encoding aarch64_vector_reduce_int_max
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 16 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx11000x 101010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '100' then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean min = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        integer maxmin;
        integer element;
        
        maxmin = Int(Elem[operand, 0, esize], unsigned);
        for e = 1 to elements-1
            element = Int(Elem[operand, e, esize], unsigned);
            maxmin = if min then Min(maxmin, element) else Max(maxmin, element);
        
        V[d] = maxmin<esize-1:0>;

__instruction LD4D_Z.P.BR_Contiguous
    __encoding LD4D_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 111xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction LDFF1H_Z.P.BZ_S.x32.scaled
    __encoding LDFF1H_Z.P.BZ_S.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 1x1xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 1;

    __encoding LDFF1H_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 1x1xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 1;

    __encoding LDFF1H_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 1x0xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1H_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 1x0xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1H_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 111xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 1;

    __encoding LDFF1H_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 110xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction ST4W_Z.P.BI_Contiguous
    __encoding ST4W_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 0111xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer offset = SInt(imm4);
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction LD3D_Z.P.BI_Contiguous
    __encoding LD3D_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1100xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer offset = SInt(imm4);
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction ST3W_Z.P.BR_Contiguous
    __encoding ST3W_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 010xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction aarch64_memory_pair_general_post_idx
    __encoding aarch64_memory_pair_general_post_idx
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101000 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = TRUE;
            boolean postindex = TRUE;

    __encoding aarch64_memory_pair_general_pre_idx
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101001 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = TRUE;
            boolean postindex = FALSE;

    __encoding aarch64_memory_pair_general_offset
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101001 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = FALSE;
            boolean postindex = FALSE;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer t2 = UInt(Rt2);
        AccType acctype = AccType_NORMAL;
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        if L:opc<0> == '01' || opc == '11' then UNDEFINED;
        boolean signed = (opc<0> != '0');
        integer scale = 2 + UInt(opc<1>);
        integer datasize = 8 << scale;
        bits(64) offset = LSL(SignExtend(imm7, 64), scale);
        boolean tag_checked = wback || n != 31;
    __execute
        bits(64) address;
        bits(datasize) data1;
        bits(datasize) data2;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        boolean wb_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then
            Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then
            Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_LOAD && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown && t == n then
                    data1 = bits(datasize) UNKNOWN;
                else
                    data1 = X[t];
                if rt_unknown && t2 == n then
                    data2 = bits(datasize) UNKNOWN;
                else
                    data2 = X[t2];
                Mem[address + 0     , dbytes, acctype] = data1;
                Mem[address + dbytes, dbytes, acctype] = data2;
        
            when MemOp_LOAD
                data1 = Mem[address + 0     , dbytes, acctype];
                data2 = Mem[address + dbytes, dbytes, acctype];
                if rt_unknown then
                    data1 = bits(datasize) UNKNOWN;
                    data2 = bits(datasize) UNKNOWN;
                if signed then
                    X[t]  = SignExtend(data1, 64);
                    X[t2] = SignExtend(data2, 64);
                else
                    X[t]  = data1;
                    X[t2] = data2;
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction ASR_Z.P.ZZ__
    __encoding ASR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010000 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            integer element2 = UInt(Elem[operand2, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = ASR(element1, element2);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction ANDV_R.P.Z__
    __encoding ANDV_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000100 xx011010 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(esize) result = Ones(esize);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                result = result AND Elem[operand, e, esize];
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 001101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            if pair then
                element1 = Elem[concat, 2*e, esize];
                element2 = Elem[concat, (2*e)+1, esize];
            else
                element1 = Elem[operand1, e, esize];
                element2 = Elem[operand2, e, esize];
        
            if minimum then
                Elem[result, e, esize] = FPMin(element1, element2, FPCR);
            else
                Elem[result, e, esize] = FPMax(element1, element2, FPCR);
        
        V[d] = result;

__instruction WHILELS_P.P.RR__
    __encoding WHILELS_P.P.RR__
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field sf 12 +: 1
        __field Rn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx1xxxxx 000x11xx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer rsize = 32 << UInt(sf);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer d = UInt(Pd);
            boolean unsigned = TRUE;
            SVECmp op = Cmp_LE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = Ones(PL);
        bits(rsize) operand1 = X[n];
        bits(rsize) operand2 = X[m];
        bits(PL) result;
        boolean last = TRUE;
        
        for e = 0 to elements-1
            boolean cond;
            case op of
                when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));
                when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));
        
            last = last && cond;
            ElemP[result, e, esize] = if last then '1' else '0';
            operand1 = operand1 + 1;
        
        PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_integer_conditional_select
    __encoding aarch64_integer_conditional_select
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field Rm 16 +: 5
        __field cond 12 +: 4
        __field o2 10 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xx011010 100xxxxx xxxx0xxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            bits(4) condition = cond;
            boolean else_inv = (op == '1');
            boolean else_inc = (o2 == '1');

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        
        if ConditionHolds(condition) then
            result = operand1;
        else
            result = operand2;
            if else_inv then result = NOT(result);
            if else_inc then result = result + 1;
        
        X[d] = result;

__instruction PRFB_I.P.AI_S
    __encoding PRFB_I.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000100 000xxxxx 111xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 0;
            integer offset = UInt(imm5);

    __encoding PRFB_I.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000100 000xxxxx 111xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 0;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) base;
        bits(64) addr;
        base = Z[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);

__instruction PRFB_I.P.BR_S
    __encoding PRFB_I.P.BR_S
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000100 000xxxxx 110xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) offset = X[m];
        bits(64) addr;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + (UInt(offset) << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);
            offset = offset + 1;

__instruction aarch64_integer_arithmetic_div
    __encoding aarch64_integer_arithmetic_div
        __instruction_set A64
        __field sf 31 +: 1
        __field Rm 16 +: 5
        __field o1 10 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011010 110xxxxx 00001xxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean unsigned = (o1 == '0');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        integer result;
        
        if IsZero(operand2) then
            result = 0;
        else
            result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));
        
        X[d] = result<datasize-1:0>;

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_float_round_frint_32_64
    __encoding aarch64_vector_arithmetic_unary_float_round_frint_32_64
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 0x100001 111x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFrintExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            integer intsize = if op == '0' then 32 else 64; 
            FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_add_pairwise
    __encoding aarch64_vector_arithmetic_unary_add_pairwise
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 14 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 0x1010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV (2*esize);
            boolean acc = (op == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        
        bits(2*esize) sum;
        integer op1;
        integer op2;
        
        result = if acc then V[d] else Zeros();
        for e = 0 to elements-1
            op1 = Int(Elem[operand, 2*e+0, esize], unsigned);
            op2 = Int(Elem[operand, 2*e+1, esize], unsigned);
            sum = (op1 + op2)<2*esize-1:0>;
            Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;
        
        V[d] = result;

__instruction LD1RQH_Z.P.BI_U16
    __encoding LD1RQH_Z.P.BI_U16
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1000xxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = 128 DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g]; // low 16 bits only
        bits(128) result;
        constant integer mbytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * 16;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = Replicate(result, VL DIV 128);

__instruction aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
    __encoding aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
        __instruction_set A64
        __field Q 30 +: 1
        __field opc2 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx1xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            VBitOp op;
            
            case opc2 of
                when '00' op = VBitOp_VEOR;
                when '01' op = VBitOp_VBSL;
                when '10' op = VBitOp_VBIT;
                when '11' op = VBitOp_VBIF;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1;
        bits(datasize) operand2;
        bits(datasize) operand3;
        bits(datasize) operand4 = V[n];
        
        case op of
            when VBitOp_VEOR
                operand1 = V[m];
                operand2 = Zeros();
                operand3 = Ones();
            when VBitOp_VBSL
                operand1 = V[m];
                operand2 = operand1;
                operand3 = V[d];
            when VBitOp_VBIT
                operand1 = V[d];
                operand2 = operand1;
                operand3 = V[m];
            when VBitOp_VBIF
                operand1 = V[d];
                operand2 = operand1;
                operand3 = NOT(V[m]);
        
        V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);

__instruction aarch64_vector_crypto_sm3_sm3tt1a
    __encoding aarch64_vector_crypto_sm3_sm3tt1a
        __instruction_set A64
        __field Rm 16 +: 5
        __field imm2 12 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 010xxxxx 10xx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSM3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer i = UInt(imm2);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        bits(128) Vd = V[d];
        bits(32) WjPrime;
        bits(128) result; 
        bits(32) TT1;
        bits(32) SS2;
        
        WjPrime = Elem[Vm,i,32];
        SS2 = Vn<127:96> EOR ROL(Vd<127:96>,12); 
        TT1 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);
        TT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>;
        result<31:0> = Vd<63:32>;
        result<63:32> = ROL(Vd<95:64>,9); 
        result<95:64> = Vd<127:96>; 
        result<127:96> = TT1; 
        V[d] = result;

__instruction FMLA_Z.ZZZi_H
    __encoding FMLA_Z.ZZZi_H
        __instruction_set A64
        __field i3h 22 +: 1
        __field i3l 19 +: 2
        __field Zm 16 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100100 0x1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer index = UInt(i3h:i3l);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean op1_neg = FALSE;
            boolean op3_neg = FALSE;

    __encoding FMLA_Z.ZZZi_S
        __instruction_set A64
        __field i2 19 +: 2
        __field Zm 16 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100100 101xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer index = UInt(i2);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean op1_neg = FALSE;
            boolean op3_neg = FALSE;

    __encoding FMLA_Z.ZZZi_D
        __instruction_set A64
        __field i1 20 +: 1
        __field Zm 16 +: 4
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100100 111xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer index = UInt(i1);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean op1_neg = FALSE;
            boolean op3_neg = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer eltspersegment = 128 DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result = Z[da];
        
        for e = 0 to elements-1
            integer segmentbase = e - e MOD eltspersegment;
            integer s = segmentbase + index;
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, s, esize];
            bits(esize) element3 = Elem[result, e, esize];
            if op1_neg then element1 = FPNeg(element1);
            if op3_neg then element3 = FPNeg(element3);
            Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
        
        Z[da] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_long
    __encoding aarch64_vector_arithmetic_binary_element_mul_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 xxxxxxxx 1010x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(idxdsize)   operand2 = V[m];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        
        element2 = Int(Elem[operand2, index, esize], unsigned);
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            product = (element1 * element2)<2*esize-1:0>;
            Elem[result, e, 2*esize] = product;
        
        V[d] = result;

__instruction SETFFR_F__
    __encoding SETFFR_F__
        __instruction_set A64
        __opcode '00100101 00101100 10010000 00000000'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;

    __execute
        CheckSVEEnabled();
        FFR[] = Ones(PL);

__instruction aarch64_vector_reduce_add_sisd
    __encoding aarch64_vector_reduce_add_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 xx110001 101110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size != '11' then UNDEFINED;
            
            integer esize = 8 << UInt(size);
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = ReduceOp_ADD;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction aarch64_vector_arithmetic_binary_disparate_mul_accum
    __encoding aarch64_vector_arithmetic_binary_disparate_mul_accum
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 10x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        bits(2*esize) accum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            product = (element1 * element2)<2*esize-1:0>;
            if sub_op then
                accum = Elem[operand3, e, 2*esize] - product;
            else
                accum = Elem[operand3, e, 2*esize] + product;
            Elem[result, e, 2*esize] = accum;
        
        V[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_post_idx
    __encoding aarch64_memory_single_general_immediate_signed_post_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = TRUE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_signed_pre_idx
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx11xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = TRUE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __encoding aarch64_memory_single_general_immediate_unsigned
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm12 10 +: 12
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111001 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction UQINCW_R.RS_UW
    __encoding UQINCW_R.RS_UW
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1010xxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 32;

    __encoding UQINCW_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1011xxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction aarch64_vector_reduce_fp16_max_simd
    __encoding aarch64_vector_reduce_fp16_max_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field o1 23 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 x0110000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

    __encoding aarch64_vector_reduce_fp_max_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx110000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q != '01' then UNDEFINED;
            
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction SDIV_Z.P.ZZ__
    __encoding SDIV_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010100 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '0x' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer quotient;
                if element2 == 0 then
                    quotient = 0;
                else
                    quotient = RoundTowardsZero(Real(element1) / Real(element2));
                Elem[result, e, esize] = quotient<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_integer_tags_mcgettag
    __encoding aarch64_integer_tags_mcgettag
        __instruction_set A64
        __field imm9 12 +: 9
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 011xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Xt);
            integer n = UInt(Xn);
            bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);

    __execute
        bits(64) address;
        bits(4) tag;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        address = address + offset;
        address = Align(address, TAG_GRANULE);
        
        tag = MemTag[address];
        address = AddressWithAllocationTag(address, tag);
        
        X[t] = address;

__instruction UQINCP_R.P.R_UW
    __encoding UQINCP_R.P.R_UW
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Rdn 0 +: 5
        __opcode '00100101 xx101001 1000100x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);
            boolean unsigned = TRUE;
            integer ssize = 32;

    __encoding UQINCP_R.P.R_X
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Rdn 0 +: 5
        __opcode '00100101 xx101001 1000110x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);
            boolean unsigned = TRUE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(ssize) operand = X[dn];
        bits(ssize) result;
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        integer element = Int(operand, unsigned);
        (result, -) = SatQ(element + count, ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction PRFW_I.P.BZ_S.x32.scaled
    __encoding PRFW_I.P.BZ_S.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000100 0x1xxxxx 010xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 32;
            boolean offs_unsigned = (xs == '0');
            integer scale = 2;

    __encoding PRFW_I.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000100 0x1xxxxx 010xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 32;
            boolean offs_unsigned = (xs == '0');
            integer scale = 2;

    __encoding PRFW_I.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000100 011xxxxx 110xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);

__instruction aarch64_float_convert_fix
    __encoding aarch64_float_convert_fix
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field scale 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            
            case type1 of
                when '00' fltsize = 32;
                when '01' fltsize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            if sf == '0' && scale<5> == '0' then UNDEFINED;
            integer fracbits = 64 - UInt(scale);
            
            case opcode<2:1>:rmode of
                when '00 11'        // FCVTZ
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                otherwise
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
                V[d] = fltval;

__instruction aarch64_memory_single_general_immediate_signed_offset_normal
    __encoding aarch64_memory_single_general_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_integer_arithmetic_add_sub_carry
    __encoding aarch64_integer_arithmetic_add_sub_carry
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx11010 000xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(4) nzcv;
        
        if sub_op then
            operand2 = NOT(operand2);
        
        (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        X[d] = result;

__instruction ORR_Z.P.ZZ__
    __encoding ORR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx011000 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = element1 OR element2;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction ST1W_Z.P.BZ_S.x32.scaled
    __encoding ST1W_Z.P.BZ_S.x32.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 011xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 2;

    __encoding ST1W_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 001xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 2;

    __encoding ST1W_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 000xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding ST1W_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field xs 14 +: 1
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 010xxxxx 1x0xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            integer offs_size = 32;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding ST1W_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 001xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 2;

    __encoding ST1W_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 000xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            integer offs_size = 64;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(VL) offset = Z[m];
        bits(VL) src = Z[t];
        bits(PL) mask = P[g];
        bits(64) addr;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;

__instruction aarch64_memory_atomicops_cas_single
    __encoding aarch64_memory_atomicops_cas_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x1xxxxx x11111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) comparevalue;
        bits(datasize) newvalue;
        bits(datasize) data;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        comparevalue = X[s];
        newvalue = X[t];
        
        if n == 31 then 
            CheckSPAlignment(); 
            address = SP[];
        else 
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data = Mem[address, datasize DIV 8, ldacctype];
        if data == comparevalue then  
            Mem[address, datasize DIV 8, stacctype] = newvalue;
        
        X[s] = ZeroExtend(data, regsize);

__instruction LDFF1SH_Z.P.BZ_S.x32.scaled
    __encoding LDFF1SH_Z.P.BZ_S.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 1x1xxxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 1;

    __encoding LDFF1SH_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 1x1xxxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 1;

    __encoding LDFF1SH_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 1x0xxxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1SH_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 1x0xxxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1SH_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 111xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 64;
            boolean unsigned = FALSE;
            boolean offs_unsigned = TRUE;
            integer scale = 1;

    __encoding LDFF1SH_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 110xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 64;
            boolean unsigned = FALSE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction aarch64_float_arithmetic_round_frint
    __encoding aarch64_float_arithmetic_round_frint
        __instruction_set A64
        __field type1 22 +: 2
        __field rmode 15 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1001xx x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case rmode of
                when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundInt(operand, FPCR, rounding, exact);
        
        V[d] = result;

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction aarch64_integer_arithmetic_cnt
    __encoding aarch64_integer_arithmetic_cnt
        __instruction_set A64
        __field sf 31 +: 1
        __field op 10 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x1011010 11000000 00010xxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            CountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;

    __execute
        integer result;
        bits(datasize) operand1 = X[n];
        
        if opcode == CountOp_CLZ then
            result = CountLeadingZeroBits(operand1);
        else
            result = CountLeadingSignBits(operand1);
        
        X[d] = result<datasize-1:0>;

__instruction LD2H_Z.P.BI_Contiguous
    __encoding LD2H_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1010xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer offset = SInt(imm4);
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field a 23 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (a == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            if pair then
                element1 = Elem[concat, 2*e, esize];
                element2 = Elem[concat, (2*e)+1, esize];
            else
                element1 = Elem[operand1, e, esize];
                element2 = Elem[operand2, e, esize];
        
            if minimum then
                Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
            else
                Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);
        
        V[d] = result;

__instruction aarch64_vector_transfer_vector_table
    __encoding aarch64_vector_transfer_vector_table
        __instruction_set A64
        __field Q 30 +: 1
        __field Rm 16 +: 5
        __field len 13 +: 2
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 000xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV 8;
            integer regs = UInt(len) + 1;
            boolean is_tbl = (op == '0');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) indices = V[m];
        bits(128*regs) table = Zeros();
        bits(datasize) result;
        integer index;
        
        // Create table from registers
        for i = 0 to regs - 1
            table<128*i+127:128*i> = V[n];
            n = (n + 1) MOD 32;
        
        result = if is_tbl then Zeros() else V[d];
        for i = 0 to elements - 1
            index = UInt(Elem[indices, i, 8]);
            if index < 16 * regs then
                Elem[result, i, 8] = Elem[table, index, 8];
        
        V[d] = result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction STNT1D_Z.P.BI_Contiguous
    __encoding STNT1D_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 1001xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        constant integer mbytes = esize DIV 8;
        bits(VL) src;
        bits(PL) mask = P[g];
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        src = Z[t];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
            addr = addr + mbytes;

__instruction aarch64_vector_crypto_sha3op_sha1_sched0
    __encoding aarch64_vector_crypto_sha3op_sha1_sched0
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 000xxxxx 001100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if !HaveSHA1Ext() then UNDEFINED;

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) operand1 = V[d];
        bits(128) operand2 = V[n];
        bits(128) operand3 = V[m];
        bits(128) result;
        
        result = operand2<63:0> : operand1<127:64>;
        result = result EOR operand1 EOR operand3;
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_float_round_frint_32_64
    __encoding aarch64_vector_arithmetic_unary_float_round_frint_32_64
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 0x100001 111x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFrintExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            integer intsize = if op == '0' then 32 else 64; 
            FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);
        
        V[d] = result;

__instruction aarch64_integer_tags_mcsettagarray
    __encoding aarch64_integer_tags_mcsettagarray
        __instruction_set A64
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 10100000 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Xt);
            integer n = UInt(Xn);

    __execute
        bits(64) data = X[t];
        bits(64) address;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // address<63:LOG2_TAG_GRANULE+4>:Zeros(LOG2_TAG_GRANULE+4) <= start <= address
        // 0 < count <= 16-start<LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE>
        integer count;
        (address, count) = ImpDefTagArrayStartAndCount(address);
        
        for i = 0 to count-1
            integer index = UInt(address<LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE>);
            bits(4) tag = data<(index*4)+3:index*4>;
            MemTag[address] = tag;
            address = address + TAG_GRANULE;
        
        if n == 31 then
            SP[] = address;
        else
            X[n] = address;

__instruction aarch64_vector_reduce_fp16_max_simd
    __encoding aarch64_vector_reduce_fp16_max_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field o1 23 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 x0110000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

    __encoding aarch64_vector_reduce_fp_max_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx110000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q != '01' then UNDEFINED;
            
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_long
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 00x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        integer sum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            Elem[result, e, 2*esize] = sum<2*esize-1:0>;
        
        V[d] = result;

__instruction aarch64_vector_transfer_integer_insert
    __encoding aarch64_vector_transfer_integer_insert
        __instruction_set A64
        __field imm5 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01001110 000xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer size = LowestSetBit(imm5);
            
            if size > 3 then UNDEFINED;
            integer index = UInt(imm5<4:size+1>);
            
            integer esize = 8 << size;
            integer datasize = 128;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(esize) element = X[n];
        bits(datasize) result;
        
        result = V[d];
        Elem[result, index, esize] = element;
        V[d] = result;

__instruction SMAXV_R.P.Z__
    __encoding SMAXV_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000100 xx001000 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        integer maximum = if unsigned then 0 else -(2^(esize-1));
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer element = Int(Elem[operand, e, esize], unsigned);
                maximum = Max(maximum, element);
        
        V[d] = maximum<esize-1:0>;

__instruction CPY_Z.P.R__
    __encoding CPY_Z.P.R__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx101000 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) operand1;
        if n == 31 then
            operand1 = SP[];
        else
            operand1 = X[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = operand1<esize-1:0>;
        
        Z[d] = result;

__instruction LSL_Z.P.ZZ__
    __encoding LSL_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010011 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            integer element2 = UInt(Elem[operand2, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = LSL(element1, element2);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags
    __encoding aarch64_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags
        __instruction_set A64
        __field Xm 16 +: 5
        __field Xn 5 +: 5
        __field Xd 0 +: 5
        __opcode '10111010 110xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Xd);
            integer n = UInt(Xn);
            integer m = UInt(Xm);
            boolean setflags = TRUE;

    __execute
        bits(64) operand1 = if n == 31 then SP[] else X[n];
        bits(64) operand2 = if m == 31 then SP[] else X[m];
        operand1 = SignExtend(operand1<55:0>, 64);
        operand2 = SignExtend(operand2<55:0>, 64);
        
        bits(64) result;
        bits(4) nzcv;
        
        operand2 = NOT(operand2);
        (result, nzcv) = AddWithCarry(operand1, operand2, '1');
        
        if setflags then
            PSTATE.<N,Z,C,V> = nzcv;
        X[d] = result;

__instruction aarch64_integer_arithmetic_mul_widening_32_64
    __encoding aarch64_integer_arithmetic_mul_widening_32_64
        __instruction_set A64
        __field U 23 +: 1
        __field Rm 16 +: 5
        __field o0 15 +: 1
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '10011011 x01xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer a = UInt(Ra);
            integer destsize = 64;
            integer datasize = 32;
            boolean sub_op = (o0 == '1');
            boolean unsigned = (U == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(destsize) operand3 = X[a];
        
        integer result;
        
        if sub_op then
            result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));
        else
            result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));
        
        X[d] = result<63:0>;

__instruction LD1H_Z.P.BI_U16
    __encoding LD1H_Z.P.BI_U16
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1010xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LD1H_Z.P.BI_U32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1100xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __encoding LD1H_Z.P.BI_U64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1110xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = TRUE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction aarch64_integer_arithmetic_rbit
    __encoding aarch64_integer_arithmetic_rbit
        __instruction_set A64
        __field sf 31 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x1011010 11000000 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize = if sf == '1' then 64 else 32;

    __execute
        bits(datasize) operand = X[n];
        bits(datasize) result;
        
        for i = 0 to datasize-1
            result<datasize-1-i> = operand<i>;
        
        X[d] = result;

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction FMIN_Z.P.ZZ__
    __encoding FMIN_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx000111 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMin(element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_bitwise_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_bitwise_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 100011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean and_test = (U == '0');

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_bitwise_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 100011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean and_test = (U == '0');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if and_test then
                test_passed = !IsZero(element1 AND element2);
            else
                test_passed = (element1 == element2);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction UZP1_P.PP__
    __encoding UZP1_P.PP__
        __instruction_set A64
        __field size 22 +: 2
        __field Pm 16 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00000101 xx10xxxx 0100100x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            integer part = 0;

    __encoding UZP2_P.PP__
        __instruction_set A64
        __field size 22 +: 2
        __field Pm 16 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00000101 xx10xxxx 0100110x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            integer part = 1;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        bits(PL*2) zipped = operand2:operand1;
        for e = 0 to elements-1
            Elem[result, e, esize DIV 8] = Elem[zipped, 2*e+part, esize DIV 8];
        
        P[d] = result;

__instruction aarch64_vector_arithmetic_unary_special_sqrt_est_int
    __encoding aarch64_vector_arithmetic_unary_special_sqrt_est_int
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 1x100001 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz == '1' then UNDEFINED;
            integer esize = 32;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(32) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, 32];
            Elem[result, e, 32] = UnsignedRSqrtEstimate(element);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_rev
    __encoding aarch64_vector_arithmetic_unary_rev
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 000x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            // size=esize:   B(0),  H(1),  S(1), D(S)
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            
            // op=REVx: 64(0), 32(1), 16(2)
            bits(2) op = o0:U; 
            
            // => op+size: 
            //    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X
            //    32+B = 1, 32+H = 2, 32+S = X, 32+D = X
            //    16+B = 2, 16+H = X, 16+S = X, 16+D = X
            //     8+B = X,  8+H = X,  8+S = X,  8+D = X
            // => 3-(op+size) (index bits in group)
            //    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X
            //    32+B = 2, 32+H = 1, 32+S = X, 32+D = X
            //    16+B = 1, 16+H = X, 16+S = X, 16+D = X
            //     8+B = X,  8+H = X,  8+S = X,  8+D = X
            
            // index bits within group: 1, 2, 3
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            
            integer containers = datasize DIV container_size;
            integer elements_per_container = container_size DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element = 0;
        integer rev_element;
        for c = 0 to containers-1
            rev_element = element + elements_per_container - 1;
            for e = 0 to elements_per_container-1
                Elem[result, rev_element, esize] = Elem[operand, element, esize];
                element = element + 1;
                rev_element = rev_element - 1;
        
        V[d] = result;

__instruction UQDECB_R.RS_UW
    __encoding UQDECB_R.RS_UW
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0010xxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 32;

    __encoding UQDECB_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0011xxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction aarch64_vector_shift_right_narrow_logical
    __encoding aarch64_vector_shift_right_narrow_logical
        __instruction_set A64
        __field Q 30 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field op 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 0xxxxxxx 1000x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3> == '1' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            integer shift = (2 * esize) - UInt(immh:immb);
            boolean round = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize*2) operand = V[n];
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        
        for e = 0 to elements-1
            element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
            Elem[result, e, esize] = element<esize-1:0>;
        
        Vpart[d, part] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
        __instruction_set A64
        __field Q 30 +: 1
        __field a 23 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 x10xxxxx 000011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (a == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
        __instruction_set A64
        __field Q 30 +: 1
        __field op 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 110011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if sub_op then element1 = FPNeg(element1);
            Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
        
        V[d] = result;

__instruction SQINCD_Z.ZS__
    __encoding SQINCD_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1110xxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction aarch64_vector_crypto_sm3_sm3ss1
    __encoding aarch64_vector_crypto_sm3_sm3ss1
        __instruction_set A64
        __field Rm 16 +: 5
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 010xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSM3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer a = UInt(Ra);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        bits(128) Vd = V[d];
        bits(128) Va = V[a];
        Vd<127:96> = ROL((ROL(Vn<127:96>,12) + Vm<127:96> + Va<127:96>) , 7);
        Vd<95:0> = Zeros();
        V[d] = Vd;

__instruction aarch64_vector_crypto_sm3_sm3tt1b
    __encoding aarch64_vector_crypto_sm3_sm3tt1b
        __instruction_set A64
        __field Rm 16 +: 5
        __field imm2 12 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 010xxxxx 10xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSM3Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer i = UInt(imm2);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vm = V[m];
        bits(128) Vn = V[n];
        bits(128) Vd = V[d];
        bits(32) WjPrime;
        bits(128) result; 
        bits(32) TT1;
        bits(32) SS2;
        
        WjPrime = Elem[Vm,i,32];
        SS2 = Vn<127:96> EOR ROL(Vd<127:96>,12); 
        TT1 = (Vd<127:96> AND Vd<63:32>) OR (Vd<127:96> AND Vd<95:64>) OR (Vd<63:32> AND Vd<95:64>); 
        TT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>;
        result<31:0> = Vd<63:32>;
        result<63:32> = ROL(Vd<95:64>,9); 
        result<95:64> = Vd<127:96>; 
        result<127:96> = TT1; 
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_high_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_high_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field op 12 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011111 xxxxxxxx 110xx0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            
            boolean round = (op == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_high_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field op 12 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 xxxxxxxx 110xx0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean round = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) result;
        integer round_const = if round then 1 << (esize - 1) else 0;
        integer element1;
        integer element2;
        integer product;
        boolean sat;
        
        element2 = SInt(Elem[operand2, index, esize]);
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            product = (2 * element1 * element2) + round_const;
            // The following only saturates if element1 and element2 equal -(2^(esize-1))
            (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 01111001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 0x100001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 01111001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 0x100001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        FPRounding rounding = FPRoundingMode(FPCR);
        bits(esize) element;
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
    __encoding aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 xx1xxxxx 110100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '00' || size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;

    __encoding aarch64_vector_arithmetic_binary_disparate_mul_double_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 110100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '00' || size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        boolean sat;
        
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            element2 = SInt(Elem[operand2, e, esize]);
            (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);
            Elem[result, e, 2*esize] = product;
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_add_halving_truncating
    __encoding aarch64_vector_arithmetic_binary_uniform_add_halving_truncating
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer sum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            sum = element1 + element2;
            Elem[result, e, esize] = sum<esize:1>;
        
        V[d] = result;

__instruction aarch64_float_arithmetic_mul_product
    __encoding aarch64_float_arithmetic_mul_product
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field op 15 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx x00010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean negated = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        result = FPMul(operand1, operand2, FPCR);
        
        if negated then result = FPNeg(result);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_add_wrapping_pair
    __encoding aarch64_vector_arithmetic_binary_uniform_add_wrapping_pair
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 101111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[concat, 2*e, esize];
            element2 = Elem[concat, (2*e)+1, esize];
            Elem[result, e, esize] = element1 + element2;
        
        V[d] = result;

__instruction LD1SH_Z.P.BI_S32
    __encoding LD1SH_Z.P.BI_S32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0010xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __encoding LD1SH_Z.P.BI_S64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0000xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction aarch64_float_arithmetic_unary
    __encoding aarch64_float_arithmetic_unary
        __instruction_set A64
        __field type1 22 +: 2
        __field opc 15 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx10000x x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            FPUnaryOp fpop;
            case opc of
                when '00' fpop = FPUnaryOp_MOV;
                when '01' fpop = FPUnaryOp_ABS;
                when '10' fpop = FPUnaryOp_NEG;
                when '11' fpop = FPUnaryOp_SQRT;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        case fpop of
            when FPUnaryOp_MOV  result = operand;
            when FPUnaryOp_ABS  result = FPAbs(operand);
            when FPUnaryOp_NEG  result = FPNeg(operand);
            when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);
        
        V[d] = result;

__instruction aarch64_integer_pac_pacda_dp_1src
    __encoding aarch64_integer_pac_pacda_dp_1src
        __instruction_set A64
        __field Z 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11011010 11000001 00x010xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean source_is_sp = FALSE;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if !HavePACExt() then
                UNDEFINED;
            
            if Z == '0' then // PACDA
                if n == 31 then source_is_sp = TRUE;
            else // PACDZA
                if n != 31 then UNDEFINED;

    __execute
        if source_is_sp then
            X[d] = AddPACDA(X[d], SP[]);
        else
            X[d] = AddPACDA(X[d], X[n]);

__instruction aarch64_memory_pair_simdfp_no_alloc
    __encoding aarch64_memory_pair_simdfp_no_alloc
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101100 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = FALSE;
            boolean postindex = FALSE;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer t2 = UInt(Rt2);
        AccType acctype = AccType_VECSTREAM;
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        if opc == '11' then UNDEFINED;
        integer scale = 2 + UInt(opc);
        integer datasize = 8 << scale;
        bits(64) offset = LSL(SignExtend(imm7, 64), scale);
        boolean tag_checked = wback || n != 31;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(datasize) data1;
        bits(datasize) data2;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                data1 = V[t];
                data2 = V[t2];
                Mem[address + 0     , dbytes, acctype] = data1;
                Mem[address + dbytes, dbytes, acctype] = data2;
        
            when MemOp_LOAD
                data1 = Mem[address + 0     , dbytes, acctype];
                data2 = Mem[address + dbytes, dbytes, acctype];
                if rt_unknown then
                    data1 = bits(datasize) UNKNOWN;
                    data2 = bits(datasize) UNKNOWN;
                V[t]  = data1;
                V[t2] = data2;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction LDFF1D_Z.P.BR_U64
    __encoding LDFF1D_Z.P.BR_U64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 111xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + UInt(offset) * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            offset = offset + 1;
        
        Z[t] = result;

__instruction LDFF1D_Z.P.AI_D
    __encoding LDFF1D_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 101xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction aarch64_integer_arithmetic_mul_uniform_add_sub
    __encoding aarch64_integer_arithmetic_mul_uniform_add_sub
        __instruction_set A64
        __field sf 31 +: 1
        __field Rm 16 +: 5
        __field o0 15 +: 1
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011011 000xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer a = UInt(Ra);
            integer destsize = if sf == '1' then 64 else 32;
            integer datasize = destsize;
            boolean sub_op = (o0 == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(destsize) operand3 = X[a];
        
        integer result;
        
        if sub_op then
            result = UInt(operand3) - (UInt(operand1) * UInt(operand2));
        else
            result = UInt(operand3) + (UInt(operand1) * UInt(operand2));
        
        X[d] = result<destsize-1:0>;

__instruction aarch64_vector_reduce_fp16_max_sisd
    __encoding aarch64_vector_reduce_fp16_max_sisd
        __instruction_set A64
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 xx110000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            if sz == '1' then UNDEFINED;
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

    __encoding aarch64_vector_reduce_fp_max_sisd
        __instruction_set A64
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 xx110000 111110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction aarch64_integer_flags_rmif
    __encoding aarch64_integer_flags_rmif
        __instruction_set A64
        __field sf 31 +: 1
        __field imm6 15 +: 6
        __field Rn 5 +: 5
        __field mask 0 +: 4
        __opcode 'x0111010 000xxxxx x00001xx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveFlagManipulateExt() || sf != '1' then UNDEFINED;
            integer lsb = UInt(imm6);
            integer n = UInt(Rn);

    __execute
        bits(4) tmp;
        bits(64) tmpreg = X[n];
        tmp = (tmpreg:tmpreg)<lsb+3:lsb>;
        if mask<3> == '1' then PSTATE.N = tmp<3>;
        if mask<2> == '1' then PSTATE.Z = tmp<2>;
        if mask<1> == '1' then PSTATE.C = tmp<1>;
        if mask<0> == '1' then PSTATE.V = tmp<0>;

__instruction aarch64_integer_arithmetic_rev
    __encoding aarch64_integer_arithmetic_rev
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 10 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x1011010 11000000 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize = if sf == '1' then 64 else 32;
            
            integer container_size;
            case opc of
                when '00'
                    Unreachable();
                when '01'
                    container_size = 16;
                when '10'
                    container_size = 32;
                when '11'
                    if sf == '0' then UNDEFINED;
                    container_size = 64;

    __execute
        bits(datasize) operand = X[n];
        bits(datasize) result;
        
        integer containers = datasize DIV container_size;
        integer elements_per_container = container_size DIV 8;
        integer index = 0;
        integer rev_index;
        for c = 0 to containers-1
            rev_index = index + ((elements_per_container - 1) * 8);
            for e = 0 to elements_per_container-1
                result<rev_index + 7:rev_index> = operand<index + 7:index>;
                index = index + 8;
                rev_index = rev_index - 8;
        
        X[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_shift_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_shift_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');
            if S == '0' && size != '11' then UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_shift_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        integer round_const = 0;
        integer shift;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            shift = SInt(Elem[operand2, e, esize]<7:0>);
            if rounding then
                round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift 
            element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
            if saturating then
                (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                if sat then FPSR.QC = '1';
            else
                Elem[result, e, esize] = element<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_integer_logical_shiftedreg
    __encoding aarch64_integer_logical_shiftedreg
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field shift 22 +: 2
        __field N 21 +: 1
        __field Rm 16 +: 5
        __field imm6 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx01010 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            if sf == '0' && imm6<5> == '1' then UNDEFINED;
            
            ShiftType shift_type = DecodeShift(shift);
            integer shift_amount = UInt(imm6);
            boolean invert = (N == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
        
        if invert then operand2 = NOT(operand2);
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        X[d] = result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_binary_uniform_shift_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_shift_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');
            if S == '0' && size != '11' then UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_shift_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        integer round_const = 0;
        integer shift;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            shift = SInt(Elem[operand2, e, esize]<7:0>);
            if rounding then
                round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift 
            element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
            if saturating then
                (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                if sat then FPSR.QC = '1';
            else
                Elem[result, e, esize] = element<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_memory_atomicops_cas_single
    __encoding aarch64_memory_atomicops_cas_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x1xxxxx x11111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) comparevalue;
        bits(datasize) newvalue;
        bits(datasize) data;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        comparevalue = X[s];
        newvalue = X[t];
        
        if n == 31 then 
            CheckSPAlignment(); 
            address = SP[];
        else 
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data = Mem[address, datasize DIV 8, ldacctype];
        if data == comparevalue then  
            Mem[address, datasize DIV 8, stacctype] = newvalue;
        
        X[s] = ZeroExtend(data, regsize);

__instruction WHILELT_P.P.RR__
    __encoding WHILELT_P.P.RR__
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field sf 12 +: 1
        __field Rn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx1xxxxx 000x01xx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer rsize = 32 << UInt(sf);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer d = UInt(Pd);
            boolean unsigned = FALSE;
            SVECmp op = Cmp_LT;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = Ones(PL);
        bits(rsize) operand1 = X[n];
        bits(rsize) operand2 = X[m];
        bits(PL) result;
        boolean last = TRUE;
        
        for e = 0 to elements-1
            boolean cond;
            case op of
                when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));
                when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));
        
            last = last && cond;
            ElemP[result, e, esize] = if last then '1' else '0';
            operand1 = operand1 + 1;
        
        PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_branch_unconditional_register
    __encoding aarch64_branch_unconditional_register
        __instruction_set A64
        __field Z 24 +: 1
        __field op 21 +: 2
        __field A 11 +: 1
        __field M 10 +: 1
        __field Rn 5 +: 5
        __field Rm 0 +: 5
        __opcode '1101011x 0xx11111 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            BranchType branch_type;
            integer m = UInt(Rm);
            boolean pac = (A == '1');
            boolean use_key_a = (M == '0');
            boolean source_is_sp = ((Z == '1') && (m == 31));
            
            if !pac && m != 0 then 
                UNDEFINED;
            elsif pac && !HavePACExt() then 
                UNDEFINED;
            
            case op of
                when '00' branch_type = BranchType_INDIR;
                when '01' branch_type = BranchType_INDCALL;
                when '10' branch_type = BranchType_RET;
                otherwise UNDEFINED;
            
            if pac then
                if Z == '0' && m != 31 then
                    UNDEFINED;
            
                if branch_type == BranchType_RET then
                    if n != 31 then UNDEFINED;
                    n = 30;
                    source_is_sp = TRUE;

    __execute
        bits(64) target = X[n];
        if pac then
            bits(64) modifier = if source_is_sp then SP[] else X[m];
        
            if use_key_a then
                target = AuthIA(target, modifier);
            else
                target = AuthIB(target, modifier);
        
        if branch_type == BranchType_INDCALL then X[30] = PC[] + 4;
        
        // Value in BTypeNext will be used to set PSTATE.BTYPE
        case branch_type of
            when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ
                if InGuardedPage then
                    if n == 16 || n == 17 then
                        BTypeNext = '01';
                    else
                        BTypeNext = '11';
                else
                    BTypeNext = '01';
            when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ
                BTypeNext = '10';
            when BranchType_RET             // RET, RETAA, RETAB 
                BTypeNext = '00';
        
        BranchTo(target, branch_type);

__instruction aarch64_vector_crypto_sha2op_sha256_sched0
    __encoding aarch64_vector_crypto_sha2op_sha256_sched0
        __instruction_set A64
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 00101000 001010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            if !HaveSHA256Ext() then UNDEFINED;

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) operand1 = V[d];
        bits(128) operand2 = V[n];
        bits(128) result;
        bits(128) T = operand2<31:0> : operand1<127:32>;
        bits(32) elt;
        
        for e = 0 to 3
            elt = Elem[T, e, 32];
            elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);
            Elem[result, e, 32] = elt + Elem[operand1, e, 32];
        V[d] = result;

__instruction aarch64_integer_logical_immediate
    __encoding aarch64_integer_logical_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field N 22 +: 1
        __field immr 16 +: 6
        __field imms 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10010 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            bits(datasize) imm;
            if sf == '0' && N != '0' then UNDEFINED;
            (imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = imm;
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction aarch64_memory_vector_multiple_no_wb
    __encoding aarch64_memory_vector_multiple_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 0x000000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_multiple_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field Rm 16 +: 5
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << UInt(size);
        integer elements = datasize DIV esize;
        
        integer rpt;    // number of iterations
        integer selem;  // structure elements 
        
        case opcode of
            when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
            when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
            when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
            when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
            when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
            when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
            when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
            otherwise UNDEFINED;
        
        // .1D format only permitted with LD1 & ST1
        if size:Q == '110' && selem != 1 then UNDEFINED;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(datasize) rval;
        integer tt;
        constant integer ebytes = esize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        for r = 0 to rpt-1
            for e = 0 to elements-1
                tt = (t + r) MOD 32;
                for s = 0 to selem-1
                    rval = V[tt];
                    if memop == MemOp_LOAD then
                        Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                        V[tt] = rval;
                    else // memop == MemOp_STORE
                        Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                    offs = offs + ebytes;
                    tt = (tt + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction SEL_Z.P.ZZ__
    __encoding SEL_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 4
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx1xxxxx 11xxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = element1;
            else
                Elem[result, e, esize] = element2;
        
        Z[d] = result;

__instruction LSR_Z.P.ZZ__
    __encoding LSR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010001 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            integer element2 = UInt(Elem[operand2, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = LSR(element1, element2);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_long
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 xxxxxxxx 0x10x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean sub_op = (o2 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(idxdsize)   operand2 = V[m];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        
        element2 = Int(Elem[operand2, index, esize], unsigned);
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            product = (element1 * element2)<2*esize-1:0>;
            if sub_op then
                Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
            else
                Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;
        
        V[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_lda_stl
    __encoding aarch64_memory_single_general_immediate_signed_offset_lda_stl
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx011001 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_ORDERED;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_memory_single_general_immediate_signed_offset_unpriv
    __encoding aarch64_memory_single_general_immediate_signed_offset_unpriv
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        
        unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
        unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
        
        user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
        if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
            acctype = AccType_UNPRIV;
        else
            acctype = AccType_NORMAL;
        
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_integer_arithmetic_add_sub_carry
    __encoding aarch64_integer_arithmetic_add_sub_carry
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx11010 000xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(4) nzcv;
        
        if sub_op then
            operand2 = NOT(operand2);
        
        (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        X[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_mul_product
    __encoding aarch64_vector_arithmetic_binary_disparate_mul_product
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;
        
        V[d] = result;

__instruction aarch64_integer_pac_autib_dp_1src
    __encoding aarch64_integer_pac_autib_dp_1src
        __instruction_set A64
        __field Z 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11011010 11000001 00x101xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean source_is_sp = FALSE;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if !HavePACExt() then
                UNDEFINED;
            
            if Z == '0' then // AUTIB
                if n == 31 then source_is_sp = TRUE;
            else // AUTIZB
                if n != 31 then UNDEFINED;

    __encoding aarch64_integer_pac_autib_hint
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            integer d;
            integer n;
            boolean source_is_sp = FALSE;
            
            case CRm:op2 of
                when '0011 110' // AUTIBZ
                    d = 30;
                    n = 31;
                when '0011 111' // AUTIBSP
                    d = 30;
                    source_is_sp = TRUE;
                when '0001 110' // AUTIB1716
                    d = 17;
                    n = 16;
                when '0001 000' SEE "PACIA";
                when '0001 010' SEE "PACIB";
                when '0001 100' SEE "AUTIA";
                when '0011 00x' SEE "PACIA";
                when '0011 01x' SEE "PACIB";
                when '0011 10x' SEE "AUTIA";
                when '0000 111' SEE "XPACLRI";

    __execute
        if HavePACExt() then
            if source_is_sp then
                X[d] = AuthIB(X[d], SP[]);
            else
                X[d] = AuthIB(X[d], X[n]);

__instruction ST2B_Z.P.BR_Contiguous
    __encoding ST2B_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 001xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction ASR_Z.ZI__
    __encoding ASR_Z.ZI__
        __instruction_set A64
        __field tszh 22 +: 2
        __field tszl 19 +: 2
        __field imm3 16 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 100100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            bits(4) tsize = tszh:tszl;
            case tsize of
                when '0000' UNDEFINED;
                when '0001' esize = 8;
                when '001x' esize = 16;
                when '01xx' esize = 32;
                when '1xxx' esize = 64;
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer shift = (2 * esize) - UInt(tsize:imm3);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            Elem[result, e, esize] = ASR(element1, shift);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_sub_saturating_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_sub_saturating_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 001011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_sub_saturating_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 001011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer diff;
        boolean sat;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            diff = element1 - element2;
            (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_branch_unconditional_dret
    __encoding aarch64_branch_unconditional_dret
        __instruction_set A64
        __opcode '11010110 10111111 00000011 11100000'
        __guard TRUE
        __decode
            if !Halted() || PSTATE.EL == EL0 then UNDEFINED;

    __execute
        DRPSInstruction();

__instruction aarch64_vector_reduce_fp16_maxnm_sisd
    __encoding aarch64_vector_reduce_fp16_maxnm_sisd
        __instruction_set A64
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 xx110000 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            if sz == '1' then UNDEFINED;
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

    __encoding aarch64_vector_reduce_fp_maxnm_sisd
        __instruction_set A64
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 xx110000 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize * 2;
            integer elements = 2;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction FCPY_Z.P.I__
    __encoding FCPY_Z.P.I__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 16 +: 4
        __field imm8 5 +: 8
        __field Zd 0 +: 5
        __opcode '00000101 xx01xxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer d = UInt(Zd);
            bits(esize) imm = VFPExpandImm(imm8);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = imm;
        
        Z[d] = result;

__instruction LD1RD_Z.P.BI_U64
    __encoding LD1RD_Z.P.BI_U64
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 11xxxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 64;
            boolean unsigned = TRUE;
            integer offset = UInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        integer last = LastActiveElement(mask, esize);
        if last >= 0 then
            addr = base + offset * mbytes;
            data = Mem[addr, mbytes, AccType_NORMAL];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
    __encoding aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100000 011110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean neg = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_diff_neg_sat_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 011110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean neg = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            element = SInt(Elem[operand, e, esize]);
            if neg then
                element = -element;
            else
                element = Abs(element);
            (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_crypto_sha512_sha512h2
    __encoding aarch64_vector_crypto_sha512_sha512h2
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 011xxxxx 100001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSHA512Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) Vtmp;  
        bits(64) NSigma0;
        bits(64) tmp;
        bits(128) X = V[n];
        bits(128) Y = V[m];
        bits(128) W = V[d];
        
        NSigma0 =  ROR(Y<63:0>, 28) EOR ROR(Y<63:0>,34) EOR ROR(Y<63:0>,39);
        Vtmp<127:64> = (X<63:0> AND Y<127:64>) EOR (X<63:0> AND Y<63:0>) EOR (Y<127:64> AND Y<63:0>);
        Vtmp<127:64> = (Vtmp<127:64> + NSigma0 +  W<127:64>);
        NSigma0 =  ROR(Vtmp<127:64>, 28) EOR ROR(Vtmp<127:64>,34) EOR ROR(Vtmp<127:64>,39);
        Vtmp<63:0> =   (Vtmp<127:64> AND Y<63:0>) EOR (Vtmp<127:64> AND Y<127:64>) EOR (Y<127:64> AND Y<63:0>);
        Vtmp<63:0> =   (Vtmp<63:0> + NSigma0 + W<63:0>);
        
        V[d] = Vtmp;

__instruction FADDA_V.P.Z__
    __encoding FADDA_V.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Vdn 0 +: 5
        __opcode '01100101 xx011000 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Vdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(esize) operand1 = V[dn];
        bits(VL) operand2 = Z[m];
        bits(esize) result = operand1;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                bits(esize) element = Elem[operand2, e, esize];
                result = FPAdd(result, element, FPCR);
        
        V[dn] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_bitwise_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_bitwise_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 100011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean and_test = (U == '0');

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_bitwise_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 100011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean and_test = (U == '0');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if and_test then
                test_passed = !IsZero(element1 AND element2);
            else
                test_passed = (element1 == element2);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction FCMEQ_P.P.ZZ__
    __encoding FCMEQ_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx0xxxxx 011xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_EQ;

    __encoding FCMGT_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx0xxxxx 010xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GT;

    __encoding FCMGE_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx0xxxxx 010xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GE;

    __encoding FCMNE_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx0xxxxx 011xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_NE;

    __encoding FCMUO_P.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '01100101 xx0xxxxx 110xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_UN;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                case op of
                    when Cmp_EQ res = FPCompareEQ(element1, element2, FPCR);
                    when Cmp_GE res = FPCompareGE(element1, element2, FPCR);
                    when Cmp_GT res = FPCompareGT(element1, element2, FPCR);
                    when Cmp_UN res = FPCompareUN(element1, element2, FPCR);
                    when Cmp_NE res = FPCompareNE(element1, element2, FPCR);
                    when Cmp_LT res = FPCompareGT(element2, element1, FPCR);
                    when Cmp_LE res = FPCompareGE(element2, element1, FPCR);
                ElemP[result, e, esize] = if res then '1' else '0';
            else
                ElemP[result, e, esize] = '0';
        
        P[d] = result;

__instruction aarch64_integer_conditional_compare_immediate
    __encoding aarch64_integer_conditional_compare_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field imm5 16 +: 5
        __field cond 12 +: 4
        __field Rn 5 +: 5
        __field nzcv 0 +: 4
        __opcode 'xx111010 010xxxxx xxxx10xx xxx0xxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            bits(4) condition = cond;
            bits(4) flags = nzcv;
            bits(datasize) imm = ZeroExtend(imm5, datasize);

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = imm;
        bit carry_in = '0';
        
        if ConditionHolds(condition) then
            if sub_op then
                operand2 = NOT(operand2);
                carry_in = '1';
            (-, flags) = AddWithCarry(operand1, operand2, carry_in);
        PSTATE.<N,Z,C,V> = flags;

__instruction aarch64_memory_exclusive_pair
    __encoding aarch64_memory_exclusive_pair
        __instruction_set A64
        __field sz 30 +: 1
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '1x001000 0x1xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = TRUE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 32 << UInt(sz);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction aarch64_integer_arithmetic_mul_widening_64_128hi
    __encoding aarch64_integer_arithmetic_mul_widening_64_128hi
        __instruction_set A64
        __field U 23 +: 1
        __field Rm 16 +: 5
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '10011011 x10xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer a = UInt(Ra);           // ignored by UMULH/SMULH
            integer destsize = 64;
            integer datasize = destsize;
            boolean unsigned = (U == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        
        integer result;
        
        result = Int(operand1, unsigned) * Int(operand2, unsigned);
        
        X[d] = result<127:64>;

__instruction aarch64_memory_single_general_immediate_signed_offset_normal
    __encoding aarch64_memory_single_general_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_single
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_single
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer maxmin;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
            Elem[result, e, esize] = maxmin<esize-1:0>;
        
        V[d] = result;

__instruction SCVTF_Z.P.Z_H2FP16
    __encoding SCVTF_Z.P.Z_H2FP16
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01010010 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 16;
            integer d_esize = 16;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding SCVTF_Z.P.Z_W2FP16
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01010100 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 16;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding SCVTF_Z.P.Z_W2S
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 10010100 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 32;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding SCVTF_Z.P.Z_W2D
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11010000 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 32;
            integer d_esize = 64;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding SCVTF_Z.P.Z_X2FP16
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 01010110 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 16;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding SCVTF_Z.P.Z_X2S
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11010100 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 32;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding SCVTF_Z.P.Z_X2D
        __instruction_set A64
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 11010110 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer s_esize = 64;
            integer d_esize = 64;
            boolean unsigned = FALSE;
            FPRounding rounding = FPRoundingMode(FPCR);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                bits(d_esize) fpval = FixedToFP(element<s_esize-1:0>, 0, unsigned, FPCR, rounding);
                Elem[result, e, esize] = ZeroExtend(fpval);
        
        Z[d] = result;

__instruction aarch64_float_convert_fp
    __encoding aarch64_float_convert_fp
        __instruction_set A64
        __field type1 22 +: 2
        __field opc 15 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx10001x x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if type1 == opc then UNDEFINED;
            
            integer srcsize;
            case type1 of
                when '00' srcsize = 32;
                when '01' srcsize = 64;
                when '10' UNDEFINED;
                when '11' srcsize = 16;
            integer dstsize;
            case opc of
                when '00' dstsize = 32;
                when '01' dstsize = 64;
                when '10' UNDEFINED;
                when '11' dstsize = 16;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(dstsize) result;
        bits(srcsize) operand = V[n];
        
        result = FPConvert(operand, FPCR);
        V[d] = result;

__instruction aarch64_float_arithmetic_round_frint
    __encoding aarch64_float_arithmetic_round_frint
        __instruction_set A64
        __field type1 22 +: 2
        __field rmode 15 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1001xx x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case rmode of
                when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundInt(operand, FPCR, rounding, exact);
        
        V[d] = result;

__instruction ADD_Z.ZI__
    __encoding ADD_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field sh 13 +: 1
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx100000 11xxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size:sh == '001' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer imm = UInt(imm8);
            if sh == '1' then imm = imm << 8;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            Elem[result, e, esize] = element1 + imm;
        
        Z[dn] = result;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction LD1RQB_Z.P.BI_U8
    __encoding LD1RQB_Z.P.BI_U8
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0000xxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = 128 DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g]; // low 16 bits only
        bits(128) result;
        constant integer mbytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * 16;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = Replicate(result, VL DIV 128);

__instruction UQDECH_R.RS_UW
    __encoding UQDECH_R.RS_UW
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0110xxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 32;

    __encoding UQDECH_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 0111xxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction LDFF1W_Z.P.BR_U32
    __encoding LDFF1W_Z.P.BR_U32
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 010xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            boolean unsigned = TRUE;

    __encoding LDFF1W_Z.P.BR_U64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 011xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + UInt(offset) * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            offset = offset + 1;
        
        Z[t] = result;

__instruction LDFF1W_Z.P.AI_S
    __encoding LDFF1W_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 001xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __encoding LDFF1W_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 001xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = TRUE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction AND_P.P.PP_Z
    __encoding AND_P.P.PP_Z
        __instruction_set A64
        __field S 22 +: 1
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0000xxxx 01xxxx0x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = FALSE;

    __encoding ANDS_P.P.PP_Z
        __instruction_set A64
        __field S 22 +: 1
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 0100xxxx 01xxxx0x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            bit element1 = ElemP[operand1, e, esize];
            bit element2 = ElemP[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                ElemP[result, e, esize] = element1 AND element2;
            else
                ElemP[result, e, esize] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_vector_transfer_vector_permute_unzip
    __encoding aarch64_vector_transfer_vector_permute_unzip
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field op 14 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx0xxxxx 0x0110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            integer part = UInt(op);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operandl = V[n];
        bits(datasize) operandh = V[m];
        bits(datasize) result;
        
        bits(datasize*2) zipped = operandh:operandl;
        for e = 0 to elements-1
            Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];
        
        V[d] = result;

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction MAD_Z.P.ZZZ__
    __encoding MAD_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Za 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx0xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            integer a = UInt(Za);
            boolean sub_op = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[a];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = UInt(Elem[operand1, e, esize]);
            integer element2 = UInt(Elem[operand2, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                integer product = element1 * element2;
                if sub_op then
                    Elem[result, e, esize] = Elem[operand3, e, esize] - product;
                else
                    Elem[result, e, esize] = Elem[operand3, e, esize] + product;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction LD1RW_Z.P.BI_U32
    __encoding LD1RW_Z.P.BI_U32
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 01xxxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 32;
            boolean unsigned = TRUE;
            integer offset = UInt(imm6);

    __encoding LD1RW_Z.P.BI_U64
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000101 01xxxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = TRUE;
            integer offset = UInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        integer last = LastActiveElement(mask, esize);
        if last >= 0 then
            addr = base + offset * mbytes;
            data = Mem[addr, mbytes, AccType_NORMAL];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_branch_unconditional_register
    __encoding aarch64_branch_unconditional_register
        __instruction_set A64
        __field Z 24 +: 1
        __field op 21 +: 2
        __field A 11 +: 1
        __field M 10 +: 1
        __field Rn 5 +: 5
        __field Rm 0 +: 5
        __opcode '1101011x 0xx11111 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            BranchType branch_type;
            integer m = UInt(Rm);
            boolean pac = (A == '1');
            boolean use_key_a = (M == '0');
            boolean source_is_sp = ((Z == '1') && (m == 31));
            
            if !pac && m != 0 then 
                UNDEFINED;
            elsif pac && !HavePACExt() then 
                UNDEFINED;
            
            case op of
                when '00' branch_type = BranchType_INDIR;
                when '01' branch_type = BranchType_INDCALL;
                when '10' branch_type = BranchType_RET;
                otherwise UNDEFINED;
            
            if pac then
                if Z == '0' && m != 31 then
                    UNDEFINED;
            
                if branch_type == BranchType_RET then
                    if n != 31 then UNDEFINED;
                    n = 30;
                    source_is_sp = TRUE;

    __execute
        bits(64) target = X[n];
        if pac then
            bits(64) modifier = if source_is_sp then SP[] else X[m];
        
            if use_key_a then
                target = AuthIA(target, modifier);
            else
                target = AuthIB(target, modifier);
        
        if branch_type == BranchType_INDCALL then X[30] = PC[] + 4;
        
        // Value in BTypeNext will be used to set PSTATE.BTYPE
        case branch_type of
            when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ
                if InGuardedPage then
                    if n == 16 || n == 17 then
                        BTypeNext = '01';
                    else
                        BTypeNext = '11';
                else
                    BTypeNext = '01';
            when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ
                BTypeNext = '10';
            when BranchType_RET             // RET, RETAA, RETAB 
                BTypeNext = '00';
        
        BranchTo(target, branch_type);

__instruction CMPEQ_P.P.ZW__
    __encoding CMPEQ_P.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 001xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_EQ;
            boolean unsigned = FALSE;

    __encoding CMPGT_P.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 010xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GT;
            boolean unsigned = FALSE;

    __encoding CMPGE_P.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 010xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GE;
            boolean unsigned = FALSE;

    __encoding CMPHI_P.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 110xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GT;
            boolean unsigned = TRUE;

    __encoding CMPHS_P.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 110xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_GE;
            boolean unsigned = TRUE;

    __encoding CMPLT_P.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 011xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_LT;
            boolean unsigned = FALSE;

    __encoding CMPLE_P.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 011xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_LE;
            boolean unsigned = FALSE;

    __encoding CMPLO_P.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 111xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_LT;
            boolean unsigned = TRUE;

    __encoding CMPLS_P.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 111xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_LE;
            boolean unsigned = TRUE;

    __encoding CMPNE_P.P.ZW__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100100 xx0xxxxx 001xxxxx xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Pd);
            SVECmp op = Cmp_NE;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, (e * esize) DIV 64, 64], unsigned);
            if ElemP[mask, e, esize] == '1' then
                boolean cond;
                case op of
                    when Cmp_EQ cond = element1 == element2;
                    when Cmp_NE cond = element1 != element2;
                    when Cmp_GE cond = element1 >= element2;
                    when Cmp_LT cond = element1 <  element2;
                    when Cmp_GT cond = element1 >  element2;
                    when Cmp_LE cond = element1 <= element2;
                ElemP[result, e, esize] = if cond then '1' else '0';
            else
                ElemP[result, e, esize] = '0';
        
        PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_vector_shift_conv_int_sisd
    __encoding aarch64_vector_shift_conv_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 111001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
            integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
            integer datasize = esize;
            integer elements = 1;
            
            integer fracbits = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding aarch64_vector_shift_conv_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 111001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer fracbits = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            FPRounding rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_cmp_fp16_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_cmp_fp16_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 11111000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 1x100000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_fp16_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 11111000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __encoding aarch64_vector_arithmetic_unary_cmp_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field op 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 1x100000 110x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            CompareOp comparison;
            case op:U of
                when '00' comparison = CompareOp_GT;
                when '01' comparison = CompareOp_GE;
                when '10' comparison = CompareOp_EQ;
                when '11' comparison = CompareOp_LE;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) zero = FPZero('0');
        bits(esize) element;
        boolean test_passed;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            case comparison of
                when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
                when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
                when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
                when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
                when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction aarch64_float_arithmetic_round_frint_32_64
    __encoding aarch64_float_arithmetic_round_frint_32_64
        __instruction_set A64
        __field type1 22 +: 2
        __field op 15 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx10100x x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFrintExt() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '1x' UNDEFINED;
            
            integer intsize = if op<1> == '0' then 32 else 64;
            
            FPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundIntN(operand, FPCR, rounding, intsize);
        
        V[d] = result;

__instruction LD1RSW_Z.P.BI_S64
    __encoding LD1RSW_Z.P.BI_S64
        __instruction_set A64
        __field imm6 16 +: 6
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 11xxxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = FALSE;
            integer offset = UInt(imm6);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        integer last = LastActiveElement(mask, esize);
        if last >= 0 then
            addr = base + offset * mbytes;
            data = Mem[addr, mbytes, AccType_NORMAL];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field S 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 1xxxxxxx 0x00x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
            if sz == '1' then UNDEFINED;
            integer index = UInt(H:L:M); 
            
            integer esize = 32;
            integer datasize = if Q=='1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (S == '1');
            integer part = 0;

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field S 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 1xxxxxxx 1x00x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
            if sz == '1' then UNDEFINED;
            integer index = UInt(H:L:M); 
            
            integer esize = 32;
            integer datasize = if Q=='1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (S == '1');
            integer part = 1;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize DIV 2) operand1 = Vpart[n,part];
        bits(128) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize DIV 2) element1;
        bits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2];
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize DIV 2];
            if sub_op then element1 = FPNeg(element1);
            Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
        V[d] = result;

__instruction SQDECP_Z.P.Z__
    __encoding SQDECP_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Zdn 0 +: 5
        __opcode '00100101 xx101010 1000000x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[dn];
        bits(VL) result;
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        for e = 0 to elements-1
            integer element = Int(Elem[operand, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element - count, esize, unsigned);
        
        Z[dn] = result;

__instruction aarch64_integer_logical_immediate
    __encoding aarch64_integer_logical_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field N 22 +: 1
        __field immr 16 +: 6
        __field imms 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10010 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            bits(datasize) imm;
            if sf == '0' && N != '0' then UNDEFINED;
            (imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = imm;
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_diff
    __encoding aarch64_vector_arithmetic_binary_disparate_diff
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field op 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 01x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean accumulate = (op == '0');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) absdiff;
        
        result = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            absdiff = Abs(element1 - element2)<2*esize-1:0>;
            Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
        V[d] = result;

__instruction LDFF1SB_Z.P.BZ_D.x32.unscaled
    __encoding LDFF1SB_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 0x0xxxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1SB_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 0x0xxxxx 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1SB_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 010xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offs_size = 64;
            boolean unsigned = FALSE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction SUBR_Z.ZI__
    __encoding SUBR_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field sh 13 +: 1
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx100011 11xxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size:sh == '001' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            integer imm = UInt(imm8);
            if sh == '1' then imm = imm << 8;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = UInt(Elem[operand1, e, esize]);
            Elem[result, e, esize] = (imm - element1)<esize-1:0>;
        
        Z[dn] = result;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction LD2B_Z.P.BI_Contiguous
    __encoding LD2B_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 0010xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 8;
            integer offset = SInt(imm4);
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction LSR_Z.ZI__
    __encoding LSR_Z.ZI__
        __instruction_set A64
        __field tszh 22 +: 2
        __field tszl 19 +: 2
        __field imm3 16 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 100101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            bits(4) tsize = tszh:tszl;
            case tsize of
                when '0000' UNDEFINED;
                when '0001' esize = 8;
                when '001x' esize = 16;
                when '01xx' esize = 32;
                when '1xxx' esize = 64;
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer shift = (2 * esize) - UInt(tsize:imm3);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            Elem[result, e, esize] = LSR(element1, shift);
        
        Z[d] = result;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction EOR_Z.ZZ__
    __encoding EOR_Z.ZZ__
        __instruction_set A64
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 101xxxxx 001100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        
        Z[d] = operand1 EOR operand2;

__instruction SMIN_Z.P.ZZ__
    __encoding SMIN_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx001010 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer minimum = Min(element1, element2);
                Elem[result, e, esize] = minimum<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_vector_shift_conv_float_sisd
    __encoding aarch64_vector_shift_conv_float_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
            integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
            integer datasize = esize;
            integer elements = 1;
            
            integer fracbits = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            FPRounding rounding = FPRounding_ZERO;

    __encoding aarch64_vector_shift_conv_float_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer fracbits = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            FPRounding rounding = FPRounding_ZERO;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction SMAX_Z.ZI__
    __encoding SMAX_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx101000 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            boolean unsigned = FALSE;
            integer imm = Int(imm8, unsigned);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            Elem[result, e, esize] = Max(element1, imm)<esize-1:0>;
        
        Z[dn] = result;

__instruction LDNT1B_Z.P.BR_Contiguous
    __encoding LDNT1B_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 000xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(64) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = X[m];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
            else
                Elem[result, e, esize] = Zeros();
            offset = offset + 1;
        
        Z[t] = result;

__instruction FNMLA_Z.P.ZZZ__
    __encoding FNMLA_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100101 xx1xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean op1_neg = TRUE;
            boolean op3_neg = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            bits(esize) element3 = Elem[operand3, e, esize];
            
            if ElemP[mask, e, esize] == '1' then
                if op1_neg then element1 = FPNeg(element1);
                if op3_neg then element3 = FPNeg(element3);
                Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
            else
                Elem[result, e, esize] = element3;
        
        Z[da] = result;

__instruction aarch64_system_hints
    __encoding aarch64_system_hints
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            SystemHintOp op;
            
            case CRm:op2 of
                when '0000 000' op = SystemHintOp_NOP;
                when '0000 001' op = SystemHintOp_YIELD;
                when '0000 010' op = SystemHintOp_WFE;
                when '0000 011' op = SystemHintOp_WFI;
                when '0000 100' op = SystemHintOp_SEV;
                when '0000 101' op = SystemHintOp_SEVL;
                when '0000 111'
                    SEE "XPACLRI";
                when '0001 xxx'
                    SEE "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716";
                when '0010 000'
                    if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
                    op = SystemHintOp_ESB;
                when '0010 001'
                    if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
                    op = SystemHintOp_PSB;
                when '0010 010'
                    if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
                    op = SystemHintOp_TSB;
                when '0010 100'
                    op = SystemHintOp_CSDB;
                when '0011 xxx'
                    SEE "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP";
                when '0100 xx0'
                    op = SystemHintOp_BTI;
                    // Check branch target compatibility
                    // between BTI instruction and PSTATE.BTYPE
                    BTypeCompatible = BTypeCompatible_BTI(op2<2:1>);
                otherwise  EndOfInstruction();                                 // Instruction executes as NOP

    __execute
        case op of
            when SystemHintOp_YIELD
                Hint_Yield();
        
            when SystemHintOp_WFE
                if IsEventRegisterSet() then
                    ClearEventRegister();
                else
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, TRUE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, TRUE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, TRUE);
                    WaitForEvent();
        
            when SystemHintOp_WFI
                if !InterruptPending() then
                    if PSTATE.EL == EL0 then
                        // Check for traps described by the OS which may be EL1 or EL2.
                        AArch64.CheckForWFxTrap(EL1, FALSE);
                    if EL2Enabled() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                        // Check for traps described by the Hypervisor.
                        AArch64.CheckForWFxTrap(EL2, FALSE);
                    if HaveEL(EL3) && PSTATE.EL != EL3 then
                        // Check for traps described by the Secure Monitor.
                        AArch64.CheckForWFxTrap(EL3, FALSE);
                    WaitForInterrupt();
        
            when SystemHintOp_SEV
                SendEvent();
        
            when SystemHintOp_SEVL
                SendEventLocal();
        
            when SystemHintOp_ESB
                SynchronizeErrors();
                AArch64.ESBOperation();
                if EL2Enabled() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();
                TakeUnmaskedSErrorInterrupts();
        
            when SystemHintOp_PSB
                ProfilingSynchronizationBarrier();
        
            when SystemHintOp_TSB
                TraceSynchronizationBarrier();
        
            when SystemHintOp_CSDB
                ConsumptionOfSpeculativeDataBarrier();
        
            when SystemHintOp_BTI
                BTypeNext = '00';
        
            otherwise // do nothing

__instruction NOR_P.P.PP_Z
    __encoding NOR_P.P.PP_Z
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 1000xxxx 01xxxx1x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = FALSE;

    __encoding NORS_P.P.PP_Z
        __instruction_set A64
        __field Pm 16 +: 4
        __field Pg 10 +: 4
        __field Pn 5 +: 4
        __field Pd 0 +: 4
        __opcode '00100101 1100xxxx 01xxxx1x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8;
            integer g = UInt(Pg);
            integer n = UInt(Pn);
            integer m = UInt(Pm);
            integer d = UInt(Pd);
            boolean setflags = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand1 = P[n];
        bits(PL) operand2 = P[m];
        bits(PL) result;
        
        for e = 0 to elements-1
            bit element1 = ElemP[operand1, e, esize];
            bit element2 = ElemP[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                ElemP[result, e, esize] = NOT(element1 OR element2);
            else
                ElemP[result, e, esize] = '0';
        
        if setflags then
            PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_wide
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_wide
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 00x100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand1 = V[n];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        integer sum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, 2*esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            Elem[result, e, 2*esize] = sum<2*esize-1:0>;
        
        V[d] = result;

__instruction SQDECW_Z.ZS__
    __encoding SQDECW_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1010xxxx 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction aarch64_integer_pac_pacdb_dp_1src
    __encoding aarch64_integer_pac_pacdb_dp_1src
        __instruction_set A64
        __field Z 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11011010 11000001 00x011xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean source_is_sp = FALSE;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if !HavePACExt() then
                UNDEFINED;
            
            if Z == '0' then // PACDB
                if n == 31 then source_is_sp = TRUE;
            else // PACDZB
                if n != 31 then UNDEFINED;

    __execute
        if source_is_sp then
            X[d] = AddPACDB(X[d], SP[]);
        else
            X[d] = AddPACDB(X[d], X[n]);

__instruction COMPACT_Z.P.Z__
    __encoding COMPACT_Z.P.Z__
        __instruction_set A64
        __field sz 22 +: 1
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 1x100001 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) result;
        integer x = 0;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = Zeros();
            if ElemP[mask, e, esize] == '1' then
                bits(esize) element = Elem[operand1, e, esize];
                Elem[result, x, esize] = element;
                x = x + 1;
        
        Z[d] = result;

__instruction LDFF1SW_Z.P.AI_D
    __encoding LDFF1SW_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000101 001xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = FALSE;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction LDFF1SW_Z.P.BR_S64
    __encoding LDFF1SW_Z.P.BR_S64
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 100xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 32;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        bits(64) offset = X[m];
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + UInt(offset) * mbytes;
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            offset = offset + 1;
        
        Z[t] = result;

__instruction aarch64_integer_bitfield
    __encoding aarch64_integer_bitfield
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field N 22 +: 1
        __field immr 16 +: 6
        __field imms 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10011 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            
            boolean inzero;
            boolean extend;
            integer R;
            integer S;
            bits(datasize) wmask;
            bits(datasize) tmask;
            
            case opc of
                when '00' inzero = TRUE;  extend = TRUE;    // SBFM
                when '01' inzero = FALSE; extend = FALSE;   // BFM
                when '10' inzero = TRUE;  extend = FALSE;   // UBFM
                when '11' UNDEFINED;
            
            if sf == '1' && N != '1' then UNDEFINED;
            if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;
            
            R = UInt(immr);
            S = UInt(imms);
            (wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);

    __execute
        bits(datasize) dst = if inzero then Zeros() else X[d];
        bits(datasize) src = X[n];
        
        // perform bitfield move on low bits
        bits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);
        
        // determine extension bits (sign, zero or dest register)
        bits(datasize) top = if extend then Replicate(src<S>) else dst;
        
        // combine extension bits and result bits
        X[d] = (top AND NOT(tmask)) OR (bot AND tmask);

__instruction ST1H_Z.P.AI_S
    __encoding ST1H_Z.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 111xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offset = UInt(imm5);

    __encoding ST1H_Z.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 110xxxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Zn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) base = Z[n];
        bits(VL) src = Z[t];
        bits(PL) mask = P[g];
        bits(64) addr;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;

__instruction aarch64_vector_shift_left_insert_sisd
    __encoding aarch64_vector_shift_left_insert_sisd
        __instruction_set A64
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111111 0xxxxxxx 010101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = UInt(immh:immb) - esize;

    __encoding aarch64_vector_shift_left_insert_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 0xxxxxxx 010101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = UInt(immh:immb) - esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) operand2 = V[d];
        bits(datasize) result;
        bits(esize) mask = LSL(Ones(esize), shift);
        bits(esize) shifted;
        
        for e = 0 to elements-1
            shifted = LSL(Elem[operand, e, esize], shift);
            Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;
        V[d] = result;

__instruction ST1H_Z.P.BR__
    __encoding ST1H_Z.P.BR__
        __instruction_set A64
        __field size 21 +: 2
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 1xxxxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 8 << UInt(size);
            integer msize = 16;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        bits(VL) src = Z[t];
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize]<msize-1:0>;
            offset = offset + 1;

__instruction aarch64_system_sysops
    __encoding aarch64_system_sysops
        __instruction_set A64
        __field L 21 +: 1
        __field op1 16 +: 3
        __field CRn 12 +: 4
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __field Rt 0 +: 5
        __opcode '11010101 00x01xxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);
            
            integer t = UInt(Rt);
            
            integer sys_op0 = 1;
            integer sys_op1 = UInt(op1);
            integer sys_op2 = UInt(op2);
            integer sys_crn = UInt(CRn);
            integer sys_crm = UInt(CRm);
            boolean has_result = (L == '1');

    __execute
        if has_result then
            X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);
        else
            AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);

__instruction FRSQRTS_Z.ZZ__
    __encoding FRSQRTS_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx0xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);
        
        Z[d] = result;

__instruction aarch64_vector_shift_right_sisd
    __encoding aarch64_vector_shift_right_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __encoding aarch64_vector_shift_right_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) operand2;
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        
        operand2 = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
            Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
        
        V[d] = result;

__instruction PRFH_I.P.BR_S
    __encoding PRFH_I.P.BR_S
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000100 100xxxxx 110xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer esize = 16;
            integer g = UInt(Pg);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 1;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(64) base;
        bits(64) offset = X[m];
        bits(64) addr;
        
        if n == 31 then
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = base + (UInt(offset) << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);
            offset = offset + 1;

__instruction PRFH_I.P.AI_S
    __encoding PRFH_I.P.AI_S
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field prfop 0 +: 4
        __opcode '10000100 100xxxxx 111xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 1;
            integer offset = UInt(imm5);

    __encoding PRFH_I.P.AI_D
        __instruction_set A64
        __field imm5 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field prfop 0 +: 4
        __opcode '11000100 100xxxxx 111xxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer level = UInt(prfop<2:1>);
            boolean stream = (prfop<0> == '1');
            pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
            integer scale = 1;
            integer offset = UInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) base;
        bits(64) addr;
        base = Z[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);
                Hint_Prefetch(addr, pref_hint, level, stream);

__instruction aarch64_system_exceptions_runtime_hvc
    __encoding aarch64_system_exceptions_runtime_hvc
        __instruction_set A64
        __field imm16 5 +: 16
        __opcode '11010100 000xxxxx xxxxxxxx xxx00010'
        __guard TRUE
        __decode
            bits(16) imm = imm16;

    __execute
        if !HaveEL(EL2) || PSTATE.EL == EL0 || (PSTATE.EL == EL1 && (!IsSecureEL2Enabled() && IsSecure())) then
            UNDEFINED;
        
        hvc_enable = if HaveEL(EL3) then SCR_EL3.HCE else NOT(HCR_EL2.HCD);
        if hvc_enable == '0' then
            AArch64.UndefinedFault();
        else
            AArch64.CallHypervisor(imm);

__instruction aarch64_memory_single_general_immediate_signed_offset_lda_stl
    __encoding aarch64_memory_single_general_immediate_signed_offset_lda_stl
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx011001 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_ORDERED;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction INDEX_Z.RI__
    __encoding INDEX_Z.RI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm5 16 +: 5
        __field Rn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 010001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Rn);
            integer d = UInt(Zd);
            integer imm = SInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(esize) operand1 = X[n];
        integer element1 = SInt(operand1);
        bits(VL) result;
        
        for e = 0 to elements-1
            integer index = element1 + e * imm;
            Elem[result, e, esize] = index<esize-1:0>;
        
        Z[d] = result;

__instruction ORV_R.P.Z__
    __encoding ORV_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000100 xx011000 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(esize) result = Zeros(esize);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                result = result OR Elem[operand, e, esize];
        
        V[d] = result;

__instruction aarch64_integer_pac_autia_dp_1src
    __encoding aarch64_integer_pac_autia_dp_1src
        __instruction_set A64
        __field Z 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11011010 11000001 00x100xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean source_is_sp = FALSE;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if !HavePACExt() then
                UNDEFINED;
            
            if Z == '0' then // AUTIA
                if n == 31 then source_is_sp = TRUE;
            else // AUTIZA
                if n != 31 then UNDEFINED;

    __encoding aarch64_integer_pac_autia_hint
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            integer d;
            integer n;
            boolean source_is_sp = FALSE;
            
            case CRm:op2 of
                when '0011 100' // AUTIAZ
                    d = 30;
                    n = 31;
                when '0011 101' // AUTIASP
                    d = 30;
                    source_is_sp = TRUE;
                when '0001 100' // AUTIA1716
                    d = 17;
                    n = 16;
                when '0001 000' SEE "PACIA";
                when '0001 010' SEE "PACIB";
                when '0001 110' SEE "AUTIB";
                when '0011 00x' SEE "PACIA";
                when '0011 01x' SEE "PACIB";
                when '0011 11x' SEE "AUTIB";
                when '0000 111' SEE "XPACLRI";
                otherwise SEE "HINT";

    __execute
        if HavePACExt() then
            if source_is_sp then
                X[d] = AuthIA(X[d], SP[]);
            else
                X[d] = AuthIA(X[d], X[n]);

__instruction aarch64_vector_crypto_sha3op_sha1_hash_parity
    __encoding aarch64_vector_crypto_sha3op_sha1_hash_parity
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 000xxxxx 000100xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if !HaveSHA1Ext() then UNDEFINED;

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) X = V[d];
        bits(32)  Y = V[n];     // Note: 32 not 128 bits wide
        bits(128) W = V[m];
        bits(32)  t;
        
        for e = 0 to 3
            t = SHAparity(X<63:32>, X<95:64>, X<127:96>);
            Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
            X<63:32> = ROL(X<63:32>, 30);
            <Y, X> = ROL(Y : X, 32);
        V[d] = X;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_memory_single_general_immediate_signed_offset_unpriv
    __encoding aarch64_memory_single_general_immediate_signed_offset_unpriv
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        
        unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
        unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
        
        user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
        if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
            acctype = AccType_UNPRIV;
        else
            acctype = AccType_NORMAL;
        
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_system_exceptions_runtime_svc
    __encoding aarch64_system_exceptions_runtime_svc
        __instruction_set A64
        __field imm16 5 +: 16
        __opcode '11010100 000xxxxx xxxxxxxx xxx00001'
        __guard TRUE
        __decode
            bits(16) imm = imm16;

    __execute
        AArch64.CallSupervisor(imm);

__instruction LDFF1B_Z.P.BZ_D.x32.unscaled
    __encoding LDFF1B_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 0x0xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1B_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 0x0xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LDFF1B_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 010xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean first = TRUE;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = Z[m];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                if first then
                    // Mem[] will not return if a fault is detected for the first active element
                    data = Mem[addr, mbytes, AccType_NORMAL];
                    first = FALSE;
                else
                    // MemNF[] will return fault=TRUE if access is not performed for any reason
                    (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
        Z[t] = result;

__instruction aarch64_memory_atomicops_swp
    __encoding aarch64_memory_atomicops_swp
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 100000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        Mem[address, datasize DIV 8, stacctype] = X[s];
        
        X[t] = ZeroExtend(data, regsize);

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction FMUL_Z.ZZ__
    __encoding FMUL_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx0xxxxx 000010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPMul(element1, element2, FPCR);
        
        Z[d] = result;

__instruction aarch64_float_arithmetic_max_min
    __encoding aarch64_float_arithmetic_max_min
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field op 12 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx 01xx10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            FPMaxMinOp operation;
            case op of
                when '00' operation = FPMaxMinOp_MAX;
                when '01' operation = FPMaxMinOp_MIN;
                when '10' operation = FPMaxMinOp_MAXNUM;
                when '11' operation = FPMaxMinOp_MINNUM;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        case operation of
            when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);
            when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);
            when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);
            when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);
        
        V[d] = result;

__instruction SQDECH_Z.ZS__
    __encoding SQDECH_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 0110xxxx 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);
        
        Z[dn] = result;

__instruction LD1RQW_Z.P.BR_Contiguous
    __encoding LD1RQW_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 000xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;

    __execute
        CheckSVEEnabled();
        integer elements = 128 DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g]; // low 16 bits only
        bits(64) offset;
        bits(128) result;
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = X[m];
        
        addr = base + UInt(offset) * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = Replicate(result, VL DIV 128);

__instruction LSL_Z.ZI__
    __encoding LSL_Z.ZI__
        __instruction_set A64
        __field tszh 22 +: 2
        __field tszl 19 +: 2
        __field imm3 16 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 100111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            bits(4) tsize = tszh:tszl;
            case tsize of
                when '0000' UNDEFINED;
                when '0001' esize = 8;
                when '001x' esize = 16;
                when '01xx' esize = 32;
                when '1xxx' esize = 64;
            integer n = UInt(Zn);
            integer d = UInt(Zd);
            integer shift = UInt(tsize:imm3) - esize;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            Elem[result, e, esize] = LSL(element1, shift);
        
        Z[d] = result;

__instruction CTERMEQ_RR__
    __encoding CTERMEQ_RR__
        __instruction_set A64
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __opcode '00100101 1x1xxxxx 001000xx xxx00000'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            SVECmp op = Cmp_EQ;

    __encoding CTERMNE_RR__
        __instruction_set A64
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __opcode '00100101 1x1xxxxx 001000xx xxx10000'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            SVECmp op = Cmp_NE;

    __execute
        CheckSVEEnabled();
        bits(esize) operand1 = X[n];
        bits(esize) operand2 = X[m];
        integer element1 = UInt(operand1);
        integer element2 = UInt(operand2);
        boolean term;
        
        case op of
            when Cmp_EQ term = element1 == element2;
            when Cmp_NE term = element1 != element2;
        if term then
            PSTATE.N = '1';
            PSTATE.V = '0';
        else
            PSTATE.N = '0';
            PSTATE.V = (NOT PSTATE.C);

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction aarch64_branch_unconditional_register
    __encoding aarch64_branch_unconditional_register
        __instruction_set A64
        __field Z 24 +: 1
        __field op 21 +: 2
        __field A 11 +: 1
        __field M 10 +: 1
        __field Rn 5 +: 5
        __field Rm 0 +: 5
        __opcode '1101011x 0xx11111 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            BranchType branch_type;
            integer m = UInt(Rm);
            boolean pac = (A == '1');
            boolean use_key_a = (M == '0');
            boolean source_is_sp = ((Z == '1') && (m == 31));
            
            if !pac && m != 0 then 
                UNDEFINED;
            elsif pac && !HavePACExt() then 
                UNDEFINED;
            
            case op of
                when '00' branch_type = BranchType_INDIR;
                when '01' branch_type = BranchType_INDCALL;
                when '10' branch_type = BranchType_RET;
                otherwise UNDEFINED;
            
            if pac then
                if Z == '0' && m != 31 then
                    UNDEFINED;
            
                if branch_type == BranchType_RET then
                    if n != 31 then UNDEFINED;
                    n = 30;
                    source_is_sp = TRUE;

    __execute
        bits(64) target = X[n];
        if pac then
            bits(64) modifier = if source_is_sp then SP[] else X[m];
        
            if use_key_a then
                target = AuthIA(target, modifier);
            else
                target = AuthIB(target, modifier);
        
        if branch_type == BranchType_INDCALL then X[30] = PC[] + 4;
        
        // Value in BTypeNext will be used to set PSTATE.BTYPE
        case branch_type of
            when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ
                if InGuardedPage then
                    if n == 16 || n == 17 then
                        BTypeNext = '01';
                    else
                        BTypeNext = '11';
                else
                    BTypeNext = '01';
            when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ
                BTypeNext = '10';
            when BranchType_RET             // RET, RETAA, RETAB 
                BTypeNext = '00';
        
        BranchTo(target, branch_type);

__instruction UABD_Z.P.ZZ__
    __encoding UABD_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx001101 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            integer element2 = Int(Elem[operand2, e, esize], unsigned);
            if ElemP[mask, e, esize] == '1' then
                integer absdiff = Abs(element1 - element2);
                Elem[result, e, esize] = absdiff<esize-1:0>;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_vector_fp16_movi
    __encoding aarch64_vector_fp16_movi
        __instruction_set A64
        __field Q 30 +: 1
        __field a 18 +: 1
        __field b 17 +: 1
        __field c 16 +: 1
        __field d 9 +: 1
        __field e 8 +: 1
        __field f 7 +: 1
        __field g 6 +: 1
        __field h 5 +: 1
        __field Rd 0 +: 5
        __opcode '0x001111 00000xxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer rd = UInt(Rd);
            
            integer datasize = if Q == '1' then 128 else 64;
            bits(datasize) imm;
            
            imm8 = a:b:c:d:e:f:g:h;
            imm16 = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>,2):imm8<5:0>:Zeros(6);
            
            imm = Replicate(imm16, datasize DIV 16);

    __encoding aarch64_vector_logical
        __instruction_set A64
        __field Q 30 +: 1
        __field op 29 +: 1
        __field a 18 +: 1
        __field b 17 +: 1
        __field c 16 +: 1
        __field cmode 12 +: 4
        __field d 9 +: 1
        __field e 8 +: 1
        __field f 7 +: 1
        __field g 6 +: 1
        __field h 5 +: 1
        __field Rd 0 +: 5
        __opcode '0xx01111 00000xxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer rd = UInt(Rd);
            
            integer datasize = if Q == '1' then 128 else 64;
            bits(datasize) imm;
            bits(64) imm64;
            
            ImmediateOp operation;
            case cmode:op of
                when '0xx00' operation = ImmediateOp_MOVI;
                when '0xx01' operation = ImmediateOp_MVNI;
                when '0xx10' operation = ImmediateOp_ORR;
                when '0xx11' operation = ImmediateOp_BIC;
                when '10x00' operation = ImmediateOp_MOVI;
                when '10x01' operation = ImmediateOp_MVNI;
                when '10x10' operation = ImmediateOp_ORR;
                when '10x11' operation = ImmediateOp_BIC;
                when '110x0' operation = ImmediateOp_MOVI;
                when '110x1' operation = ImmediateOp_MVNI;
                when '1110x' operation = ImmediateOp_MOVI;
                when '11110' operation = ImmediateOp_MOVI;
                when '11111' 
                    // FMOV Dn,#imm is in main FP instruction set
                    if Q == '0' then UNDEFINED;
                    operation = ImmediateOp_MOVI;
            
            imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
            imm = Replicate(imm64, datasize DIV 64);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        V[rd] = imm;

__instruction aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
    __encoding aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
        __instruction_set A64
        __field Q 30 +: 1
        __field opc2 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx1xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            VBitOp op;
            
            case opc2 of
                when '00' op = VBitOp_VEOR;
                when '01' op = VBitOp_VBSL;
                when '10' op = VBitOp_VBIT;
                when '11' op = VBitOp_VBIF;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1;
        bits(datasize) operand2;
        bits(datasize) operand3;
        bits(datasize) operand4 = V[n];
        
        case op of
            when VBitOp_VEOR
                operand1 = V[m];
                operand2 = Zeros();
                operand3 = Ones();
            when VBitOp_VBSL
                operand1 = V[m];
                operand2 = operand1;
                operand3 = V[d];
            when VBitOp_VBIT
                operand1 = V[d];
                operand2 = operand1;
                operand3 = V[m];
            when VBitOp_VBIF
                operand1 = V[d];
                operand2 = operand1;
                operand3 = NOT(V[m]);
        
        V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);

__instruction LASTA_V.P.Z__
    __encoding LASTA_V.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000101 xx100010 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);
            boolean isBefore = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        integer last = LastActiveElement(mask, esize);
        
        if isBefore then
            if last < 0 then last = elements - 1;
        else
            last = last + 1;
            if last >= elements then last = 0;
        V[d] = Elem[operand, last, esize];

__instruction aarch64_integer_pac_autdb_dp_1src
    __encoding aarch64_integer_pac_autdb_dp_1src
        __instruction_set A64
        __field Z 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11011010 11000001 00x111xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean source_is_sp = FALSE;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if !HavePACExt() then
                UNDEFINED;
            
            if Z == '0' then // AUTDB
                if n == 31 then source_is_sp = TRUE;
            else // AUTDZB
                if n != 31 then UNDEFINED;

    __execute
        if source_is_sp then
            X[d] = AuthDB(X[d], SP[]);
        else
            X[d] = AuthDB(X[d], X[n]);

__instruction aarch64_float_arithmetic_round_frint
    __encoding aarch64_float_arithmetic_round_frint
        __instruction_set A64
        __field type1 22 +: 2
        __field rmode 15 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1001xx x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case rmode of
                when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        result = FPRoundInt(operand, FPCR, rounding, exact);
        
        V[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_normal
    __encoding aarch64_memory_single_general_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_NORMAL;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction LD2W_Z.P.BR_Contiguous
    __encoding LD2W_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 001xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field a 23 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 000001xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (a == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 110001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean pair = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            if pair then
                element1 = Elem[concat, 2*e, esize];
                element2 = Elem[concat, (2*e)+1, esize];
            else
                element1 = Elem[operand1, e, esize];
                element2 = Elem[operand2, e, esize];
        
            if minimum then
                Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
            else
                Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);
        
        V[d] = result;

__instruction ST2D_Z.P.BI_Contiguous
    __encoding ST2D_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 1011xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer offset = SInt(imm4);
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction aarch64_float_arithmetic_unary
    __encoding aarch64_float_arithmetic_unary
        __instruction_set A64
        __field type1 22 +: 2
        __field opc 15 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx10000x x10000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            FPUnaryOp fpop;
            case opc of
                when '00' fpop = FPUnaryOp_MOV;
                when '01' fpop = FPUnaryOp_ABS;
                when '10' fpop = FPUnaryOp_NEG;
                when '11' fpop = FPUnaryOp_SQRT;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) result;
        bits(datasize) operand = V[n];
        
        case fpop of
            when FPUnaryOp_MOV  result = operand;
            when FPUnaryOp_ABS  result = FPAbs(operand);
            when FPUnaryOp_NEG  result = FPNeg(operand);
            when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);
        
        V[d] = result;

__instruction FRSQRTE_Z.Z__
    __encoding FRSQRTE_Z.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '01100101 xx001111 001100xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand = Z[n];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_add_sub_long
    __encoding aarch64_vector_arithmetic_binary_disparate_add_sub_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 00x000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o1 == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        integer sum;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            if sub_op then
                sum = element1 - element2;
            else
                sum = element1 + element2;
            Elem[result, e, 2*esize] = sum<2*esize-1:0>;
        
        V[d] = result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 00xxxxxx 1001x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64;
            integer index;
            index = UInt(H:L:M);
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            boolean mulx_op = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_fp_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 1xxxxxxx 1001x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi = M;
            case sz:L of
                when '0x' index = UInt(H:L);
                when '10' index = UInt(H);
                when '11' UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            boolean mulx_op = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 00xxxxxx 1001x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64;
            integer index;
            index = UInt(H:L:M);
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean mulx_op = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 1xxxxxxx 1001x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi = M;
            case sz:L of
                when '0x' index = UInt(H:L);
                when '10' index = UInt(H);
                when '11' UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean mulx_op = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2 = Elem[operand2, index, esize];
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            if mulx_op then
                Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
            else
                Elem[result, e, esize] = FPMul(element1, element2, FPCR);
        
        V[d] = result;

__instruction LASTB_R.P.Z__
    __encoding LASTB_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00000101 xx100001 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer rsize = if esize < 64 then 32 else 64;
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Rd);
            boolean isBefore = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(rsize) result;
        integer last = LastActiveElement(mask, esize);
        
        if isBefore then
            if last < 0 then last = elements - 1;
        else
            last = last + 1;
            if last >= elements then last = 0;
        result = ZeroExtend(Elem[operand, last, esize]);
        
        X[d] = result;

__instruction aarch64_memory_vector_single_no_wb
    __encoding aarch64_memory_vector_single_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 0xx00000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_single_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field R 21 +: 1
        __field Rm 16 +: 5
        __field opcode 13 +: 3
        __field S 12 +: 1
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        integer scale = UInt(opcode<2:1>);
        integer selem = UInt(opcode<0>:R) + 1;
        boolean replicate = FALSE;
        integer index;
        
        case scale of
            when 3
                // load and replicate
                if L == '0' || S == '1' then UNDEFINED;
                scale = UInt(size);
                replicate = TRUE;
            when 0
                index = UInt(Q:S:size);         // B[0-15]
            when 1
                if size<0> == '1' then UNDEFINED;
                index = UInt(Q:S:size<1>);      // H[0-7]
            when 2
                if size<1> == '1' then UNDEFINED;
                if size<0> == '0' then
                    index = UInt(Q:S);          // S[0-3]
                else
                    if S == '1' then UNDEFINED;
                    index = UInt(Q);            // D[0-1]
                    scale = 3;
        
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << scale;
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(128) rval;
        bits(esize) element;
        constant integer ebytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        if replicate then
            // load and replicate to all elements
            for s = 0 to selem-1
                element = Mem[address + offs, ebytes, AccType_VEC];
                // replicate to fill 128- or 64-bit register
                V[t] = Replicate(element, datasize DIV esize);
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        else
            // load/store one element per register
            for s = 0 to selem-1
                rval = V[t];
                if memop == MemOp_LOAD then
                    // insert into one lane of 128-bit register
                    Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                    V[t] = rval;
                else // memop == MemOp_STORE
                    // extract from one lane of 128-bit register
                    Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                offs = offs + ebytes;
                t = (t + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_vector_shift_right_insert_sisd
    __encoding aarch64_vector_shift_right_insert_sisd
        __instruction_set A64
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111111 0xxxxxxx 010001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = (esize * 2) - UInt(immh:immb);

    __encoding aarch64_vector_shift_right_insert_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101111 0xxxxxxx 010001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = (esize * 2) - UInt(immh:immb);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) operand2 = V[d];
        bits(datasize) result;
        bits(esize) mask = LSR(Ones(esize), shift);
        bits(esize) shifted;
        
        for e = 0 to elements-1
            shifted = LSR(Elem[operand, e, esize], shift);
            Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp16_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field E 23 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x10xxxxx 0010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field E 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 1110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field E 23 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 0010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field E 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 1110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if abs then
                element1 = FPAbs(element1);
                element2 = FPAbs(element2);
            case cmp of
                when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
                when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
                when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction EOR_Z.ZI__
    __encoding EOR_Z.ZI__
        __instruction_set A64
        __field imm13 5 +: 13
        __field Zdn 0 +: 5
        __opcode '00000101 010000xx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer dn = UInt(Zdn);
            bits(64) imm;
            (imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV 64;
        bits(VL) operand = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(64) element1 = Elem[operand, e, 64];
            Elem[result, e, 64] = element1 EOR imm;
        
        Z[dn] = result;

__instruction LDNF1SB_Z.P.BI_S16
    __encoding LDNF1SB_Z.P.BI_S16
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1101xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __encoding LDNF1SB_Z.P.BI_S32
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1011xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __encoding LDNF1SB_Z.P.BI_S64
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1001xxxx 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 8;
            boolean unsigned = FALSE;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(VL) orig = Z[t];
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        boolean fault = FALSE;
        boolean faulted = FALSE;
        boolean unknown = FALSE;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                // MemNF[] will return fault=TRUE if access is not performed for any reason
                (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
            else
                (data, fault) = (Zeros(msize), FALSE);
        
            // FFR elements set to FALSE following a supressed access/fault
            faulted = faulted || fault;
            if faulted then
                ElemFFR[e, esize] = '0';
        
            // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
            unknown = unknown || ElemFFR[e, esize] == '0';
            if unknown then
                if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
                    Elem[result, e, esize] = Extend(data, esize, unsigned);
                elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
                    Elem[result, e, esize] = Zeros();
                else  // merge
                    Elem[result, e, esize] = Elem[orig, e, esize];
            else
                Elem[result, e, esize] = Extend(data, esize, unsigned);
        
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction aarch64_integer_pac_pacia_dp_1src
    __encoding aarch64_integer_pac_pacia_dp_1src
        __instruction_set A64
        __field Z 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11011010 11000001 00x000xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean source_is_sp = FALSE;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if !HavePACExt() then
                UNDEFINED;
            
            if Z == '0' then // PACIA
                if n == 31 then source_is_sp = TRUE;
            else // PACIZA
                if n != 31 then UNDEFINED;

    __encoding aarch64_integer_pac_pacia_hint
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            integer d;
            integer n;
            boolean source_is_sp = FALSE;
            
            case CRm:op2 of
                when '0011 000' // PACIAZ 
                    d = 30;
                    n = 31;
                when '0011 001' // PACIASP
                    d = 30;
                    source_is_sp = TRUE;
                    if HaveBTIExt() then
                        // Check for branch target compatibility between PSTATE.BTYPE
                        // and implicit branch target of PACIASP instruction.
                        BTypeCompatible = BTypeCompatible_PACIXSP();
            
                when '0001 000' // PACIA1716
                    d = 17;
                    n = 16;
                when '0001 010' SEE "PACIB";
                when '0001 100' SEE "AUTIA";
                when '0001 110' SEE "AUTIB";
                when '0011 01x' SEE "PACIB";
                when '0011 10x' SEE "AUTIA";
                when '0011 11x' SEE "AUTIB";
                when '0000 111' SEE "XPACLRI";

    __execute
        if HavePACExt() then
            if source_is_sp then
                X[d] = AddPACIA(X[d], SP[]);
            else
                X[d] = AddPACIA(X[d], X[n]);

__instruction aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 010xxxxx 001111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_binary_uniform_recps_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 0x1xxxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 010xxxxx 001111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __encoding aarch64_vector_arithmetic_binary_uniform_recps_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 0x1xxxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = FPRecipStepFused(element1, element2);
        
        V[d] = result;

__instruction aarch64_integer_arithmetic_mul_uniform_add_sub
    __encoding aarch64_integer_arithmetic_mul_uniform_add_sub
        __instruction_set A64
        __field sf 31 +: 1
        __field Rm 16 +: 5
        __field o0 15 +: 1
        __field Ra 10 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011011 000xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer a = UInt(Ra);
            integer destsize = if sf == '1' then 64 else 32;
            integer datasize = destsize;
            boolean sub_op = (o0 == '1');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(destsize) operand3 = X[a];
        
        integer result;
        
        if sub_op then
            result = UInt(operand3) - (UInt(operand1) * UInt(operand2));
        else
            result = UInt(operand3) + (UInt(operand1) * UInt(operand2));
        
        X[d] = result<destsize-1:0>;

__instruction aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
    __encoding aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
        __instruction_set A64
        __field Q 30 +: 1
        __field opc2 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx1xxxxx 000111xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            VBitOp op;
            
            case opc2 of
                when '00' op = VBitOp_VEOR;
                when '01' op = VBitOp_VBSL;
                when '10' op = VBitOp_VBIT;
                when '11' op = VBitOp_VBIF;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1;
        bits(datasize) operand2;
        bits(datasize) operand3;
        bits(datasize) operand4 = V[n];
        
        case op of
            when VBitOp_VEOR
                operand1 = V[m];
                operand2 = Zeros();
                operand3 = Ones();
            when VBitOp_VBSL
                operand1 = V[m];
                operand2 = operand1;
                operand3 = V[d];
            when VBitOp_VBIT
                operand1 = V[d];
                operand2 = operand1;
                operand3 = V[m];
            when VBitOp_VBIF
                operand1 = V[d];
                operand2 = operand1;
                operand3 = NOT(V[m]);
        
        V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);

__instruction aarch64_vector_reduce_int_max
    __encoding aarch64_vector_reduce_int_max
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 16 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx11000x 101010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '100' then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean min = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        integer maxmin;
        integer element;
        
        maxmin = Int(Elem[operand, 0, esize], unsigned);
        for e = 1 to elements-1
            element = Int(Elem[operand, e, esize], unsigned);
            maxmin = if min then Min(maxmin, element) else Max(maxmin, element);
        
        V[d] = maxmin<esize-1:0>;

__instruction aarch64_vector_reduce_add_simd
    __encoding aarch64_vector_reduce_add_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx110001 101110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '100' then UNDEFINED;
            if size == '11' then UNDEFINED;
            
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            ReduceOp op = ReduceOp_ADD;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction UQDECW_R.RS_UW
    __encoding UQDECW_R.RS_UW
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1010xxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 32;

    __encoding UQDECW_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1011xxxx 111111xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction FMLA_Z.P.ZZZ__
    __encoding FMLA_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zda 0 +: 5
        __opcode '01100101 xx1xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer da = UInt(Zda);
            boolean op1_neg = FALSE;
            boolean op3_neg = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[da];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            bits(esize) element3 = Elem[operand3, e, esize];
            
            if ElemP[mask, e, esize] == '1' then
                if op1_neg then element1 = FPNeg(element1);
                if op3_neg then element3 = FPNeg(element3);
                Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
            else
                Elem[result, e, esize] = element3;
        
        Z[da] = result;

__instruction FMINV_V.P.Z__
    __encoding FMINV_V.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '01100101 xx000111 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);

    __execute
        CheckSVEEnabled();
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(esize) identity = FPInfinity('0');
        
        V[d] = ReducePredicated(ReduceOp_FMIN, operand, mask, identity);

__instruction aarch64_vector_logical
    __encoding aarch64_vector_logical
        __instruction_set A64
        __field Q 30 +: 1
        __field op 29 +: 1
        __field a 18 +: 1
        __field b 17 +: 1
        __field c 16 +: 1
        __field cmode 12 +: 4
        __field d 9 +: 1
        __field e 8 +: 1
        __field f 7 +: 1
        __field g 6 +: 1
        __field h 5 +: 1
        __field Rd 0 +: 5
        __opcode '0xx01111 00000xxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer rd = UInt(Rd);
            
            integer datasize = if Q == '1' then 128 else 64;
            bits(datasize) imm;
            bits(64) imm64;
            
            ImmediateOp operation;
            case cmode:op of
                when '0xx00' operation = ImmediateOp_MOVI;
                when '0xx01' operation = ImmediateOp_MVNI;
                when '0xx10' operation = ImmediateOp_ORR;
                when '0xx11' operation = ImmediateOp_BIC;
                when '10x00' operation = ImmediateOp_MOVI;
                when '10x01' operation = ImmediateOp_MVNI;
                when '10x10' operation = ImmediateOp_ORR;
                when '10x11' operation = ImmediateOp_BIC;
                when '110x0' operation = ImmediateOp_MOVI;
                when '110x1' operation = ImmediateOp_MVNI;
                when '1110x' operation = ImmediateOp_MOVI;
                when '11110' operation = ImmediateOp_MOVI;
                when '11111' 
                    // FMOV Dn,#imm is in main FP instruction set
                    if Q == '0' then UNDEFINED;
                    operation = ImmediateOp_MOVI;
            
            imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
            imm = Replicate(imm64, datasize DIV 64);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand;
        bits(datasize) result;
        
        case operation of
            when ImmediateOp_MOVI
                result = imm;
            when ImmediateOp_MVNI
                result = NOT(imm);
            when ImmediateOp_ORR
                operand = V[rd];
                result = operand OR imm;
            when ImmediateOp_BIC
                operand = V[rd];
                result = operand AND NOT(imm);
        
        V[rd] = result;

__instruction LDNT1W_Z.P.BI_Contiguous
    __encoding LDNT1W_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 0000xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        constant integer mbytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction ST4H_Z.P.BR_Contiguous
    __encoding ST4H_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 111xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;
            offset = offset + nreg;

__instruction aarch64_integer_arithmetic_div
    __encoding aarch64_integer_arithmetic_div
        __instruction_set A64
        __field sf 31 +: 1
        __field Rm 16 +: 5
        __field o1 10 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011010 110xxxxx 00001xxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean unsigned = (o1 == '0');

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        integer result;
        
        if IsZero(operand2) then
            result = 0;
        else
            result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));
        
        X[d] = result<datasize-1:0>;

__instruction aarch64_integer_arithmetic_add_sub_carry
    __encoding aarch64_integer_arithmetic_add_sub_carry
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field S 29 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx11010 000xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            boolean setflags = (S == '1');

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bits(4) nzcv;
        
        if sub_op then
            operand2 = NOT(operand2);
        
        (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);
        
        if setflags then 
            PSTATE.<N,Z,C,V> = nzcv;
        
        X[d] = result;

__instruction FSUBR_Z.P.ZS__
    __encoding FSUBR_Z.P.ZS__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field i1 5 +: 1
        __field Zdn 0 +: 5
        __opcode '01100101 xx011011 100xxx00 00xxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPSub(imm, element1, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction ADD_Z.ZZ__
    __encoding ADD_Z.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer n = UInt(Zn);
            integer m = UInt(Zm);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[n];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            Elem[result, e, esize] = element1 + element2;
        
        Z[d] = result;

__instruction aarch64_vector_transfer_vector_insert
    __encoding aarch64_vector_transfer_vector_insert
        __instruction_set A64
        __field imm5 16 +: 5
        __field imm4 11 +: 4
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01101110 000xxxxx 0xxxx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer size = LowestSetBit(imm5);
            if size > 3 then UNDEFINED;
            
            integer dst_index = UInt(imm5<4:size+1>);
            integer src_index = UInt(imm4<3:size>);
            integer idxdsize = if imm4<3> == '1' then 128 else 64; 
            // imm4<size-1:0> is IGNORED 
            
            integer esize = 8 << size;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(idxdsize) operand = V[n];
        bits(128) result;
        
        result = V[d];
        Elem[result, dst_index, esize] = Elem[operand, src_index, esize];
        V[d] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_unpriv
    __encoding aarch64_memory_single_general_immediate_signed_offset_unpriv
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx0xxxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        
        unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
        unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
        
        user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
        if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
            acctype = AccType_UNPRIV;
        else
            acctype = AccType_NORMAL;
        
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction ST3H_Z.P.BI_Contiguous
    __encoding ST3H_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 1101xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer offset = SInt(imm4);
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction aarch64_memory_single_simdfp_immediate_signed_offset_normal
    __encoding aarch64_memory_single_simdfp_immediate_signed_offset_normal
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111100 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(opc<1>:size);
            if scale > 4 then UNDEFINED;
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_VEC;
        MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        CheckFPAdvSIMDEnabled64();
        bits(64) address;
        bits(datasize) data;
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                data = V[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                V[t] = data;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_shift_conv_int_sisd
    __encoding aarch64_vector_shift_conv_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 111001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
            integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
            integer datasize = esize;
            integer elements = 1;
            
            integer fracbits = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            FPRounding rounding = FPRoundingMode(FPCR);

    __encoding aarch64_vector_shift_conv_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 111001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer fracbits = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            FPRounding rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_float_arithmetic_max_min
    __encoding aarch64_float_arithmetic_max_min
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field op 12 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '00011110 xx1xxxxx 01xx10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            FPMaxMinOp operation;
            case op of
                when '00' operation = FPMaxMinOp_MAX;
                when '01' operation = FPMaxMinOp_MIN;
                when '10' operation = FPMaxMinOp_MAXNUM;
                when '11' operation = FPMaxMinOp_MINNUM;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) result;
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        
        case operation of
            when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);
            when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);
            when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);
            when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);
        
        V[d] = result;

__instruction UMINV_R.P.Z__
    __encoding UMINV_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000100 xx001011 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        integer minimum = if unsigned then (2^esize - 1) else (2^(esize-1) - 1);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer element = Int(Elem[operand, e, esize], unsigned);
                minimum = Min(minimum, element);
        
        V[d] = minimum<esize-1:0>;

__instruction aarch64_vector_crypto_sha512_sha512su0
    __encoding aarch64_vector_crypto_sha512_sha512su0
        __instruction_set A64
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11001110 11000000 100000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSHA512Ext() then UNDEFINED;
            integer d = UInt(Rd);
            integer n = UInt(Rn);

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(64) sig0;
        bits(128) Vtmp;
        bits(128) X = V[n];
        bits(128) W = V[d]; 
        sig0 = ROR(W<127:64>, 1) EOR ROR(W<127:64>, 8) EOR ('0000000':W<127:71>);
        Vtmp<63:0> = W<63:0> + sig0;
        sig0 = ROR(X<63:0>, 1) EOR ROR(X<63:0>, 8) EOR ('0000000':X<63:7>);
        Vtmp<127:64> = W<127:64> + sig0;
        V[d] = Vtmp;

__instruction aarch64_system_exceptions_debug_exception
    __encoding aarch64_system_exceptions_debug_exception
        __instruction_set A64
        __field imm16 5 +: 16
        __field LL 0 +: 2
        __opcode '11010100 101xxxxx xxxxxxxx xxx000xx'
        __guard TRUE
        __decode
            bits(2) target_level = LL;
            if LL == '00' then UNDEFINED;
            if !Halted() then AArch64.UndefinedFault();

    __execute
        DCPSInstruction(target_level);

__instruction aarch64_memory_exclusive_single
    __encoding aarch64_memory_exclusive_single
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 0x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
            boolean pair = FALSE;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = if pair then elsize * 2 else elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        boolean rn_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && pair && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE then
            if s == t || (pair && s == t2) then
                Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
                    when Constraint_NONE       rt_unknown = FALSE;   // store original value
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
            if s == n && n != 31 then
                Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
                assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                case c of
                    when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
                    when Constraint_NONE       rn_unknown = FALSE;   // address is original base
                    when Constraint_UNDEF      UNDEFINED;
                    when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        elsif rn_unknown then
            address = bits(64) UNKNOWN;
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                elsif pair then
                    bits(datasize DIV 2) el1 = X[t];
                    bits(datasize DIV 2) el2 = X[t2];
                    data = if BigEndian() then el1 : el2 else el2 : el1;
                else
                    data = X[t];
        
                bit status = '1';
                // Check whether the Exclusives monitors are set to include the
                // physical memory locations corresponding to virtual address
                // range [address, address+dbytes-1].
                if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                    // This atomic write will be rejected if it does not refer
                    // to the same physical locations after address translation.
                    Mem[address, dbytes, acctype] = data;
                    status = ExclusiveMonitorsStatus();
                X[s] = ZeroExtend(status, 32);
        
            when MemOp_LOAD
                // Tell the Exclusives monitors to record a sequence of one or more atomic
                // memory reads from virtual address range [address, address+dbytes-1].
                // The Exclusives monitor will only be set if all the reads are from the
                // same dbytes-aligned physical address, to allow for the possibility of
                // an atomicity break if the translation is changed between reads.
                AArch64.SetExclusiveMonitors(address, dbytes);
        
                if pair then
                    if rt_unknown then
                        // ConstrainedUNPREDICTABLE case
                        X[t]  = bits(datasize) UNKNOWN;
                    elsif elsize == 32 then
                        // 32-bit load exclusive pair (atomic)
                        data = Mem[address, dbytes, acctype];
                        if BigEndian() then
                            X[t]  = data<datasize-1:elsize>;
                            X[t2] = data<elsize-1:0>;
                        else
                            X[t]  = data<elsize-1:0>;
                            X[t2] = data<datasize-1:elsize>;
                    else // elsize == 64
                        // 64-bit load exclusive pair (not atomic),
                        // but must be 128-bit aligned
                        if address != Align(address, dbytes) then
                            iswrite = FALSE;
                            secondstage = FALSE;
                            AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                        X[t]  = Mem[address + 0, 8, acctype];
                        X[t2] = Mem[address + 8, 8, acctype];
                else
                    data = Mem[address, dbytes, acctype];
                    X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_fp16_round
    __encoding aarch64_vector_arithmetic_unary_fp16_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __encoding aarch64_vector_arithmetic_unary_float_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
        
        V[d] = result;

__instruction aarch64_vector_reduce_int_max
    __encoding aarch64_vector_reduce_int_max
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 16 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx11000x 101010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size:Q == '100' then UNDEFINED;
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean min = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        integer maxmin;
        integer element;
        
        maxmin = Int(Elem[operand, 0, esize], unsigned);
        for e = 1 to elements-1
            element = Int(Elem[operand, e, esize], unsigned);
            maxmin = if min then Min(maxmin, element) else Max(maxmin, element);
        
        V[d] = maxmin<esize-1:0>;

__instruction EORV_R.P.Z__
    __encoding EORV_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Vd 0 +: 5
        __opcode '00000100 xx011001 001xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Vd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[n];
        bits(esize) result = Zeros(esize);
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                result = result EOR Elem[operand, e, esize];
        
        V[d] = result;

__instruction FDIVR_Z.P.ZZ__
    __encoding FDIVR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx001100 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPDiv(element2, element1, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_system_exceptions_debug_exception
    __encoding aarch64_system_exceptions_debug_exception
        __instruction_set A64
        __field imm16 5 +: 16
        __field LL 0 +: 2
        __opcode '11010100 101xxxxx xxxxxxxx xxx000xx'
        __guard TRUE
        __decode
            bits(2) target_level = LL;
            if LL == '00' then UNDEFINED;
            if !Halted() then AArch64.UndefinedFault();

    __execute
        DCPSInstruction(target_level);

__instruction aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 101x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPDecodeRounding(o1:o2);
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction PNEXT_P.P.P__
    __encoding PNEXT_P.P.P__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Pdn 0 +: 4
        __opcode '00100101 xx011001 1100010x xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Pdn);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(PL) operand = P[dn];
        bits(PL) result;
        
        integer next = LastActiveElement(operand, esize) + 1;
        
        while next < elements && (ElemP[mask, next, esize] == '0') do
            next = next + 1;
        
        result = Zeros();
        if next < elements then
            ElemP[result, next, esize] = '1';
        
        PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[dn] = result;

__instruction LDNT1D_Z.P.BI_Contiguous
    __encoding LDNT1D_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 1000xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 64;
            integer offset = SInt(imm4);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(VL) result;
        constant integer mbytes = esize DIV 8;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = result;

__instruction aarch64_float_compare_cond
    __encoding aarch64_float_compare_cond
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field cond 12 +: 4
        __field Rn 5 +: 5
        __field op 4 +: 1
        __field nzcv 0 +: 4
        __opcode '00011110 xx1xxxxx xxxx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean signal_all_nans = (op == '1');
            bits(4) condition = cond;
            bits(4) flags = nzcv;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2;
        
        operand2 = V[m];
        
        if ConditionHolds(condition) then
            flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);
        PSTATE.<N,Z,C,V> = flags;

__instruction aarch64_vector_arithmetic_binary_uniform_shift_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_shift_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');
            if S == '0' && size != '11' then UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_shift_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        integer round_const = 0;
        integer shift;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            shift = SInt(Elem[operand2, e, esize]<7:0>);
            if rounding then
                round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift 
            element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
            if saturating then
                (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                if sat then FPSR.QC = '1';
            else
                Elem[result, e, esize] = element<esize-1:0>;
        
        V[d] = result;

__instruction MSB_Z.P.ZZZ__
    __encoding MSB_Z.P.ZZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Za 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx0xxxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            integer a = UInt(Za);
            boolean sub_op = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) operand3 = Z[a];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = UInt(Elem[operand1, e, esize]);
            integer element2 = UInt(Elem[operand2, e, esize]);
            if ElemP[mask, e, esize] == '1' then
                integer product = element1 * element2;
                if sub_op then
                    Elem[result, e, esize] = Elem[operand3, e, esize] - product;
                else
                    Elem[result, e, esize] = Elem[operand3, e, esize] + product;
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_integer_logical_immediate
    __encoding aarch64_integer_logical_immediate
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 29 +: 2
        __field N 22 +: 1
        __field immr 16 +: 6
        __field imms 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'xxx10010 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer datasize = if sf == '1' then 64 else 32;
            boolean setflags;
            LogicalOp op;
            case opc of
                when '00' op = LogicalOp_AND; setflags = FALSE;
                when '01' op = LogicalOp_ORR; setflags = FALSE;
                when '10' op = LogicalOp_EOR; setflags = FALSE;
                when '11' op = LogicalOp_AND; setflags = TRUE;
            
            bits(datasize) imm;
            if sf == '0' && N != '0' then UNDEFINED;
            (imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

    __execute
        bits(datasize) result;
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = imm;
        
        case op of
            when LogicalOp_AND result = operand1 AND operand2;
            when LogicalOp_ORR result = operand1 OR  operand2;
            when LogicalOp_EOR result = operand1 EOR operand2;
        
        if setflags then
            PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
        
        if d == 31 && !setflags then
            SP[] = result;
        else
            X[d] = result;

__instruction CLASTB_R.P.Z__
    __encoding CLASTB_R.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000101 xx110001 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Rdn);
            integer m = UInt(Zm);
            integer csize = if esize < 64 then 32 else 64;
            boolean isBefore = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(esize) operand1 = X[dn];
        bits(VL) operand2 = Z[m];
        bits(csize) result;
        integer last = LastActiveElement(mask, esize);
        
        if last < 0 then
            result = ZeroExtend(operand1);
        else
            if !isBefore then
                last = last + 1;
                if last >= elements then last = 0;
            result = ZeroExtend(Elem[operand2, last, esize]);
        
        X[dn] = result;

__instruction FCADD_Z.P.ZZ__
    __encoding FCADD_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field rot 16 +: 1
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100100 xx00000x 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);
            boolean sub_i = (rot == '0');
            boolean sub_r = (rot == '1');

    __execute
        CheckSVEEnabled();
        integer pairs = VL DIV (2 * esize);
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for p = 0 to pairs-1
            acc_r  = Elem[operand1, 2 * p + 0, esize];
            acc_i  = Elem[operand1, 2 * p + 1, esize];
            elt2_r = Elem[operand2, 2 * p + 0, esize];
            elt2_i = Elem[operand2, 2 * p + 1, esize];
            if ElemP[mask, 2 * p + 0, esize] == '1' then
                if sub_i then elt2_i = FPNeg(elt2_i);
                acc_r = FPAdd(acc_r, elt2_i, FPCR);
            if ElemP[mask, 2 * p + 1, esize] == '1' then
                if sub_r then elt2_r = FPNeg(elt2_r);
                acc_i = FPAdd(acc_i, elt2_r, FPCR);
            Elem[result, 2 * p + 0, esize] = acc_r;
            Elem[result, 2 * p + 1, esize] = acc_i;
        
        Z[dn] = result;

__instruction WHILELO_P.P.RR__
    __encoding WHILELO_P.P.RR__
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field sf 12 +: 1
        __field Rn 5 +: 5
        __field Pd 0 +: 4
        __opcode '00100101 xx1xxxxx 000x11xx xxx0xxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer rsize = 32 << UInt(sf);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer d = UInt(Pd);
            boolean unsigned = TRUE;
            SVECmp op = Cmp_LT;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = Ones(PL);
        bits(rsize) operand1 = X[n];
        bits(rsize) operand2 = X[m];
        bits(PL) result;
        boolean last = TRUE;
        
        for e = 0 to elements-1
            boolean cond;
            case op of
                when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));
                when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));
        
            last = last && cond;
            ElemP[result, e, esize] = if last then '1' else '0';
            operand1 = operand1 + 1;
        
        PSTATE.<N,Z,C,V> = PredTest(mask, result, esize);
        P[d] = result;

__instruction aarch64_vector_arithmetic_unary_float_narrow
    __encoding aarch64_vector_arithmetic_unary_float_narrow
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 0x100001 011010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16 << UInt(sz);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(2*datasize) operand = V[n];
        bits(datasize) result;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR);
        
        Vpart[d, part] = result;

__instruction aarch64_memory_single_general_immediate_signed_pac
    __encoding aarch64_memory_single_general_immediate_signed_pac
        __instruction_set A64
        __field size 30 +: 2
        __field M 23 +: 1
        __field S 22 +: 1
        __field imm9 12 +: 9
        __field W 11 +: 1
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx xxxxx1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HavePACExt() || size != '11' then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            boolean wback = (W == '1');
            boolean use_key_a = (M == '0');
            bits(10) S10 = S:imm9;
            integer scale = 3;
            bits(64) offset = LSL(SignExtend(S10, 64), scale);
            boolean tag_checked = wback || n != 31;

    __execute
        bits(64) address;
        bits(64) data;
        boolean wb_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if use_key_a then
            address = AuthDA(address, X[31]);
        else
            address = AuthDB(address, X[31]);
        
        address = address + offset;
        data = Mem[address, 8, AccType_NORMAL];
        X[t] = data;
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction LSR_Z.P.ZI__
    __encoding LSR_Z.P.ZI__
        __instruction_set A64
        __field tszh 22 +: 2
        __field Pg 10 +: 3
        __field tszl 8 +: 2
        __field imm3 5 +: 3
        __field Zdn 0 +: 5
        __opcode '00000100 xx000001 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            bits(4) tsize = tszh:tszl;
            case tsize of
                when '0000' UNDEFINED;
                when '0001' esize = 8;
                when '001x' esize = 16;
                when '01xx' esize = 32;
                when '1xxx' esize = 64;
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer shift = (2 * esize) - UInt(tsize:imm3);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(PL) mask = P[g];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = LSR(element1, shift);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction aarch64_integer_pac_autda_dp_1src
    __encoding aarch64_integer_pac_autda_dp_1src
        __instruction_set A64
        __field Z 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11011010 11000001 00x110xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean source_is_sp = FALSE;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if !HavePACExt() then
                UNDEFINED;
            
            if Z == '0' then // AUTDA
                if n == 31 then source_is_sp = TRUE;
            else // AUTDZA
                if n != 31 then UNDEFINED;

    __execute
        if source_is_sp then
            X[d] = AuthDA(X[d], SP[]);
        else
            X[d] = AuthDA(X[d], X[n]);

__instruction aarch64_vector_crypto_sha3op_sha1_hash_choose
    __encoding aarch64_vector_crypto_sha3op_sha1_hash_choose
        __instruction_set A64
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 000xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if !HaveSHA1Ext() then UNDEFINED;

    __execute
        AArch64.CheckFPAdvSIMDEnabled();
        
        bits(128) X = V[d];
        bits(32)  Y = V[n];     // Note: 32 not 128 bits wide
        bits(128) W = V[m];
        bits(32)  t;
        
        for e = 0 to 3
            t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);
            Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
            X<63:32> = ROL(X<63:32>, 30);
            <Y, X> = ROL(Y : X, 32);
        V[d] = X;

__instruction aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 00xxxxxx 1001x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64;
            integer index;
            index = UInt(H:L:M);
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            boolean mulx_op = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_fp_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 1xxxxxxx 1001x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi = M;
            case sz:L of
                when '0x' index = UInt(H:L);
                when '10' index = UInt(H);
                when '11' UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            boolean mulx_op = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 00xxxxxx 1001x0xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer idxdsize = if H == '1' then 128 else 64;
            integer index;
            index = UInt(H:L:M);
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean mulx_op = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 1xxxxxxx 1001x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi = M;
            case sz:L of
                when '0x' index = UInt(H:L);
                when '10' index = UInt(H);
                when '11' UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean mulx_op = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(idxdsize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2 = Elem[operand2, index, esize];
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            if mulx_op then
                Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
            else
                Elem[result, e, esize] = FPMul(element1, element2, FPCR);
        
        V[d] = result;

__instruction LSLR_Z.P.ZZ__
    __encoding LSLR_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 xx010111 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = UInt(Elem[operand1, e, esize]);
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = LSL(element2, element1);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction INCD_Z.ZS__
    __encoding INCD_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1111xxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding INCH_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 0111xxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 16;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __encoding INCW_Z.ZS__
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Zdn 0 +: 5
        __opcode '00000100 1011xxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 32;
            integer dn = UInt(Zdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        integer count = DecodePredCount(pat, esize);
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = Elem[operand1, e, esize] + (count * imm);
        
        Z[dn] = result;

__instruction aarch64_memory_single_general_immediate_signed_offset_lda_stl
    __encoding aarch64_memory_single_general_immediate_signed_offset_lda_stl
        __instruction_set A64
        __field size 30 +: 2
        __field opc 22 +: 2
        __field imm9 12 +: 9
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx011001 xx0xxxxx xxxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback = FALSE;
            boolean postindex = FALSE;
            integer scale = UInt(size);
            bits(64) offset = SignExtend(imm9, 64);

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        AccType acctype = AccType_ORDERED;
        MemOp memop;
        boolean signed;
        integer regsize;
        
        if opc<1> == '0' then
            // store or zero-extending load
            memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
            regsize = if size == '11' then 64 else 32;
            signed = FALSE;
        else
            if size == '11' then
                memop = MemOp_PREFETCH;
                if opc<0> == '1' then UNDEFINED;
            else
                // sign-extending load
                memop = MemOp_LOAD;
                if size == '10' && opc<0> == '1' then UNDEFINED;
                regsize = if opc<0> == '1' then 32 else 64;
                signed = TRUE;
        
        integer datasize = 8 << scale;
        boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
    __execute
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        bits(64) address;
        bits(datasize) data;
        
        boolean wb_unknown = FALSE;
        boolean rt_unknown = FALSE;
        
        if memop == MemOp_LOAD && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
                when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if memop == MemOp_STORE && wback && n == t && n != 31 then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
            assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
                when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            if memop != MemOp_PREFETCH then CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                if rt_unknown then
                    data = bits(datasize) UNKNOWN;
                else
                    data = X[t];
                Mem[address, datasize DIV 8, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, datasize DIV 8, acctype];
                if signed then
                    X[t] = SignExtend(data, regsize);
                else
                    X[t] = ZeroExtend(data, regsize);
        
            when MemOp_PREFETCH
                Prefetch(address, t<4:0>);
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            elsif postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_vector_shift_right_sisd
    __encoding aarch64_vector_shift_right_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __encoding aarch64_vector_shift_right_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) operand2;
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        
        operand2 = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
            Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
        
        V[d] = result;

__instruction DECP_Z.P.Z__
    __encoding DECP_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Zdn 0 +: 5
        __opcode '00100101 xx101101 1000000x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[dn];
        bits(VL) result;
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = Elem[operand, e, esize] - count;
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
        __instruction_set A64
        __field Q 30 +: 1
        __field a 23 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 x10xxxxx 000011xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (a == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
        __instruction_set A64
        __field Q 30 +: 1
        __field op 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 xx1xxxxx 110011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean sub_op = (op == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if sub_op then element1 = FPNeg(element1);
            Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
        
        V[d] = result;

__instruction aarch64_memory_atomicops_swp
    __encoding aarch64_memory_atomicops_swp
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 100000xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        Mem[address, datasize DIV 8, stacctype] = X[s];
        
        X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_fp16_round
    __encoding aarch64_vector_arithmetic_unary_fp16_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x1111001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __encoding aarch64_vector_arithmetic_unary_float_round
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field o2 23 +: 1
        __field sz 22 +: 1
        __field o1 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100001 100x10xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean exact = FALSE;
            FPRounding rounding;
            case U:o1:o2 of
                when '0xx' rounding = FPDecodeRounding(o1:o2);
                when '100' rounding = FPRounding_TIEAWAY;
                when '101' UNDEFINED;
                when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                when '111' rounding = FPRoundingMode(FPCR);

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
        
        V[d] = result;

__instruction LD4H_Z.P.BI_Contiguous
    __encoding LD4H_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 1110xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 16;
            integer offset = SInt(imm4);
            integer nreg = 4;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..3] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction UQINCD_R.RS_UW
    __encoding UQINCD_R.RS_UW
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1110xxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 32;

    __encoding UQINCD_R.RS_X
        __instruction_set A64
        __field imm4 16 +: 4
        __field pattern 5 +: 5
        __field Rdn 0 +: 5
        __opcode '00000100 1111xxxx 111101xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 64;
            integer dn = UInt(Rdn);
            bits(5) pat = pattern;
            integer imm = UInt(imm4) + 1;
            boolean unsigned = TRUE;
            integer ssize = 64;

    __execute
        CheckSVEEnabled();
        integer count = DecodePredCount(pat, esize);
        bits(ssize) operand1 = X[dn];
        bits(ssize) result;
        
        integer element1 = Int(operand1, unsigned);
        (result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
        X[dn] = Extend(result, 64, unsigned);

__instruction aarch64_memory_pair_simdfp_post_idx
    __encoding aarch64_memory_pair_simdfp_post_idx
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101100 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = TRUE;
            boolean postindex = TRUE;

    __encoding aarch64_memory_pair_simdfp_pre_idx
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101101 1xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = TRUE;
            boolean postindex = FALSE;

    __encoding aarch64_memory_pair_simdfp_offset
        __instruction_set A64
        __field opc 30 +: 2
        __field L 22 +: 1
        __field imm7 15 +: 7
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx101101 0xxxxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            boolean wback  = FALSE;
            boolean postindex = FALSE;

    __postdecode
        integer n = UInt(Rn);
        integer t = UInt(Rt);
        integer t2 = UInt(Rt2);
        AccType acctype = AccType_VEC;
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        if opc == '11' then UNDEFINED;
        integer scale = 2 + UInt(opc);
        integer datasize = 8 << scale;
        bits(64) offset = LSL(SignExtend(imm7, 64), scale);
        boolean tag_checked = wback || n != 31;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(datasize) data1;
        bits(datasize) data2;
        constant integer dbytes = datasize DIV 8;
        boolean rt_unknown = FALSE;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if memop == MemOp_LOAD && t == t2 then
            Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
            assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
            case c of
                when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
                when Constraint_UNDEF      UNDEFINED;
                when Constraint_NOP        EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        if ! postindex then
            address = address + offset;
        
        case memop of
            when MemOp_STORE
                data1 = V[t];
                data2 = V[t2];
                Mem[address + 0     , dbytes, acctype] = data1;
                Mem[address + dbytes, dbytes, acctype] = data2;
        
            when MemOp_LOAD
                data1 = Mem[address + 0     , dbytes, acctype];
                data2 = Mem[address + dbytes, dbytes, acctype];
                if rt_unknown then
                    data1 = bits(datasize) UNKNOWN;
                    data2 = bits(datasize) UNKNOWN;
                V[t]  = data1;
                V[t2] = data2;
        
        if wback then
            if postindex then
                address = address + offset;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_system_monitors
    __encoding aarch64_system_monitors
        __instruction_set A64
        __field CRm 8 +: 4
        __opcode '11010101 00000011 0011xxxx 01011111'
        __guard TRUE
        __decode
            // CRm field is ignored

    __execute
        ClearExclusiveLocal(ProcessorID());

__instruction FABS_Z.P.Z__
    __encoding FABS_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx011100 101xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Zn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand  = Z[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            bits(esize) element = Elem[operand, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPAbs(element);
        
        Z[d] = result;

__instruction aarch64_vector_arithmetic_binary_disparate_mul_product
    __encoding aarch64_vector_arithmetic_binary_disparate_mul_product
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(datasize)   operand2 = Vpart[m, part];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;
        
        V[d] = result;

__instruction aarch64_integer_pac_pacib_dp_1src
    __encoding aarch64_integer_pac_pacib_dp_1src
        __instruction_set A64
        __field Z 13 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '11011010 11000001 00x001xx xxxxxxxx'
        __guard TRUE
        __decode
            boolean source_is_sp = FALSE;
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if !HavePACExt() then
                UNDEFINED;
            
            if Z == '0' then // PACIB
                if n == 31 then source_is_sp = TRUE;
            else // PACIZB
                if n != 31 then UNDEFINED;

    __encoding aarch64_integer_pac_pacib_hint
        __instruction_set A64
        __field CRm 8 +: 4
        __field op2 5 +: 3
        __opcode '11010101 00000011 0010xxxx xxx11111'
        __guard TRUE
        __decode
            integer d;
            integer n;
            boolean source_is_sp = FALSE;
            
            case CRm:op2 of
                when '0011 010' // PACIBZ
                    d = 30;
                    n = 31;
                when '0011 011' // PACIBSP
                    d = 30;
                    source_is_sp = TRUE;
                    if HaveBTIExt() then
                        // Check for branch target compatibility between PSTATE.BTYPE
                        // and implicit branch target of PACIBSP instruction.
                        BTypeCompatible = BTypeCompatible_PACIXSP();
                when '0001 010' // PACIB1716
                    d = 17;
                    n = 16;
                when '0001 000' SEE "PACIA";
                when '0001 100' SEE "AUTIA";
                when '0001 110' SEE "AUTIB";
                when '0011 00x' SEE "PACIA";
                when '0011 10x' SEE "AUTIA";
                when '0011 11x' SEE "AUTIB";
                when '0000 111' SEE "XPACLRI";

    __execute
        if HavePACExt() then
            if source_is_sp then
                X[d] = AddPACIB(X[d], SP[]);
            else
                X[d] = AddPACIB(X[d], X[n]);

__instruction LD3H_Z.P.BR_Contiguous
    __encoding LD3H_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100100 110xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;
            integer nreg = 3;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..2] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_long
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_long
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 xxxxxxxx 0x10x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean sub_op = (o2 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(idxdsize)   operand2 = V[m];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        
        element2 = Int(Elem[operand2, index, esize], unsigned);
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            product = (element1 * element2)<2*esize-1:0>;
            if sub_op then
                Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
            else
                Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;
        
        V[d] = result;

__instruction CLASTA_V.P.Z__
    __encoding CLASTA_V.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Vdn 0 +: 5
        __opcode '00000101 xx101010 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Vdn);
            integer m = UInt(Zm);
            boolean isBefore = FALSE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(esize) operand1 = V[dn];
        bits(VL) operand2 = Z[m];
        bits(esize) result;
        integer last = LastActiveElement(mask, esize);
        
        if last < 0 then
            result = ZeroExtend(operand1);
        else
            if !isBefore then
                last = last + 1;
                if last >= elements then last = 0;
            result = Elem[operand2, last, esize];
        
        V[dn] = result;

__instruction LD1SH_Z.P.BZ_S.x32.scaled
    __encoding LD1SH_Z.P.BZ_S.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 1x1xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 1;

    __encoding LD1SH_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 1x1xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 1;

    __encoding LD1SH_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 1x0xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1SH_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 1x0xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = FALSE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1SH_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 111xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 64;
            boolean unsigned = FALSE;
            boolean offs_unsigned = TRUE;
            integer scale = 1;

    __encoding LD1SH_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 110xxxxx 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 64;
            boolean unsigned = FALSE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset = Z[m];
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction aarch64_memory_ordered_rcpc
    __encoding aarch64_memory_ordered_rcpc
        __instruction_set A64
        __field size 30 +: 2
        __field Rs 16 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 101xxxxx 110000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = AccType_ORDERED;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        data = Mem[address, dbytes, acctype];
        X[t] = ZeroExtend(data, regsize);

__instruction aarch64_integer_arithmetic_rev
    __encoding aarch64_integer_arithmetic_rev
        __instruction_set A64
        __field sf 31 +: 1
        __field opc 10 +: 2
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x1011010 11000000 0000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer datasize = if sf == '1' then 64 else 32;
            
            integer container_size;
            case opc of
                when '00'
                    Unreachable();
                when '01'
                    container_size = 16;
                when '10'
                    container_size = 32;
                when '11'
                    if sf == '0' then UNDEFINED;
                    container_size = 64;

    __execute
        bits(datasize) operand = X[n];
        bits(datasize) result;
        
        integer containers = datasize DIV container_size;
        integer elements_per_container = container_size DIV 8;
        integer index = 0;
        integer rev_index;
        for c = 0 to containers-1
            rev_index = index + ((elements_per_container - 1) * 8);
            for e = 0 to elements_per_container-1
                result<rev_index + 7:rev_index> = operand<index + 7:index>;
                index = index + 8;
                rev_index = rev_index - 8;
        
        X[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_pair
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_pair
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 1010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        integer element1;
        integer element2;
        integer maxmin;
        
        for e = 0 to elements-1
            element1 = Int(Elem[concat, 2*e, esize], unsigned);
            element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
            maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
            Elem[result, e, esize] = maxmin<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_float_compare_uncond
    __encoding aarch64_float_compare_uncond
        __instruction_set A64
        __field type1 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field opc 3 +: 2
        __opcode '00011110 xx1xxxxx 001000xx xxxxx000'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer m = UInt(Rm);   // ignored when opc<0> == '1'
            
            integer datasize;
            case type1 of
                when '00' datasize = 32;
                when '01' datasize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        datasize = 16;
                    else
                        UNDEFINED;
            
            boolean signal_all_nans = (opc<1> == '1');
            boolean cmp_with_zero = (opc<0> == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2;
        
        operand2 = if cmp_with_zero then FPZero('0') else V[m];
        
        PSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_single
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_single
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 0110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        integer maxmin;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
            Elem[result, e, esize] = maxmin<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_uniform_add_wrapping_single_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_add_wrapping_single_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 100001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size != '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean sub_op = (U == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_add_wrapping_single_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 100001xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean sub_op = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if sub_op then
                Elem[result, e, esize] = element1 - element2;
            else
                Elem[result, e, esize] = element1 + element2;
        
        V[d] = result;

__instruction aarch64_integer_conditional_compare_register
    __encoding aarch64_integer_conditional_compare_register
        __instruction_set A64
        __field sf 31 +: 1
        __field op 30 +: 1
        __field Rm 16 +: 5
        __field cond 12 +: 4
        __field Rn 5 +: 5
        __field nzcv 0 +: 4
        __opcode 'xx111010 010xxxxx xxxx00xx xxx0xxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer datasize = if sf == '1' then 64 else 32;
            boolean sub_op = (op == '1');
            bits(4) condition = cond;
            bits(4) flags = nzcv;

    __execute
        bits(datasize) operand1 = X[n];
        bits(datasize) operand2 = X[m];
        bit carry_in = '0';
        
        if ConditionHolds(condition) then
            if sub_op then
                operand2 = NOT(operand2);
                carry_in = '1';
            (-, flags) = AddWithCarry(operand1, operand2, carry_in);
        PSTATE.<N,Z,C,V> = flags;

__instruction aarch64_vector_arithmetic_binary_uniform_cmp_fp16_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp16_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field E 23 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 x10xxxxx 0010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field E 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 1110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field E 23 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 x10xxxxx 0010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_cmp_fp_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field E 23 +: 1
        __field sz 22 +: 1
        __field Rm 16 +: 5
        __field ac 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 1110x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            CompareOp cmp;
            boolean abs;
            
            case E:U:ac of
                when '000' cmp = CompareOp_EQ; abs = FALSE;
                when '010' cmp = CompareOp_GE; abs = FALSE;
                when '011' cmp = CompareOp_GE; abs = TRUE;
                when '110' cmp = CompareOp_GT; abs = FALSE;
                when '111' cmp = CompareOp_GT; abs = TRUE;
                otherwise  UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(esize) element1;
        bits(esize) element2;
        boolean test_passed;
        
        for e = 0 to elements-1
            element1 = Elem[operand1, e, esize];
            element2 = Elem[operand2, e, esize];
            if abs then
                element1 = FPAbs(element1);
                element2 = FPAbs(element2);
            case cmp of
                when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
                when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
                when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
            Elem[result, e, esize] = if test_passed then Ones() else Zeros();
        
        V[d] = result;

__instruction FSUB_Z.P.ZS__
    __encoding FSUB_Z.P.ZS__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field i1 5 +: 1
        __field Zdn 0 +: 5
        __opcode '01100101 xx011001 100xxx00 00xxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPSub(element1, imm, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_float_convert_fix
    __encoding aarch64_float_convert_fix
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field scale 10 +: 6
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            
            case type1 of
                when '00' fltsize = 32;
                when '01' fltsize = 64;
                when '10' UNDEFINED;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            if sf == '0' && scale<5> == '0' then UNDEFINED;
            integer fracbits = 64 - UInt(scale);
            
            case opcode<2:1>:rmode of
                when '00 11'        // FCVTZ
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                otherwise
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
                V[d] = fltval;

__instruction LD1RQD_Z.P.BR_Contiguous
    __encoding LD1RQD_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 100xxxxx 000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;

    __execute
        CheckSVEEnabled();
        integer elements = 128 DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g]; // low 16 bits only
        bits(64) offset;
        bits(128) result;
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        offset = X[m];
        
        addr = base + UInt(offset) * mbytes;
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
            else
                Elem[result, e, esize] = Zeros();
            addr = addr + mbytes;
        
        Z[t] = Replicate(result, VL DIV 128);

__instruction aarch64_vector_arithmetic_binary_uniform_shift_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_shift_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');
            if S == '0' && size != '11' then UNDEFINED;

    __encoding aarch64_vector_arithmetic_binary_uniform_shift_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field R 12 +: 1
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 010xx1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size:Q == '110' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');
            boolean rounding = (R == '1');
            boolean saturating = (S == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        
        integer round_const = 0;
        integer shift;
        integer element;
        boolean sat;
        
        for e = 0 to elements-1
            shift = SInt(Elem[operand2, e, esize]<7:0>);
            if rounding then
                round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift 
            element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
            if saturating then
                (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                if sat then FPSR.QC = '1';
            else
                Elem[result, e, esize] = element<esize-1:0>;
        
        V[d] = result;

__instruction UMIN_Z.ZI__
    __encoding UMIN_Z.ZI__
        __instruction_set A64
        __field size 22 +: 2
        __field imm8 5 +: 8
        __field Zdn 0 +: 5
        __opcode '00100101 xx101011 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer dn = UInt(Zdn);
            boolean unsigned = TRUE;
            integer imm = Int(imm8, unsigned);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(VL) result;
        
        for e = 0 to elements-1
            integer element1 = Int(Elem[operand1, e, esize], unsigned);
            Elem[result, e, esize] = Min(element1, imm)<esize-1:0>;
        
        Z[dn] = result;

__instruction aarch64_vector_arithmetic_unary_add_pairwise
    __encoding aarch64_vector_arithmetic_unary_add_pairwise
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field op 14 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx100000 0x1010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV (2*esize);
            boolean acc = (op == '1');
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        
        bits(2*esize) sum;
        integer op1;
        integer op2;
        
        result = if acc then V[d] else Zeros();
        for e = 0 to elements-1
            op1 = Int(Elem[operand, 2*e+0, esize], unsigned);
            op2 = Int(Elem[operand, 2*e+1, esize], unsigned);
            sum = (op1 + op2)<2*esize-1:0>;
            Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;
        
        V[d] = result;

__instruction aarch64_vector_reduce_fp16_maxnm_simd
    __encoding aarch64_vector_reduce_fp16_maxnm_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field o1 23 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 x0110000 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

    __encoding aarch64_vector_reduce_fp_maxnm_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field o1 23 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx110000 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q != '01' then UNDEFINED; // .4S only
            
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        V[d] = Reduce(op, operand, esize);

__instruction aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01111110 xx0xxxxx 1000x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' || size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            boolean rounding = TRUE;
            boolean sub_op = (S == '1');

    __encoding aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field S 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x101110 xx0xxxxx 1000x1xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' || size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean rounding = TRUE;
            boolean sub_op = (S == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) operand3 = V[d];
        bits(datasize) result;
        integer rounding_const = if rounding then 1 << (esize - 1) else 0;
        integer element1;
        integer element2;
        integer element3;
        integer product;
        boolean sat;
        
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            element2 = SInt(Elem[operand2, e, esize]);
            element3 = SInt(Elem[operand3, e, esize]);
            if sub_op then
                accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
            else
                accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
            (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
            if sat then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_memory_ordered
    __encoding aarch64_memory_ordered
        __instruction_set A64
        __field size 30 +: 2
        __field L 22 +: 1
        __field Rs 16 +: 5
        __field o0 15 +: 1
        __field Rt2 10 +: 5
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx001000 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer n = UInt(Rn);
            integer t = UInt(Rt);
            integer t2 = UInt(Rt2); // ignored by load/store single register
            integer s = UInt(Rs);   // ignored by all loads and store-release
            
            AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
            MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
            integer elsize = 8 << UInt(size);
            integer regsize = if elsize == 64 then 64 else 32;
            integer datasize = elsize;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) data;
        constant integer dbytes = datasize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        case memop of
            when MemOp_STORE
                data = X[t];
                Mem[address, dbytes, acctype] = data;
        
            when MemOp_LOAD
                data = Mem[address, dbytes, acctype];
                X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 01111001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_int_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 0x100001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 01111001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_int_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 0x100001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        FPRounding rounding = FPRoundingMode(FPCR);
        bits(esize) element;
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
    __encoding aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
        __instruction_set A64
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 11111001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_unary_special_recip_float_sisd
        __instruction_set A64
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011110 1x100001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;

    __encoding aarch64_vector_arithmetic_unary_special_recip_fp16_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 11111001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __encoding aarch64_vector_arithmetic_unary_special_recip_float_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 1x100001 110110xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPRecipEstimate(element, FPCR);
        
        V[d] = result;

__instruction aarch64_vector_shift_right_sisd
    __encoding aarch64_vector_shift_right_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh<3> != '1' then UNDEFINED;
            integer esize = 8 << 3;
            integer datasize = esize;
            integer elements = 1;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __encoding aarch64_vector_shift_right_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field immh 19 +: 4
        __field immb 16 +: 3
        __field o1 13 +: 1
        __field o0 12 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01111 0xxxxxxx 00xx01xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if immh == '0000' then SEE(asimdimm);
            if immh<3>:Q == '10' then UNDEFINED;
            integer esize = 8 << HighestSetBit(immh);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            integer shift = (esize * 2) - UInt(immh:immb);
            boolean unsigned = (U == '1');
            boolean round = (o1 == '1');
            boolean accumulate = (o0 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand  = V[n];
        bits(datasize) operand2;
        bits(datasize) result;
        integer round_const = if round then (1 << (shift - 1)) else 0;
        integer element;
        
        operand2 = if accumulate then V[d] else Zeros();
        for e = 0 to elements-1
            element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
            Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
        
        V[d] = result;

__instruction aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
        __instruction_set A64
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01011111 xxxxxxxx 0x11x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = esize;
            integer elements = 1;
            integer part = 0;
            
            boolean sub_op = (o2 == '1');

    __encoding aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field size 22 +: 2
        __field L 21 +: 1
        __field M 20 +: 1
        __field Rm 16 +: 4
        __field o2 14 +: 1
        __field H 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001111 xxxxxxxx 0x11x0xx xxxxxxxx'
        __guard TRUE
        __decode
            integer idxdsize = if H == '1' then 128 else 64; 
            integer index;
            bit Rmhi;
            case size of
                when '01' index = UInt(H:L:M); Rmhi = '0';
                when '10' index = UInt(H:L);   Rmhi = M;
                otherwise UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rmhi:Rm);
            
            integer esize = 8 << UInt(size);
            integer datasize = 64;
            integer part = UInt(Q);
            integer elements = datasize DIV esize;
            
            boolean sub_op = (o2 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize)   operand1 = Vpart[n, part];
        bits(idxdsize)   operand2 = V[m];
        bits(2*datasize) operand3 = V[d];
        bits(2*datasize) result;
        integer element1;
        integer element2;
        bits(2*esize) product;
        integer accum;
        boolean sat1;
        boolean sat2;
        
        element2 = SInt(Elem[operand2, index, esize]);
        for e = 0 to elements-1
            element1 = SInt(Elem[operand1, e, esize]);
            (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
            if sub_op then
                accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
            else
                accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
            (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
            if sat1 || sat2 then FPSR.QC = '1';
        
        V[d] = result;

__instruction aarch64_system_barriers
    __encoding aarch64_system_barriers
        __instruction_set A64
        __field CRm 8 +: 4
        __field opc 5 +: 2
        __opcode '11010101 00000011 0011xxxx 1xx11111'
        __guard TRUE
        __decode
            MemBarrierOp op;
            MBReqDomain domain;
            MBReqTypes types;
            
            case opc of
                when '00' op = MemBarrierOp_DSB;
                when '01' op = MemBarrierOp_DMB;
                when '10' op = MemBarrierOp_ISB;
                otherwise 
                    if HaveSBExt() && CRm<3:0> == '0000' then 
                        op = MemBarrierOp_SB;
                    else
                        UNDEFINED;
            
            case CRm<3:2> of
                when '00' domain = MBReqDomain_OuterShareable;
                when '01' domain = MBReqDomain_Nonshareable;
                when '10' domain = MBReqDomain_InnerShareable;
                when '11' domain = MBReqDomain_FullSystem;
            
            case CRm<1:0> of
                when '01' types = MBReqTypes_Reads;
                when '10' types = MBReqTypes_Writes;
                when '11' types = MBReqTypes_All;
                otherwise
                    if CRm<3:2> == '01' then
                        op = MemBarrierOp_PSSBB;
                    elsif CRm<3:2> == '00' && opc == '00' then 
                        op = MemBarrierOp_SSBB;
                    elsif HaveSBExt() && CRm<3:2> == '00' && opc == '11' then 
                        op = MemBarrierOp_SB;
                    else
                        types  = MBReqTypes_All;
                        domain = MBReqDomain_FullSystem;

    __execute
        case op of
            when MemBarrierOp_DSB
                DataSynchronizationBarrier(domain, types);
            when MemBarrierOp_DMB
                DataMemoryBarrier(domain, types);
            when MemBarrierOp_ISB
                InstructionSynchronizationBarrier();
            when MemBarrierOp_SSBB
                SpeculativeStoreBypassBarrierToVA();
            when MemBarrierOp_PSSBB
                SpeculativeStoreBypassBarrierToPA();
            when MemBarrierOp_SB
                SpeculationBarrier();

__instruction FMUL_Z.P.ZZ__
    __encoding FMUL_Z.P.ZZ__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Zm 5 +: 5
        __field Zdn 0 +: 5
        __opcode '01100101 xx000010 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer m = UInt(Zm);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand1 = Z[dn];
        bits(VL) operand2 = Z[m];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            bits(esize) element2 = Elem[operand2, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = FPMul(element1, element2, FPCR);
            else
                Elem[result, e, esize] = element1;
        
        Z[dn] = result;

__instruction aarch64_float_convert_int
    __encoding aarch64_float_convert_int
        __instruction_set A64
        __field sf 31 +: 1
        __field type1 22 +: 2
        __field rmode 19 +: 2
        __field opcode 16 +: 3
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode 'x0011110 xx1xxxxx 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer intsize = if sf == '1' then 64 else 32;
            integer fltsize;
            FPConvOp op;
            FPRounding rounding;
            boolean unsigned;
            integer part;
            
            case type1 of
                when '00'
                    fltsize = 32;
                when '01'
                    fltsize = 64;
                when '10'
                    if opcode<2:1>:rmode != '11 01' then UNDEFINED;
                    fltsize = 128;
                when '11'
                    if HaveFP16Ext() then
                        fltsize = 16;
                    else
                        UNDEFINED;
            
            case opcode<2:1>:rmode of
                when '00 xx'        // FCVT[NPMZ][US]
                    rounding = FPDecodeRounding(rmode);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '01 00'        // [US]CVTF
                    rounding = FPRoundingMode(FPCR);
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_ItoF;
                when '10 00'        // FCVTA[US]
                    rounding = FPRounding_TIEAWAY;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI;
                when '11 00'        // FMOV
                    if fltsize != 16 && fltsize != intsize then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 0;
                when '11 01'        // FMOV D[1]
                    if intsize != 64 || fltsize != 128 then UNDEFINED;
                    op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                    part = 1;
                    fltsize = 64;  // size of D[1] is 64
                when '11 11'       // FJCVTZS
                    if !HaveFJCVTZSExt() then UNDEFINED;
                    rounding = FPRounding_ZERO;
                    unsigned = (opcode<0> == '1');
                    op = FPConvOp_CVT_FtoI_JS;
                otherwise 
                    UNDEFINED;

    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(fltsize) fltval;
        bits(intsize) intval;
        
        case op of
            when FPConvOp_CVT_FtoI
                fltval = V[n];
                intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                X[d] = intval;
            when FPConvOp_CVT_ItoF
                intval = X[n];
                fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                V[d] = fltval;
            when FPConvOp_MOV_FtoI
                fltval = Vpart[n,part];
                intval = ZeroExtend(fltval, intsize);
                X[d] = intval;
            when FPConvOp_MOV_ItoF
                intval = X[n];
                fltval = intval<fltsize-1:0>;
                Vpart[d,part] = fltval;
            when FPConvOp_CVT_FtoI_JS
                fltval = V[n];
                intval = FPToFixedJS(fltval, FPCR, TRUE);
                X[d] = ZeroExtend(intval<31:0>, 64);

__instruction aarch64_vector_arithmetic_binary_uniform_add_halving_rounding
    __encoding aarch64_vector_arithmetic_binary_uniform_add_halving_rounding
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 000101xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        integer element1;
        integer element2;
        
        for e = 0 to elements-1
            element1 = Int(Elem[operand1, e, esize], unsigned);
            element2 = Int(Elem[operand2, e, esize], unsigned);
            Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;
        
        V[d] = result;

__instruction LD2D_Z.P.BR_Contiguous
    __encoding LD2D_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10100101 101xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        bits(64) offset = X[m];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
                else
                    Elem[values[r], e, esize] = Zeros();
                addr = addr + mbytes;
            offset = offset + nreg;
        
        for r = 0 to nreg-1
            Z[(t+r) MOD 32] = values[r];

__instruction ST2W_Z.P.BI_Contiguous
    __encoding ST2W_Z.P.BI_Contiguous
        __instruction_set A64
        __field imm4 16 +: 4
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100101 0011xxxx 111xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer g = UInt(Pg);
            integer esize = 32;
            integer offset = SInt(imm4);
            integer nreg = 2;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        array [0..1] of bits(VL) values;
        
        if n == 31 then
            CheckSPAlignment();
            if HaveMTEExt() then SetNotTagCheckedInstruction(TRUE);
            base = SP[];
        else
            if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
            base = X[n];
        
        for r = 0 to nreg-1
            values[r] = Z[(t+r) MOD 32];
        
        addr = base + offset * elements * nreg * mbytes;
        for e = 0 to elements-1
            for r = 0 to nreg-1
                if ElemP[mask, e, esize] == '1' then
                    Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
                addr = addr + mbytes;

__instruction aarch64_memory_vector_multiple_no_wb
    __encoding aarch64_memory_vector_multiple_no_wb
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 0x000000 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = integer UNKNOWN;
            boolean wback = FALSE;
            boolean tag_checked = wback || n != 31;

    __encoding aarch64_memory_vector_multiple_post_inc
        __instruction_set A64
        __field Q 30 +: 1
        __field L 22 +: 1
        __field Rm 16 +: 5
        __field opcode 12 +: 4
        __field size 10 +: 2
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode '0x001100 1x0xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            boolean wback = TRUE;
            boolean tag_checked = wback || n != 31;

    __postdecode
        MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
        integer datasize = if Q == '1' then 128 else 64;
        integer esize = 8 << UInt(size);
        integer elements = datasize DIV esize;
        
        integer rpt;    // number of iterations
        integer selem;  // structure elements 
        
        case opcode of
            when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
            when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
            when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
            when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
            when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
            when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
            when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
            otherwise UNDEFINED;
        
        // .1D format only permitted with LD1 & ST1
        if size:Q == '110' && selem != 1 then UNDEFINED;
    __execute
        CheckFPAdvSIMDEnabled64();
        
        bits(64) address;
        bits(64) offs;
        bits(datasize) rval;
        integer tt;
        constant integer ebytes = esize DIV 8;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        offs = Zeros();
        for r = 0 to rpt-1
            for e = 0 to elements-1
                tt = (t + r) MOD 32;
                for s = 0 to selem-1
                    rval = V[tt];
                    if memop == MemOp_LOAD then
                        Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                        V[tt] = rval;
                    else // memop == MemOp_STORE
                        Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                    offs = offs + ebytes;
                    tt = (tt + 1) MOD 32;
        
        if wback then
            if m != 31 then
                offs = X[m];
            if n == 31 then
                SP[] = address + offs;
            else
                X[n] = address + offs;

__instruction aarch64_vector_transfer_integer_dup
    __encoding aarch64_vector_transfer_integer_dup
        __instruction_set A64
        __field Q 30 +: 1
        __field imm5 16 +: 5
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0x001110 000xxxxx 000011xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer size = LowestSetBit(imm5);
            if size > 3 then UNDEFINED;
            
            // imm5<4:size+1> is IGNORED
            
            if size == 3 && Q == '0' then UNDEFINED;
            integer esize = 8 << size;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(esize) element = X[n];
        bits(datasize) result;
        
        for e = 0 to elements-1
            Elem[result, e, esize] = element;
        V[d] = result;

__instruction aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 01111001 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPRounding_TIEAWAY;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
        __instruction_set A64
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '01x11110 0x100001 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 32 << UInt(sz);
            integer datasize = esize;
            integer elements = 1;
            
            FPRounding rounding = FPRounding_TIEAWAY;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 01111001 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            integer esize = 16;
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPRounding_TIEAWAY;
            boolean unsigned = (U == '1');

    __encoding aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field sz 22 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 0x100001 110010xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            
            if sz:Q == '10' then UNDEFINED;
            integer esize = 32 << UInt(sz);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            FPRounding rounding = FPRounding_TIEAWAY;
            boolean unsigned = (U == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand = V[n];
        bits(datasize) result;
        bits(esize) element;
        
        for e = 0 to elements-1
            element = Elem[operand, e, esize];
            Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
        
        V[d] = result;

__instruction aarch64_memory_atomicops_ld
    __encoding aarch64_memory_atomicops_ld
        __instruction_set A64
        __field size 30 +: 2
        __field A 23 +: 1
        __field R 22 +: 1
        __field Rs 16 +: 5
        __field opc 12 +: 3
        __field Rn 5 +: 5
        __field Rt 0 +: 5
        __opcode 'xx111000 xx1xxxxx 0xxx00xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveAtomicExt() then UNDEFINED;
            integer t = UInt(Rt);
            integer n = UInt(Rn);
            integer s = UInt(Rs);
            
            integer datasize = 8 << UInt(size);
            integer regsize = if datasize == 64 then 64 else 32;
            AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
            MemAtomicOp op;
            case opc of
                when '000' op = MemAtomicOp_ADD;
                when '001' op = MemAtomicOp_BIC;
                when '010' op = MemAtomicOp_EOR;
                when '011' op = MemAtomicOp_ORR;
                when '100' op = MemAtomicOp_SMAX;
                when '101' op = MemAtomicOp_SMIN;
                when '110' op = MemAtomicOp_UMAX;
                when '111' op = MemAtomicOp_UMIN;
            boolean tag_checked = n != 31;

    __execute
        bits(64) address;
        bits(datasize) value;
        bits(datasize) data;
        bits(datasize) result;
        
        if HaveMTEExt() then
            SetNotTagCheckedInstruction(!tag_checked);
        
        value = X[s];
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        // All observers in the shareability domain observe the
        // following load and store atomically.
        data =  Mem[address, datasize DIV 8, ldacctype];
        
        case op of
            when MemAtomicOp_ADD   result = data + value;
            when MemAtomicOp_BIC   result = data AND NOT(value);
            when MemAtomicOp_EOR   result = data EOR value;
            when MemAtomicOp_ORR   result = data OR value;
            when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;
            when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;
            when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;
            when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;
        
        Mem[address, datasize DIV 8, stacctype] = result;
        
        if t != 31 then
            X[t] = ZeroExtend(data, regsize);

__instruction aarch64_vector_arithmetic_binary_uniform_max_min_pair
    __encoding aarch64_vector_arithmetic_binary_uniform_max_min_pair
        __instruction_set A64
        __field Q 30 +: 1
        __field U 29 +: 1
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field o1 11 +: 1
        __field Rn 5 +: 5
        __field Rd 0 +: 5
        __opcode '0xx01110 xx1xxxxx 1010x1xx xxxxxxxx'
        __guard TRUE
        __decode
            integer d = UInt(Rd);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            if size == '11' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer datasize = if Q == '1' then 128 else 64;
            integer elements = datasize DIV esize;
            
            boolean unsigned = (U == '1');
            boolean minimum = (o1 == '1');

    __execute
        CheckFPAdvSIMDEnabled64();
        bits(datasize) operand1 = V[n];
        bits(datasize) operand2 = V[m];
        bits(datasize) result;
        bits(2*datasize) concat = operand2:operand1;
        integer element1;
        integer element2;
        integer maxmin;
        
        for e = 0 to elements-1
            element1 = Int(Elem[concat, 2*e, esize], unsigned);
            element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
            maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
            Elem[result, e, esize] = maxmin<esize-1:0>;
        
        V[d] = result;

__instruction LD1H_Z.P.BZ_S.x32.scaled
    __encoding LD1H_Z.P.BZ_S.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 1x1xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 1;

    __encoding LD1H_Z.P.BZ_D.x32.scaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 1x1xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 1;

    __encoding LD1H_Z.P.BZ_D.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 1x0xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1H_Z.P.BZ_S.x32.unscaled
        __instruction_set A64
        __field xs 22 +: 1
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '10000100 1x0xxxxx 010xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 32;
            integer msize = 16;
            integer offs_size = 32;
            boolean unsigned = TRUE;
            boolean offs_unsigned = xs == '0';
            integer scale = 0;

    __encoding LD1H_Z.P.BZ_D.64.scaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 111xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 1;

    __encoding LD1H_Z.P.BZ_D.64.unscaled
        __instruction_set A64
        __field Zm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11000100 110xxxxx 110xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Zm);
            integer g = UInt(Pg);
            integer esize = 64;
            integer msize = 16;
            integer offs_size = 64;
            boolean unsigned = TRUE;
            boolean offs_unsigned = TRUE;
            integer scale = 0;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(VL) offset = Z[m];
        bits(PL) mask = P[g];
        bits(VL) result;
        bits(msize) data;
        constant integer mbytes = msize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
                addr = base + (off << scale);
                data = Mem[addr, mbytes, AccType_NORMAL];
                Elem[result, e, esize] = Extend(data, esize, unsigned);
            else
                Elem[result, e, esize] = Zeros();
        
        Z[t] = result;

__instruction UQDECP_Z.P.Z__
    __encoding UQDECP_Z.P.Z__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 5 +: 4
        __field Zdn 0 +: 5
        __opcode '00100101 xx101011 1000000x xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if size == '00' then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            boolean unsigned = TRUE;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(VL) operand = Z[dn];
        bits(VL) result;
        integer count = 0;
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                count = count + 1;
        
        for e = 0 to elements-1
            integer element = Int(Elem[operand, e, esize], unsigned);
            (Elem[result, e, esize], -) = SatQ(element - count, esize, unsigned);
        
        Z[dn] = result;

__instruction CPY_Z.P.V__
    __encoding CPY_Z.P.V__
        __instruction_set A64
        __field size 22 +: 2
        __field Pg 10 +: 3
        __field Vn 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000101 xx100000 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer g = UInt(Pg);
            integer n = UInt(Vn);
            integer d = UInt(Zd);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(PL) mask = P[g];
        bits(esize) operand1 = V[n];
        bits(VL) result = Z[d];
        
        for e = 0 to elements-1
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = operand1;
        
        Z[d] = result;

__instruction STNT1H_Z.P.BR_Contiguous
    __encoding STNT1H_Z.P.BR_Contiguous
        __instruction_set A64
        __field Rm 16 +: 5
        __field Pg 10 +: 3
        __field Rn 5 +: 5
        __field Zt 0 +: 5
        __opcode '11100100 100xxxxx 011xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            if Rm == '11111' then UNDEFINED;
            integer t = UInt(Zt);
            integer n = UInt(Rn);
            integer m = UInt(Rm);
            integer g = UInt(Pg);
            integer esize = 16;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(64) base;
        bits(64) addr;
        bits(64) offset = X[m];
        bits(VL) src;
        bits(PL) mask = P[g];
        constant integer mbytes = esize DIV 8;
        
        if HaveMTEExt() then SetNotTagCheckedInstruction(FALSE);
        
        if n == 31 then
            CheckSPAlignment();
            base = SP[];
        else
            base = X[n];
        
        src = Z[t];
        for e = 0 to elements-1
            addr = base + UInt(offset) * mbytes;
            if ElemP[mask, e, esize] == '1' then
                Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
            offset = offset + 1;

__instruction aarch64_integer_tags_mcgettagarray
    __encoding aarch64_integer_tags_mcgettagarray
        __instruction_set A64
        __field Xn 5 +: 5
        __field Xt 0 +: 5
        __opcode '11011001 11100000 000000xx xxxxxxxx'
        __guard TRUE
        __decode
            integer t = UInt(Xt);
            integer n = UInt(Xn);
            boolean wback = TRUE;
            boolean wb_unknown = FALSE;

    __execute
        bits(64) data = Zeros(64);
        bits(64) address;
        integer count;
        
        if n == t then
            c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
            assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
        
            case c of
                when Constraint_WBSUPPRESS  wback = FALSE; // writeback is suppressed
                when Constraint_UNKNOWN     wb_unknown = TRUE; // writeback is UNKNOWN
                when Constraint_UNDEF       UnallocatedEncoding();
                when Constraint_NOP         EndOfInstruction();
        
        if n == 31 then
            CheckSPAlignment();
            address = SP[];
        else
            address = X[n];
        
        (address, count) = ImpDefTagArrayStartAndCount(address);
        
        for i = 0 to count-1
            integer index = UInt(address<LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE>);
            bits(4) tag = MemTag[address];
            data<(index*4)+3:(index*4)> = tag;
            address = address + TAG_GRANULE;
        
        X[t] = data;
        
        if wback then
            if wb_unknown then
                address = bits(64) UNKNOWN;
            if n == 31 then
                SP[] = address;
            else
                X[n] = address;

__instruction aarch64_system_exceptions_debug_exception
    __encoding aarch64_system_exceptions_debug_exception
        __instruction_set A64
        __field imm16 5 +: 16
        __field LL 0 +: 2
        __opcode '11010100 101xxxxx xxxxxxxx xxx000xx'
        __guard TRUE
        __decode
            bits(2) target_level = LL;
            if LL == '00' then UNDEFINED;
            if !Halted() then AArch64.UndefinedFault();

    __execute
        DCPSInstruction(target_level);

__instruction LSL_Z.P.ZI__
    __encoding LSL_Z.P.ZI__
        __instruction_set A64
        __field tszh 22 +: 2
        __field Pg 10 +: 3
        __field tszl 8 +: 2
        __field imm3 5 +: 3
        __field Zdn 0 +: 5
        __opcode '00000100 xx000011 100xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            bits(4) tsize = tszh:tszl;
            case tsize of
                when '0000' UNDEFINED;
                when '0001' esize = 8;
                when '001x' esize = 16;
                when '01xx' esize = 32;
                when '1xxx' esize = 64;
            integer g = UInt(Pg);
            integer dn = UInt(Zdn);
            integer shift = UInt(tsize:imm3) - esize;

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(VL) operand1 = Z[dn];
        bits(PL) mask = P[g];
        bits(VL) result;
        
        for e = 0 to elements-1
            bits(esize) element1 = Elem[operand1, e, esize];
            if ElemP[mask, e, esize] == '1' then
                Elem[result, e, esize] = LSL(element1, shift);
            else
                Elem[result, e, esize] = Elem[operand1, e, esize];
        
        Z[dn] = result;

__instruction INDEX_Z.IR__
    __encoding INDEX_Z.IR__
        __instruction_set A64
        __field size 22 +: 2
        __field Rm 16 +: 5
        __field imm5 5 +: 5
        __field Zd 0 +: 5
        __opcode '00000100 xx1xxxxx 010010xx xxxxxxxx'
        __guard TRUE
        __decode
            if !HaveSVE() then UNDEFINED;
            integer esize = 8 << UInt(size);
            integer m = UInt(Rm);
            integer d = UInt(Zd);
            integer imm = SInt(imm5);

    __execute
        CheckSVEEnabled();
        integer elements = VL DIV esize;
        bits(esize) operand2 = X[m];
        integer element2 = SInt(operand2);
        bits(VL) result;
        
        for e = 0 to elements-1
            integer index = imm + e * element2;
            Elem[result, e, esize] = index<esize-1:0>;
        
        Z[d] = result;

////////////////////////////////////////////////////////////////////////
// End
////////////////////////////////////////////////////////////////////////

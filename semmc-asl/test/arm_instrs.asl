////////////////////////////////////////////////////////////////////////
// Proprietary Notice
//
//     This document is protected by copyright and other related rights
// and the practice or implementation of the information contained in
// this document may be protected by one or more patents or pending
// patent applications. No part of this document may be reproduced in any
// form by any means without the express prior written permission of ARM
// Limited ("ARM"). No license, express or implied, by estoppel or
// otherwise to any intellectual property rights is granted by this
// document unless specifically stated.
//
//     Your access to the information in this document is conditional
// upon your acceptance that you will not use or permit others to use the
// information for the purposes of determining whether implementations
// infringe any patents.
//
//     THIS DOCUMENT IS PROVIDED "AS IS". ARM PROVIDES NO REPRESENTATIONS
// AND NO WARRANTIES, EXPRESS, IMPLIED OR STATUTORY, INCLUDING, WITHOUT
// LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY
// QUALITY, NON-INFRINGEMENT OR FITNESS FOR A PARTICULAR PURPOSE WITH
// RESPECT TO THE DOCUMENT. For the avoidance of doubt, ARM makes no
// representation with respect to, and has undertaken no analysis to
// identify or understand the scope and content of, third party patents,
// copyrights, trade secrets, or other rights.
//
//     This document may include technical inaccuracies or typographical
// errors.
//
//     TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ARM BE
// LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT,
// INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES,
// HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT
// OF ANY USE OF THIS DOCUMENT, EVEN IF ARM HAS BEEN ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGES.
//
// This document consists solely of commercial items. You shall be
// responsible for ensuring that any use, duplication or disclosure of
// this document complies fully with any relevant export laws and
// regulations to assure that this document or any portion thereof is not
// exported, directly or indirectly, in violation of such export
// laws. Use of the word "partner" in reference to ARM's customers is not
// intended to create or refer to any partnership relationship with any
// other company. ARM may make changes to this document at any time and
// without notice.
//
// If any of the provisions contained in these terms conflict with any of
// the provisions of any signed written agreement specifically covering
// this document with ARM, then the signed written agreement prevails
// over and supersedes the conflicting provisions of these terms.
//
// Words and logos marked with (R) or (TM) are registered
// trademarks or trademarks of ARM Limited or its affiliates in the EU
// and/or elsewhere. All rights reserved. Other brands and names
// mentioned in this document may be the trademarks of their respective
// owners. You must follow the ARM trademark usage guidelines
// http://www.arm.com/about/trademarks/guidelines/index.php.
//
//     Copyright (C) 2017 ARM Limited or its affiliates. All rights
// reserved.
//
//     ARM Limited. Company 02557590 registered in England.
//
//     110 Fulbourn Road, Cambridge, England CB1 9NJ.
//
//     LES-PRE-20327
//
//     In this document, where the term ARM is used to refer to the
// company it means "ARM or any of its subsidiaries as appropriate".
////////////////////////////////////////////////////////////////////////

__instruction aarch32_REV_A
    __encoding aarch32_REV_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1011xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  m = UInt(Rm);
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_REV_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rd 0 +: 3
        __opcode '10111010 00xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);

    __encoding aarch32_REV_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 1000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
            if m != n || d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            bits(32) result;
            result<31:24> = R[m]<7:0>;
            result<23:16> = R[m]<15:8>;
            result<15:8>  = R[m]<23:16>;
            result<7:0>   = R[m]<31:24>;
            R[d] = result;

__instruction aarch32_STRH_r_A
    __encoding aarch32_STRH_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x0xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if P == '0' && W == '1' then SEE STRHT;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = (SRType_LSL, 0);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STRH_r_T1_A
        __instruction_set T16
        __field Rm 6 +: 3
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '0101001x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_STRH_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0010xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if t == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if index then offset_addr else R[n];
            MemU[address,2] = R[t]<15:0>;
            if wback then R[n] = offset_addr;

__instruction aarch32_VADDL_A
    __encoding aarch32_VADDL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0000 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VADDL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0000 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                if is_vaddw then
                    op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
                else
                    op1 = Int(Elem[Din[n],e,esize], unsigned);
                result = op1 + Int(Elem[Din[m],e,esize],unsigned);
                Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_QSUB16_A
    __encoding aarch32_QSUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QSUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);
            diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);
            R[d]<15:0>  = SignedSat(diff1, 16);
            R[d]<31:16> = SignedSat(diff2, 16);

__instruction aarch32_STLEXH_A
    __encoding aarch32_STLEXH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1110xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STLEXH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1101xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            if AArch32.ExclusiveMonitorsPass(address,2) then
                MemO[address, 2] = R[t]<15:0>;
                R[d] = ZeroExtend('0');
            else
                R[d] = ZeroExtend('1');

__instruction aarch32_SHA256H2_A
    __encoding aarch32_SHA256H2_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x01xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA256H2_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x01xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            X = Q[n>>1]; Y = Q[d>>1]; W = Q[m>>1]; part1 = FALSE;
            Q[d>>1] = SHA256hash(X, Y, W, part1);

__instruction aarch32_SEL_A
    __encoding aarch32_SEL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1000xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SEL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 1000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            R[d]<7:0>   = if PSTATE.GE<0> == '1' then R[n]<7:0>   else R[m]<7:0>;
            R[d]<15:8>  = if PSTATE.GE<1> == '1' then R[n]<15:8>  else R[m]<15:8>;
            R[d]<23:16> = if PSTATE.GE<2> == '1' then R[n]<23:16> else R[m]<23:16>;
            R[d]<31:24> = if PSTATE.GE<3> == '1' then R[n]<31:24> else R[m]<31:24>;

__instruction aarch32_SMLAWB_A
    __encoding aarch32_SMLAWB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field M 6 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 1x00xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

    __encoding aarch32_SMLAWB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0011xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE SMULWB, SMULWT;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
            result = SInt(R[n]) * SInt(operand2) + (SInt(R[a]) << 16);
            R[d] = result<47:16>;
            if (result >> 16) != SInt(R[d]) then  // Signed overflow
                PSTATE.Q = '1';

__instruction aarch32_ERET_AS
    __encoding aarch32_ERET_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0001 0110xxxx xxxxxxxx 0110xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_ERET_T1_A
        __instruction_set T32
        __opcode '11110011 11011110 10x0xxxx 00000000'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if PSTATE.M IN {M32_User,M32_System} then
                UNPREDICTABLE;                        // UNDEFINED or NOP
            else
                new_pc_value = if PSTATE.EL == EL2 then ELR_hyp else R[14];
                AArch32.ExceptionReturn(new_pc_value, SPSR[]);

__instruction aarch32_VPADD_f_A
    __encoding aarch32_VPADD_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPADD_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            bits(64) dest;
            h = elements DIV 2;
        
            for e = 0 to h-1
                Elem[dest,e,esize]   = FPAdd(Elem[D[n],2*e,esize], Elem[D[n],2*e+1,esize], StandardFPSCRValue());
                Elem[dest,e+h,esize] = FPAdd(Elem[D[m],2*e,esize], Elem[D[m],2*e+1,esize], StandardFPSCRValue());
        
            D[d] = dest;

__instruction aarch32_UXTB_A
    __encoding aarch32_UXTB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 11101111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTB_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rd 0 +: 3
        __opcode '10110010 11xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

    __encoding aarch32_UXTB_T2_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 01011111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d] = ZeroExtend(rotated<7:0>, 32);

__instruction aarch32_VSTM_A
    __encoding aarch32_VSTM_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx0xxxx xxxx1011 xxxxxxx1'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VSTR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VSTM_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx0xxxx xxxx1011 xxxxxxx1'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VSTR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            address = if add then R[n] else R[n]-imm32;
            for r = 0 to regs-1
                if single_regs then
                    MemA[address,4] = S[d+r];  address = address+4;
                else
                    // Store as two word-aligned words in the correct order for current endianness.
                    MemA[address,4] = if BigEndian() then D[d+r]<63:32> else D[d+r]<31:0>;
                    MemA[address+4,4] = if BigEndian() then D[d+r]<31:0> else D[d+r]<63:32>;
                    address = address+8;
            if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;

__instruction aarch32_VCMP_A
    __encoding aarch32_VCMP_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110100 xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VCMP_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __opcode 'xxxx1110 1x110101 xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D);
                when '10' esize = 32; d = UInt(Vd:D);
                when '11' esize = 64; d = UInt(D:Vd);

    __encoding aarch32_VCMP_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110100 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VCMP_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __opcode '11101110 1x110101 xxxx10xx 01x0xxxx'
        __guard TRUE
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D);
                when '10' esize = 32; d = UInt(Vd:D);
                when '11' esize = 64; d = UInt(D:Vd);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            case esize of
                when 16
                    bits(16) op16 = if with_zero then FPZero('0') else S[m]<15:0>;
                    FPSCR.<N,Z,C,V> = FPCompare(S[d]<15:0>, op16, quiet_nan_exc, FPSCR);
                when 32
                    bits(32) op32 = if with_zero then FPZero('0') else S[m];
                    FPSCR.<N,Z,C,V> = FPCompare(S[d], op32, quiet_nan_exc, FPSCR);
                when 64
                    bits(64) op64 = if with_zero then FPZero('0') else D[m];
                    FPSCR.<N,Z,C,V> = FPCompare(D[d], op64, quiet_nan_exc, FPSCR);

__instruction aarch32_LDRD_i_A
    __encoding aarch32_LDRD_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x0xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE LDRD (literal);
            if Rt<0> == '1' then UNPREDICTABLE;
            t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if P == '0' && W == '1' then UNPREDICTABLE;
            if wback && (n == t || n == t2) then UNPREDICTABLE;
            if t2 == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRD_i_T1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __field imm8 0 +: 8
        __opcode '1110100x x1x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && W == '0' then SEE "Related encodings";
            if Rn == '1111' then SEE LDRD (literal);
            t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if wback && (n == t || n == t2) then UNPREDICTABLE;
            if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            if address == Align(address, 8) then
                data = MemA[address,8];
                if BigEndian()  then
                    R[t] = data<63:32>;
                    R[t2] = data<31:0>;
                else
                    R[t] = data<31:0>;
                    R[t2] = data<63:32>;
            else
                R[t] = MemA[address,4];
                R[t2] = MemA[address+4,4];
            if wback then R[n] = offset_addr;

__instruction aarch32_SEVL_A
    __encoding aarch32_SEVL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000101'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_SEVL_T1_A
        __instruction_set T16
        __opcode '10111111 01010000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_SEVL_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000101'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            SendEventLocal();

__instruction aarch32_VRINTX_asimd_A
    __encoding aarch32_VRINTX_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0100 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPRounding_TIEEVEN;  exact = TRUE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTX_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0100 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPRounding_TIEEVEN;  exact = TRUE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_VLDR_A
    __encoding aarch32_VLDR_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode 'xxxx1101 xx011111 xxxx10xx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);

    __encoding aarch32_VLDR_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode '11101101 xx011111 xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            base = if n == 15 then Align(PC,4) else R[n];
            address = if add then (base + imm32) else (base - imm32);
            case esize of
                when 16
                    S[d] = Zeros(16) : MemA[address,2];
                when 32
                    S[d] = MemA[address,4];
                when 64
                    word1 = MemA[address,4];  word2 = MemA[address+4,4];
                    // Combine the word-aligned words in the correct order for current endianness.
                    D[d] = if BigEndian() then word1:word2 else word2:word1;

__instruction aarch32_VORN_r_A
    __encoding aarch32_VORN_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x11xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VORN_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x11xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                D[d+r] = D[n+r] OR NOT(D[m+r]);

__instruction aarch32_VQDMLAL_A
    __encoding aarch32_VQDMLAL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1001 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMLAL_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx0011 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQDMLAL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1001 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMLAL_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx0011 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
            for e = 0 to elements-1
                if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
                op1 = SInt(Elem[Din[n],e,esize]);
                // The following only saturates if both op1 and op2 equal -(2^(esize-1))
                (product, sat1) = SignedSatQ(2*op1*op2, 2*esize);
                if add then
                    result = SInt(Elem[Qin[d>>1],e,2*esize]) + SInt(product);
                else
                    result = SInt(Elem[Qin[d>>1],e,2*esize]) - SInt(product);
                (Elem[Q[d>>1],e,2*esize], sat2) = SignedSatQ(result, 2*esize);
                if sat1 || sat2 then FPSCR.QC = '1';

__instruction aarch32_SSUB8_A
    __encoding aarch32_SSUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SSUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);
            diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);
            diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);
            diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);
            R[d]<7:0>   = diff1<7:0>;
            R[d]<15:8>  = diff2<7:0>;
            R[d]<23:16> = diff3<7:0>;
            R[d]<31:24> = diff4<7:0>;
            PSTATE.GE<0>  = if diff1 >= 0 then '1' else '0';
            PSTATE.GE<1>  = if diff2 >= 0 then '1' else '0';
            PSTATE.GE<2>  = if diff3 >= 0 then '1' else '0';
            PSTATE.GE<3>  = if diff4 >= 0 then '1' else '0';

__instruction aarch32_SASX_A
    __encoding aarch32_SASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);
            sum  = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);
            R[d]<15:0>  = diff<15:0>;
            R[d]<31:16> = sum<15:0>;
            PSTATE.GE<1:0> = if diff >= 0 then '11' else '00';
            PSTATE.GE<3:2> = if sum  >= 0 then '11' else '00';

__instruction aarch32_STRHT_A
    __encoding aarch32_STRHT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx0000 x110xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_STRHT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0000 x010xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_STRHT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0010xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            EncodingSpecificOperations();
            offset = if register_form then R[m] else imm32;
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if postindex then R[n] else offset_addr;
            MemU_unpriv[address,2] = R[t]<15:0>;
            if postindex then R[n] = offset_addr;

__instruction aarch32_VRINTA_vfp_A
    __encoding aarch32_VRINTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111010 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111010 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_MLS_A
    __encoding aarch32_MLS_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 0110xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

    __encoding aarch32_MLS_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 0000xxxx xxxxxxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results
            operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results
            addend   = SInt(R[a]);  // addend   = UInt(R[a]) produces the same final results
            result = addend - operand1 * operand2;
            R[d] = result<31:0>;

__instruction aarch32_CPS_AS
    __encoding aarch32_CPS_A1_AS
        __instruction_set A32
        __field imod 18 +: 2
        __field M 17 +: 1
        __field A 8 +: 1
        __field I 7 +: 1
        __field F 6 +: 1
        __field mode 0 +: 5
        __opcode '11110001 0000xxx0 xxxxxxxx xx0xxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __decode
            if mode != '00000' && M == '0' then UNPREDICTABLE;
            if (imod<1> == '1' && A:I:F == '000') || (imod<1> == '0' && A:I:F != '000') then UNPREDICTABLE;
            enable = (imod == '10');  disable = (imod == '11');  changemode = (M == '1');
            affectA = (A == '1');  affectI = (I == '1');  affectF = (F == '1');
            if (imod == '00' && M == '0') || imod == '01' then UNPREDICTABLE;

    __encoding aarch32_CPS_T1_AS
        __instruction_set T16
        __field im 4 +: 1
        __field A 2 +: 1
        __field I 1 +: 1
        __field F 0 +: 1
        __opcode '10110110 011xxxxx'
        __guard TRUE
        __unpredictable_unless 3 == '0'
        __decode
            if A:I:F == '000' then UNPREDICTABLE;
            enable = (im == '0');  disable = (im == '1');  changemode = FALSE;
            affectA = (A == '1');  affectI = (I == '1');  affectF = (F == '1');
            if InITBlock() then UNPREDICTABLE;

    __encoding aarch32_CPS_T2_AS
        __instruction_set T32
        __field imod 9 +: 2
        __field M 8 +: 1
        __field A 7 +: 1
        __field I 6 +: 1
        __field F 5 +: 1
        __field mode 0 +: 5
        __opcode '11110011 1010xxxx 10x0xxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            if imod == '00' && M == '0' then SEE "Hint instructions";
            if mode != '00000' && M == '0' then UNPREDICTABLE;
            if (imod<1> == '1' && A:I:F == '000') || (imod<1> == '0' && A:I:F != '000') then UNPREDICTABLE;
            enable = (imod == '10');  disable = (imod == '11');  changemode = (M == '1');
            affectA = (A == '1');  affectI = (I == '1');  affectF = (F == '1');
            if imod == '01' || InITBlock() then UNPREDICTABLE;

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            EncodingSpecificOperations();
            if PSTATE.EL != EL0 then
                if enable then
                    if affectA then PSTATE.A = '0';
                    if affectI then PSTATE.I = '0';
                    if affectF then PSTATE.F = '0';
                if disable then
                    if affectA then PSTATE.A = '1';
                    if affectI then PSTATE.I = '1';
                    if affectF then PSTATE.F = '1';
                if changemode then
                    // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
                    AArch32.WriteModeByInstr(mode);
        else
            EncodingSpecificOperations();
            if PSTATE.EL != EL0 then
                if enable then
                    if affectA then PSTATE.A = '0';
                    if affectI then PSTATE.I = '0';
                    if affectF then PSTATE.F = '0';
                if disable then
                    if affectA then PSTATE.A = '1';
                    if affectI then PSTATE.I = '1';
                    if affectF then PSTATE.F = '1';
                if changemode then
                    // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
                    AArch32.WriteModeByInstr(mode);

__instruction aarch32_TBB_A
    __encoding aarch32_TBB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field H 4 +: 1
        __field Rm 0 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  is_tbh = (H == '1');
            if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if is_tbh then
                halfwords = UInt(MemU[R[n]+LSL(R[m],1), 2]);
            else
                halfwords = UInt(MemU[R[n]+R[m], 1]);
            BranchWritePC(PC + 2*halfwords);

__instruction aarch32_LDRD_r_A
    __encoding aarch32_LDRD_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x0xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rt<0> == '1' then UNPREDICTABLE;
            t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if P == '0' && W == '1' then UNPREDICTABLE;
            if t2 == 15 || m == 15 || m == t || m == t2 then UNPREDICTABLE;
            if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);
            address = if index then offset_addr else R[n];
            if address == Align(address, 8) then
                data = MemA[address,8];
                if BigEndian() then
                    R[t] = data<63:32>;
                    R[t2] = data<31:0>;
                else
                    R[t] = data<31:0>;
                    R[t2] = data<63:32>;
            else
                R[t] = MemA[address,4];
                R[t2] = MemA[address+4,4];
        
            if wback then R[n] = offset_addr;

__instruction aarch32_SETEND_A
    __encoding aarch32_SETEND_A1_A
        __instruction_set A32
        __field E 9 +: 1
        __opcode '11110001 0000xxx1 xxxxxxxx 0000xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            set_bigend = (E == '1');

    __encoding aarch32_SETEND_T1_A
        __instruction_set T16
        __field E 3 +: 1
        __opcode '10110110 010xxxxx'
        __guard TRUE
        __unpredictable_unless 4 == '1'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            set_bigend = (E == '1');
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations();
        AArch32.CheckSETENDEnabled();
        PSTATE.E = if set_bigend then '1' else '0';

__instruction aarch32_VMAXNM_A
    __encoding aarch32_VMAXNM_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAXNM_A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x00xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            advsimd = FALSE;
            maximum = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VMAXNM_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __encoding aarch32_VMAXNM_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x00xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            advsimd = FALSE;
            maximum = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then             // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[n+r], e, esize]; op2 = Elem[D[m+r], e, esize];
                    if maximum then
                        Elem[D[d+r], e, esize] = FPMaxNum(op1, op2, StandardFPSCRValue());
                    else
                        Elem[D[d+r], e, esize] = FPMinNum(op1, op2, StandardFPSCRValue());
        else                        // VFP instruction
            case esize of
                when 16
                    if maximum then
                        S[d] = Zeros(16) : FPMaxNum(S[n]<15:0>, S[m]<15:0>, FPSCR);
                    else
                        S[d] = Zeros(16) : FPMinNum(S[n]<15:0>, S[m]<15:0>, FPSCR);
                when 32
                    if maximum then
                        S[d] = FPMaxNum(S[n], S[m], FPSCR);
                    else
                        S[d] = FPMinNum(S[n], S[m], FPSCR);
                when 64
                    if maximum then
                        D[d] = FPMaxNum(D[n], D[m], FPSCR);
                    else
                        D[d] = FPMinNum(D[n], D[m], FPSCR);

__instruction aarch32_SBC_i_A
    __encoding aarch32_SBC_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 110xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_SBC_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 011xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result, nzcv) = AddWithCarry(R[n], NOT(imm32), PSTATE.C);
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VPMAX_f_A
    __encoding aarch32_VPMAX_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x1xxxxx xxxx1111 x0x0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPMAX_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x1xxxxx xxxx1111 x0x0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            bits(64) dest;
            h = elements DIV 2;
        
            for e = 0 to h-1
                op1 = Elem[D[n],2*e,esize];  op2 = Elem[D[n],2*e+1,esize];
                Elem[dest,e,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());
                op1 = Elem[D[m],2*e,esize];  op2 = Elem[D[m],2*e+1,esize];
                Elem[dest,e+h,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());
        
            D[d] = dest;

__instruction aarch32_VMLA_f_A
    __encoding aarch32_VMLA_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;  add = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_f_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x00xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE; add = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VMLA_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE;  add = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_f_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x00xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE; add = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if advsimd then  // Advanced SIMD instruction
                for r = 0 to regs-1
                    for e = 0 to elements-1
                        product = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
                        addend = if add then product else FPNeg(product);
                        Elem[D[d+r],e,esize] = FPAdd(Elem[D[d+r],e,esize], addend, StandardFPSCRValue());
            else             // VFP instruction
                case esize of
                    when 16
                        addend16 = if add then FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR) else FPNeg(FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR));
                        S[d] = Zeros(16) : FPAdd(S[d]<15:0>, addend16, FPSCR);
                    when 32
                        addend32 = if add then FPMul(S[n], S[m], FPSCR) else FPNeg(FPMul(S[n], S[m], FPSCR));
                        S[d] = FPAdd(S[d], addend32, FPSCR);
                    when 64
                        addend64 = if add then FPMul(D[n], D[m], FPSCR) else FPNeg(FPMul(D[n], D[m], FPSCR));
                        D[d] = FPAdd(D[d], addend64, FPSCR);

__instruction aarch32_VRINTA_vfp_A
    __encoding aarch32_VRINTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111000 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111000 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_VABA_A
    __encoding aarch32_VABA_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0101 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __encoding aarch32_VABA_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0101 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];
                    op2 = Elem[Din[m+r],e,esize];
                    absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + absdiff;
                    else
                        Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + absdiff;

__instruction aarch32_VSRI_A
    __encoding aarch32_VSRI_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1xxxxxxx xxxx0100 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSRI_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1xxxxxxx xxxx0100 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            mask = LSR(Ones(esize), shift_amount);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    shifted_op = LSR(Elem[D[m+r],e,esize], shift_amount);
                    Elem[D[d+r],e,esize] = (Elem[D[d+r],e,esize] AND NOT(mask)) OR shifted_op;

__instruction aarch32_SETPAN_A
    __encoding aarch32_SETPAN_A1_A
        __instruction_set A32
        __field imm1 9 +: 1
        __opcode '11110001 0001xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if !HavePANExt() then UNDEFINED;
            value = imm1;

    __encoding aarch32_SETPAN_T1_A
        __instruction_set T16
        __field imm1 3 +: 1
        __opcode '10110110 000xxxxx'
        __guard TRUE
        __unpredictable_unless 4 == '1'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if !HavePANExt() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            value = imm1;

    __execute
        EncodingSpecificOperations();
        if PSTATE.EL != EL0 then
            PSTATE.PAN = value;

__instruction aarch32_VTBL_A
    __encoding aarch32_VTBL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field len 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xxxx xxxx10xx xxx0xxxx'
        __guard TRUE
        __decode
            is_vtbl = (op == '0');  length = UInt(len)+1;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            if n+length > 32 then UNPREDICTABLE;

    __encoding aarch32_VTBL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field len 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xxxx xxxx10xx xxx0xxxx'
        __guard TRUE
        __decode
            is_vtbl = (op == '0');  length = UInt(len)+1;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            if n+length > 32 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
        
            // Create 256-bit = 32-byte table variable, with zeros in entries that will not be used.
            table3 = if length == 4 then D[n+3] else Zeros(64);
            table2 = if length >= 3 then D[n+2] else Zeros(64);
            table1 = if length >= 2 then D[n+1] else Zeros(64);
            table = table3 : table2 : table1 : D[n];
        
            for i = 0 to 7
                index = UInt(Elem[D[m],i,8]);
                if index < 8*length then
                    Elem[D[d],i,8] = Elem[table,index,8];
                else
                    if is_vtbl then
                        Elem[D[d],i,8] = Zeros(8);
                    // else Elem[D[d],i,8] unchanged

__instruction aarch32_AESD_A
    __encoding aarch32_AESD_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0011 01x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_AESD_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0011 01x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            op1 = Q[d>>1]; op2 = Q[m>>1];
            Q[d>>1] = AESInvSubBytes(AESInvShiftRows(op1 EOR op2));

__instruction aarch32_VCVTA_asimd_A
    __encoding aarch32_VCVTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx0000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx0000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckAdvSIMDEnabled();
        bits(esize) result;
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,
                                                 StandardFPSCRValue(), rounding);

__instruction aarch32_VABD_f_A
    __encoding aarch32_VABD_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x1xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VABD_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x1xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                    Elem[D[d+r],e,esize] = FPAbs(FPSub(op1,op2,StandardFPSCRValue()));

__instruction aarch32_VEXT_A
    __encoding aarch32_VEXT_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field imm4 8 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1x11xxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if Q == '0' && imm4<3> == '1' then UNDEFINED;
            quadword_operation = (Q == '1');  position = 8 * UInt(imm4);
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VEXT_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field imm4 8 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1x11xxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if Q == '0' && imm4<3> == '1' then UNDEFINED;
            quadword_operation = (Q == '1');  position = 8 * UInt(imm4);
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            if quadword_operation then
                Q[d>>1] = (Q[m>>1]:Q[n>>1])<position+127:position>;
            else
                D[d] = (D[m]:D[n])<position+63:position>;

__instruction aarch32_VADDHN_A
    __encoding aarch32_VADDHN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx0100 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VADDHN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx0100 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                result = Elem[Qin[n>>1],e,2*esize] + Elem[Qin[m>>1],e,2*esize];
                Elem[D[d],e,esize] = result<2*esize-1:esize>;

__instruction aarch32_VLDM_A
    __encoding aarch32_VLDM_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx1xxxx xxxx1011 xxxxxxx1'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VLDR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FLDM*X".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VLDM_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx1xxxx xxxx1011 xxxxxxx1'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VLDR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FLDM*X".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            address = if add then R[n] else R[n]-imm32;
            for r = 0 to regs-1
                if single_regs then
                    S[d+r] = MemA[address,4];  address = address+4;
                else
                    word1 = MemA[address,4];  word2 = MemA[address+4,4];  address = address+8;
                    // Combine the word-aligned words in the correct order for current endianness.
                    D[d+r] = if BigEndian() then word1:word2 else word2:word1;
            if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;

__instruction aarch32_STM_A
    __encoding aarch32_STM_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1000 10x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __encoding aarch32_STM_T1_A
        __instruction_set T16
        __field Rn 8 +: 3
        __field register_list 0 +: 8
        __opcode '11000xxx xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  registers = '00000000':register_list;  wback = TRUE;
            if BitCount(registers) < 1 then UNPREDICTABLE;

    __encoding aarch32_STM_T2_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field P 15 +: 1
        __field M 14 +: 1
        __field register_list 0 +: 14
        __opcode '11101000 10x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 13 == '0'
        __decode
            n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;
            if registers<13> == '1' then UNPREDICTABLE;
            if registers<15> == '1' then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            for i = 0 to 14
                if registers<i> == '1' then
                    if i == n && wback && i != LowestSetBit(registers) then
                        MemA[address,4] = bits(32) UNKNOWN;  // Only possible for encodings T1 and A1
                    else
                        MemA[address,4] = R[i];
                    address = address + 4;
            if registers<15> == '1' then  // Only possible for encoding A1
                MemA[address,4] = PCStoreValue();
            if wback then R[n] = R[n] + 4*BitCount(registers);

__instruction aarch32_LDAEXB_A
    __encoding aarch32_LDAEXB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1101xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAEXB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1100xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            AArch32.SetExclusiveMonitors(address, 1);
            R[t] = ZeroExtend(MemO[address, 1], 32);

__instruction aarch32_ORR_i_A
    __encoding aarch32_ORR_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 100xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_ORR_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 010xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE MOV (immediate);
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = R[n] OR imm32;
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_VCVTA_vfp_A
    __encoding aarch32_VCVTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111110 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __encoding aarch32_VCVTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111110 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
            when 32
                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
            when 64
                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_SHA256SU0_A
    __encoding aarch32_SHA256SU0_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0011 11x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_SHA256SU0_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0011 11x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            bits(128) result;
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            X = Q[d>>1]; Y = Q[m>>1];
            T = Y<31:0> : X<127:32>;
            for e = 0 to 3
                elt = Elem[T, e, 32];
                elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);
                Elem[result, e, 32] = elt + Elem[X, e, 32];
            Q[d>>1] = result;

__instruction aarch32_CMN_i_A
    __encoding aarch32_CMN_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0111xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_CMN_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm8 0 +: 8
        __opcode '11110x01 0001xxxx 0xxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  imm32 = T32ExpandImm(i:imm3:imm8);
            if n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result, nzcv) = AddWithCarry(R[n], imm32, '0');
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_STMIB_A
    __encoding aarch32_STMIB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1001 10x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n] + 4;
            for i = 0 to 14
                if registers<i> == '1' then
                    if i == n && wback && i != LowestSetBit(registers) then
                        MemA[address,4] = bits(32) UNKNOWN;
                    else
                        MemA[address,4] = R[i];
                    address = address + 4;
            if registers<15> == '1' then
                MemA[address,4] = PCStoreValue();
            if wback then R[n] = R[n] + 4*BitCount(registers);

__instruction aarch32_VQRDMLSH_A
    __encoding aarch32_VQRDMLSH_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            add = FALSE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMLSH_A2_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1111 x1x0xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            add = FALSE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQRDMLSH_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            add = FALSE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMLSH_T2_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1111 x1x0xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            add = FALSE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        EncodingSpecificOperations();  CheckAdvSIMDEnabled();
        round_const = 1 << (esize-1);
        if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = SInt(Elem[D[n+r],e,esize]);
                op3 = SInt(Elem[D[d+r],e,esize]) << esize;
                if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
                (result, sat) = SignedSatQ((op3 - 2*(op1*op2) + round_const) >> esize, esize);
                Elem[D[d+r],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_VMLA_i_A
    __encoding aarch32_VMLA_i_T1A1_A
        __instruction_set A32
        __field op 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1001 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            add = (op == '0');  long_destination = FALSE;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_i_T1A1_A
        __instruction_set T32
        __field op 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1001 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            add = (op == '0');  long_destination = FALSE;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);
                    addend = if add then product else -product;
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                    else
                        Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_LDM_e_AS
    __encoding aarch32_LDM_e_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 15
        __opcode 'xxxx100x x1x1xxxx 1xxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;
            wback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);
            if n == 15 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if PSTATE.EL == EL2 then
                UNDEFINED;
            elsif PSTATE.M IN {M32_User,M32_System} then
                UNPREDICTABLE;                        // UNDEFINED or NOP
            else
                length = 4*BitCount(registers) + 4;
                address = if increment then R[n] else R[n]-length;
                if wordhigher then address = address+4;
        
                for i = 0 to 14
                    if registers<i> == '1' then
                        R[i] = MemA[address,4];  address = address + 4;
                new_pc_value = MemA[address,4];
        
                if wback && registers<n> == '0' then R[n] = if increment then R[n]+length else R[n]-length;
                if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;
        
                AArch32.ExceptionReturn(new_pc_value, SPSR[]);

__instruction aarch32_UXTH_A
    __encoding aarch32_UXTH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 11111111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTH_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rd 0 +: 3
        __opcode '10110010 10xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

    __encoding aarch32_UXTH_T2_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 00011111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d] = ZeroExtend(rotated<15:0>, 32);

__instruction aarch32_SHADD8_A
    __encoding aarch32_SHADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);
            sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);
            sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);
            sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);
            R[d]<7:0>   = sum1<8:1>;
            R[d]<15:8>  = sum2<8:1>;
            R[d]<23:16> = sum3<8:1>;
            R[d]<31:24> = sum4<8:1>;

__instruction aarch32_VQDMLAL_A
    __encoding aarch32_VQDMLAL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1011 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMLAL_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx0111 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQDMLAL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1011 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMLAL_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx0111 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            add = (op == '0');
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
            for e = 0 to elements-1
                if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
                op1 = SInt(Elem[Din[n],e,esize]);
                // The following only saturates if both op1 and op2 equal -(2^(esize-1))
                (product, sat1) = SignedSatQ(2*op1*op2, 2*esize);
                if add then
                    result = SInt(Elem[Qin[d>>1],e,2*esize]) + SInt(product);
                else
                    result = SInt(Elem[Qin[d>>1],e,2*esize]) - SInt(product);
                (Elem[Q[d>>1],e,2*esize], sat2) = SignedSatQ(result, 2*esize);
                if sat1 || sat2 then FPSCR.QC = '1';

__instruction aarch32_VMLA_i_A
    __encoding aarch32_VMLA_i_T1A1_A
        __instruction_set A32
        __field op 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0xxxxxxx xxxx1001 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            add = (op == '0');  long_destination = FALSE;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_i_T1A1_A
        __instruction_set T32
        __field op 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0xxxxxxx xxxx1001 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            add = (op == '0');  long_destination = FALSE;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);
                    addend = if add then product else -product;
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                    else
                        Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_UHADD16_A
    __encoding aarch32_UHADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);
            sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);
            R[d]<15:0>  = sum1<16:1>;
            R[d]<31:16> = sum2<16:1>;

__instruction aarch32_SHASX_A
    __encoding aarch32_SHASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);
            sum  = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);
            R[d]<15:0>  = diff<16:1>;
            R[d]<31:16> = sum<16:1>;

__instruction aarch32_MCR_A
    __encoding aarch32_MCR_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field opc1 21 +: 3
        __field CRn 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc2 5 +: 3
        __field CRm 0 +: 4
        __opcode 'xxxx1110 xxx0xxxx xxxx111x xxx1xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15  then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_MCR_T1A1_A
        __instruction_set T32
        __field opc1 21 +: 3
        __field CRn 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc2 5 +: 3
        __field CRm 0 +: 4
        __opcode '11101110 xxx0xxxx xxxx111x xxx1xxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15  then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            AArch32.CheckSystemAccess(cp, ThisInstr());
            AArch32.SysRegWrite(cp, ThisInstr(), R[t]);

__instruction aarch32_VCVTA_asimd_A
    __encoding aarch32_VCVTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx0001 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx0001 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckAdvSIMDEnabled();
        bits(esize) result;
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,
                                                 StandardFPSCRValue(), rounding);

__instruction aarch32_SUB_SP_r_A
    __encoding aarch32_SUB_SP_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 010x1101 xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_SUB_SP_r_T1_A
        __instruction_set T32
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 101x1101 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE CMP (register);
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(SP, NOT(shifted), '1');
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_EOR_rr_A
    __encoding aarch32_EOR_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 001xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] EOR shifted;
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_STRBT_A
    __encoding aarch32_STRBT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0100 x110xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_STRBT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 x110xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_STRBT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0000xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            EncodingSpecificOperations();
            offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if postindex then R[n] else offset_addr;
            MemU_unpriv[address,1] = R[t]<7:0>;
            if postindex then R[n] = offset_addr;

__instruction aarch32_VMLA_s_A
    __encoding aarch32_VMLA_s_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0010 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMLA_s_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0010 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                    if floating_point then
                        fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));
                        Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());
                    else
                        addend = if add then op1val*op2val else -op1val*op2val;
                        if long_destination then
                            Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                        else
                            Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_MRRC_A
    __encoding aarch32_MRRC_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc1 4 +: 4
        __field CRm 0 +: 4
        __opcode 'xxxx1100 0101xxxx xxxx111x xxxxxxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_MRRC_T1A1_A
        __instruction_set T32
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc1 4 +: 4
        __field CRm 0 +: 4
        __opcode '11101100 0101xxxx xxxx111x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            AArch32.CheckSystemAccess(cp, ThisInstr());
            value = AArch32.SysRegRead64(cp, ThisInstr());
            R[t] = value<31:0>;
            R[t2] = value<63:32>;

__instruction aarch32_BXJ_A
    __encoding aarch32_BXJ_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 0010xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            m = UInt(Rm);
            if m == 15 then UNPREDICTABLE;

    __encoding aarch32_BXJ_T1_A
        __instruction_set T32
        __field Rm 16 +: 4
        __opcode '11110011 1100xxxx 10x0xxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            m = UInt(Rm);
            if m == 15 then UNPREDICTABLE;  // ARMv8-A removes UNPREDICTABLE for R13
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            BXWritePC(R[m]);

__instruction aarch32_SHA1C_A
    __encoding aarch32_SHA1C_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x00xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA1C_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x00xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            X = Q[d>>1];
            Y = Q[n>>1]<31:0>; // Note: 32 bits wide
            W = Q[m>>1];
            for e = 0 to 3
                t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);
                Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
                X<63:32> = ROL(X<63:32>, 30);
                <Y, X> = ROL(Y:X, 32);
            Q[d>>1] = X;

__instruction aarch32_LDM_A
    __encoding aarch32_LDM_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1000 10x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;

    __encoding aarch32_LDM_T1_A
        __instruction_set T16
        __field Rn 8 +: 3
        __field register_list 0 +: 8
        __opcode '11001xxx xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  registers = '00000000':register_list;  wback = (registers<n> == '0');
            if BitCount(registers) < 1 then UNPREDICTABLE;

    __encoding aarch32_LDM_T2_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field P 15 +: 1
        __field M 14 +: 1
        __field register_list 0 +: 14
        __opcode '11101000 10x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __decode
            n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 2 || (P == '1' && M == '1') then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;
            if registers<13> == '1' then UNPREDICTABLE;
            if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            for i = 0 to 14
                if registers<i> == '1' then
                    R[i] = MemA[address,4];  address = address + 4;
            if registers<15> == '1' then
                LoadWritePC(MemA[address,4]);
            if wback && registers<n> == '0' then R[n] = R[n] + 4*BitCount(registers);
            if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;

__instruction aarch32_BLX_r_A
    __encoding aarch32_BLX_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            m = UInt(Rm);
            if m == 15 then UNPREDICTABLE;

    __encoding aarch32_BLX_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 4
        __opcode '01000111 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            m = UInt(Rm);
            if m == 15 then UNPREDICTABLE;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            target = R[m];
            if CurrentInstrSet() == InstrSet_A32 then
                next_instr_addr = PC - 4;
                LR = next_instr_addr;
            else
                next_instr_addr = PC - 2;
                LR = next_instr_addr<31:1> : '1';
            BXWritePC(target);

__instruction aarch32_AND_rr_A
    __encoding aarch32_AND_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 000xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] AND shifted;
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_VZIP_A
    __encoding aarch32_VZIP_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0001 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || (Q == '0' && size == '10') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            quadword_operation = (Q == '1');  esize = 8 << UInt(size);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VZIP_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0001 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || (Q == '0' && size == '10') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            quadword_operation = (Q == '1');  esize = 8 << UInt(size);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            if quadword_operation then
                if d == m then
                    Q[d>>1] = bits(128) UNKNOWN;  Q[m>>1] = bits(128) UNKNOWN;
                else
                    bits(256) zipped_q;
                    for e = 0 to (128 DIV esize) - 1
                        Elem[zipped_q,2*e,esize] = Elem[Q[d>>1],e,esize];
                        Elem[zipped_q,2*e+1,esize] = Elem[Q[m>>1],e,esize];
                    Q[d>>1] = zipped_q<127:0>;  Q[m>>1] = zipped_q<255:128>;
            else
                if d == m then
                    D[d] = bits(64) UNKNOWN;  D[m] = bits(64) UNKNOWN;
                else
                    bits(128) zipped_d;
                    for e = 0 to (64 DIV esize) - 1
                        Elem[zipped_d,2*e,esize] = Elem[D[d],e,esize];
                        Elem[zipped_d,2*e+1,esize] = Elem[D[m],e,esize];
                    D[d] = zipped_d<63:0>;  D[m] = zipped_d<127:64>;

__instruction aarch32_VCVT_iv_A
    __encoding aarch32_VCVT_iv_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x11110x xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __encoding aarch32_VCVT_iv_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x11110x xxxx10xx 11x0xxxx'
        __guard TRUE
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            if to_integer then
                case esize of
                    when 16
                        S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
                    when 32
                        S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
                    when 64
                        S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);
            else
                case esize of
                    when 16
                        bits(16) fp16 = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                        S[d] = Zeros(16):fp16;
                    when 32
                        S[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                    when 64
                        D[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_LDRD_l_A
    __encoding aarch32_LDRD_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x01111 xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 24 == '1'
        __unpredictable_unless 21 == '0'
        __decode
            if Rt<0> == '1' then UNPREDICTABLE;
            t = UInt(Rt);  t2 = t+1;  imm32 = ZeroExtend(imm4H:imm4L, 32);  add = (U == '1');
            if t2 == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRD_l_T1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __field imm8 0 +: 8
        __opcode '1110100x x1x11111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && W == '0' then SEE "Related encodings";
            t = UInt(Rt);  t2 = UInt(Rt2);
            imm32 = ZeroExtend(imm8:'00', 32);  add = (U == '1');
            if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13
            if W == '1' then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
            if address == Align(address, 8) then
                data = MemA[address,8];
                if BigEndian() then
                    R[t] = data<63:32>;
                    R[t2] = data<31:0>;
                else
                    R[t] = data<31:0>;
                    R[t2] = data<63:32>;
            else
                R[t] = MemA[address,4];
                R[t2] = MemA[address+4,4];

__instruction aarch32_TST_rr_A
    __encoding aarch32_TST_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0001xxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            shift_t = DecodeRegShift(type1);
            if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] AND shifted;
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_SUB_SP_i_A
    __encoding aarch32_SUB_SP_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 010x1101 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_SUB_SP_i_T1_A
        __instruction_set T16
        __field imm7 0 +: 7
        __opcode '10110000 1xxxxxxx'
        __guard TRUE
        __decode
            d = 13;  setflags = FALSE;  imm32 = ZeroExtend(imm7:'00', 32);

    __encoding aarch32_SUB_SP_i_T2_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 101x1101 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE CMP (immediate);
            d = UInt(Rd);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if d == 15 && !setflags then UNPREDICTABLE;

    __encoding aarch32_SUB_SP_i_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 10101101 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
            if d == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result, nzcv) = AddWithCarry(SP, NOT(imm32), '1');
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_STC_A
    __encoding aarch32_STC_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x x0x0xxxx 01011110 xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            n = UInt(Rn);  cp = 14;
            imm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;

    __encoding aarch32_STC_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x x0x0xxxx 01011110 xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            n = UInt(Rn);  cp = 14;
            imm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            AArch32.CheckSystemAccess(cp, ThisInstr());
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
        
            // System register read from DBGDTRRXint.
            MemA[address,4] = DBGDTR_EL0[];
        
            if wback then R[n] = offset_addr;

__instruction aarch32_QASX_A
    __encoding aarch32_QASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);
            sum  = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);
            R[d]<15:0>  = SignedSat(diff, 16);
            R[d]<31:16> = SignedSat(sum, 16);

__instruction aarch32_BKPT_A
    __encoding aarch32_BKPT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm12 8 +: 12
        __field imm4 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __decode
            imm16 = imm12:imm4;
            if cond != '1110' then UNPREDICTABLE;  // BKPT must be encoded with AL condition

    __encoding aarch32_BKPT_T1_A
        __instruction_set T16
        __field imm8 0 +: 8
        __opcode '10111110 xxxxxxxx'
        __guard TRUE
        __decode
            imm16 = ZeroExtend(imm8, 16);

    __execute
        EncodingSpecificOperations();
        AArch32.SoftwareBreakpoint(imm16);

__instruction aarch32_VHADD_A
    __encoding aarch32_VHADD_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            add = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VHADD_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            add = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Int(Elem[D[n+r],e,esize], unsigned);
                    op2 = Int(Elem[D[m+r],e,esize], unsigned);
                    result = if add then op1+op2 else op1-op2;
                    Elem[D[d+r],e,esize] = result<esize:1>;

__instruction aarch32_VCVTA_vfp_A
    __encoding aarch32_VCVTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111111 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __encoding aarch32_VCVTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111111 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
            when 32
                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
            when 64
                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_REVSH_A
    __encoding aarch32_REVSH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1111xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  m = UInt(Rm);
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_REVSH_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rd 0 +: 3
        __opcode '10111010 11xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);

    __encoding aarch32_REVSH_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 1011xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
            if m != n || d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            bits(32) result;
            result<31:8>  = SignExtend(R[m]<7:0>, 24);
            result<7:0>   = R[m]<15:8>;
            R[d] = result;

__instruction aarch32_CRC32_A
    __encoding aarch32_CRC32_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sz 21 +: 2
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field C 9 +: 1
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0xx0xxxx xxxxxx0x 0100xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if ! HaveCRCExt() then UNDEFINED;
            d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
            size = 8 << UInt(sz);
            crc32c = (C == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if size == 64 then UNPREDICTABLE;
            if cond != '1110' then UNPREDICTABLE;

    __encoding aarch32_CRC32_T1_A
        __instruction_set T32
        __field C 20 +: 1
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field sz 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 10xxxxxx'
        __guard TRUE
        __decode
            if ! HaveCRCExt() then UNDEFINED;
            d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
            size = 8 << UInt(sz);
            crc32c = (C == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if size == 64 then UNPREDICTABLE;
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
        
            acc = R[n];             // accumulator
            val = R[m]<size-1:0>;   // input value
            poly = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;
            tempacc = BitReverse(acc):Zeros(size);
            tempval = BitReverse(val):Zeros(32);
            // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
            R[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));

__instruction aarch32_VMRS_AS
    __encoding aarch32_VMRS_T1A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field reg 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx1110 1111xxxx xxxx1010 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            t = UInt(Rt);
            if !(reg IN {'000x', '0101', '011x', '1000'}) then UNPREDICTABLE;
            if t == 15 && reg != '0001' then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMRS_T1A1_AS
        __instruction_set T32
        __field reg 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101110 1111xxxx xxxx1010 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            t = UInt(Rt);
            if !(reg IN {'000x', '0101', '011x', '1000'}) then UNPREDICTABLE;
            if t == 15 && reg != '0001' then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if reg == '0001' then                 // FPSCR
                CheckVFPEnabled(TRUE);
                if t == 15 then
                    PSTATE.<N,Z,C,V> = FPSR.<N,Z,C,V>;
                else
                    R[t] = FPSCR;
            elsif PSTATE.EL == EL0 then
                UNDEFINED;                        // Non-FPSCR registers accessible only at PL1 or above
            else
                CheckVFPEnabled(FALSE);           // Non-FPSCR registers are not affected by FPEXC.EN
                case reg of
                    // Pseudocode does not consider possible HCR.TIDn Hyp Traps of Non-secure register reads
                    when '0000'  R[t] = FPSID;
                    when '0101'  R[t] = MVFR2;
                    when '0110'  R[t] = MVFR1;
                    when '0111'  R[t] = MVFR0;
                    when '1000'  R[t] = FPEXC;
                    otherwise    Unreachable();   // Dealt with above or in encoding-specific pseudocode

__instruction aarch32_VMAX_f_A
    __encoding aarch32_VMAX_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x1xxxxx xxxx1111 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAX_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x1xxxxx xxxx1111 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                    if maximum then
                        Elem[D[d+r],e,esize] = FPMax(op1, op2, StandardFPSCRValue());
                    else
                        Elem[D[d+r],e,esize] = FPMin(op1, op2, StandardFPSCRValue());

__instruction aarch32_VQRSHRN_A
    __encoding aarch32_VQRSHRN_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx100x 01x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then SEE VRSHRN;
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VQRSHRN_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx100x 01x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then SEE VRSHRN;
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            round_const = 1 << (shift_amount - 1);
            for e = 0 to elements-1
                operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
                (result, sat) = SatQ((operand + round_const) >> shift_amount, esize, dest_unsigned);
                Elem[D[d],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_VCVTB_A
    __encoding aarch32_VCVTB_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field op 16 +: 1
        __field Vd 12 +: 4
        __field sz 8 +: 1
        __field T 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x11001x xxxx101x 01x0xxxx'
        __guard cond != '1111'
        __decode
            uses_double = (sz == '1'); convert_from_half = (op == '0');
            lowbit = (if T == '1' then 16 else 0);
            if uses_double then
                if convert_from_half then
                    d = UInt(D:Vd); m = UInt(Vm:M);
                else
                    d = UInt(Vd:D); m = UInt(M:Vm);
            else
                d = UInt(Vd:D); m = UInt(Vm:M);

    __encoding aarch32_VCVTB_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 16 +: 1
        __field Vd 12 +: 4
        __field sz 8 +: 1
        __field T 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x11001x xxxx101x 01x0xxxx'
        __guard TRUE
        __decode
            uses_double = (sz == '1'); convert_from_half = (op == '0');
            lowbit = (if T == '1' then 16 else 0);
            if uses_double then
                if convert_from_half then
                    d = UInt(D:Vd); m = UInt(Vm:M);
                else
                    d = UInt(Vd:D); m = UInt(M:Vm);
            else
                d = UInt(Vd:D); m = UInt(Vm:M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
            bits(16) hp;
            if convert_from_half then
                hp = S[m]<lowbit+15:lowbit>;
                if uses_double then
                    D[d] = FPConvert(hp, FPSCR);
                else
                    S[d] = FPConvert(hp, FPSCR);
            else
                if uses_double then
                    hp = FPConvert(D[m], FPSCR);
                else
                    hp = FPConvert(S[m], FPSCR);
                S[d]<lowbit+15:lowbit> = hp;

__instruction aarch32_VPMAX_i_A
    __encoding aarch32_VPMAX_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx1010 x0x1xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPMAX_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx1010 x0x1xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            bits(64) dest;
            h = elements DIV 2;
        
            for e = 0 to h-1
                op1 = Int(Elem[D[n],2*e,esize], unsigned);
                op2 = Int(Elem[D[n],2*e+1,esize], unsigned);
                result = if maximum then Max(op1,op2) else Min(op1,op2);
                Elem[dest,e,esize] = result<esize-1:0>;
                op1 = Int(Elem[D[m],2*e,esize], unsigned);
                op2 = Int(Elem[D[m],2*e+1,esize], unsigned);
                result = if maximum then Max(op1,op2) else Min(op1,op2);
                Elem[dest,e+h,esize] = result<esize-1:0>;
        
            D[d] = dest;

__instruction aarch32_VLD1_a_A
    __encoding aarch32_VLD1_a_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' || (size == '00' && a == '1') then UNDEFINED;
            ebytes = 1 << UInt(size);  regs = if T == '0' then 1 else 2;
            alignment = if a == '0' then 1 else ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_a_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' || (size == '00' && a == '1') then UNDEFINED;
            ebytes = 1 << UInt(size);  regs = if T == '0' then 1 else 2;
            alignment = if a == '0' then 1 else ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = FALSE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            bits(64) replicated_element = Replicate(MemU[address,ebytes]);
            for r = 0 to regs-1
                D[d+r] = replicated_element;
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + ebytes;

__instruction aarch32_STREXD_A
    __encoding aarch32_STREXD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1010xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);
            if d == 15 || Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t || d == t2 then UNPREDICTABLE;

    __encoding aarch32_STREXD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 0111xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
            if d == 15 || t == 15 || t2 == 15 || n == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13
            if d == n || d == t || d == t2 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            // Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.
            value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];
            if AArch32.ExclusiveMonitorsPass(address,8) then
                MemA[address,8] = value;  R[d] = ZeroExtend('0');
            else
                R[d] = ZeroExtend('1');

__instruction aarch32_VLD2_1_A
    __encoding aarch32_VLD2_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD2 (single 2-element structure to all lanes);
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD2 (single 2-element structure to all lanes);
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD2 (single 2-element structure to all lanes);
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD2 (single 2-element structure to all lanes);
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD2 (single 2-element structure to all lanes);
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD2 (single 2-element structure to all lanes);
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = FALSE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            Elem[D[d], index] = MemU[address,ebytes];
            Elem[D[d2],index] = MemU[address+ebytes,ebytes];
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 2*ebytes;

__instruction aarch32_VQRDMULH_A
    __encoding aarch32_VQRDMULH_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMULH_T2A2_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1101 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQRDMULH_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMULH_T2A2_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1101 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            round_const = 1 << (esize-1);
            if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = SInt(Elem[D[n+r],e,esize]);
                    if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
                    (result, sat) = SignedSatQ((2*op1*op2 + round_const) >> esize, esize);
                    Elem[D[d+r],e,esize] = result;
                    if sat then FPSCR.QC = '1';

__instruction aarch32_SMLSLD_A
    __encoding aarch32_SMLSLD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0100xxxx xxxxxxxx 01x1xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_SMLSLD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 1101xxxx xxxxxxxx 110xxxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand2 = if m_swap then ROR(R[m],16) else R[m];
            product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
            product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
            result = product1 - product2 + SInt(R[dHi]:R[dLo]);
            R[dHi] = result<63:32>;
            R[dLo] = result<31:0>;

__instruction aarch32_UASX_A
    __encoding aarch32_UASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);
            sum  = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);
            R[d]<15:0>  = diff<15:0>;
            R[d]<31:16> = sum<15:0>;
            PSTATE.GE<1:0> = if diff >= 0 then '11' else '00';
            PSTATE.GE<3:2> = if sum  >= 0x10000 then '11' else '00';

__instruction aarch32_MSR_br_AS
    __encoding aarch32_MSR_br_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field R 22 +: 1
        __field M1 16 +: 4
        __field M 8 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0x10xxxx xxxxxx1x 0000xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __decode
            n = UInt(Rn);  write_spsr = (R == '1');
            if n == 15 then UNPREDICTABLE;
            SYSm = M:M1;

    __encoding aarch32_MSR_br_T1_AS
        __instruction_set T32
        __field R 20 +: 1
        __field Rn 16 +: 4
        __field M1 8 +: 4
        __field M 4 +: 1
        __opcode '11110011 100xxxxx 10x0xxxx xx1xxxxx'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            n = UInt(Rn);  write_spsr = (R == '1');
            if n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13
            SYSm = M:M1;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if PSTATE.EL == EL0 then
                UNPREDICTABLE;
            else
                mode = PSTATE.M;
                if write_spsr then
                    SPSRaccessValid(SYSm, mode);             // Check for UNPREDICTABLE cases
                    case SYSm of
                        when '01110'  SPSR_fiq = R[n];
                        when '10000'  SPSR_irq = R[n];
                        when '10010'  SPSR_svc = R[n];
                        when '10100'  SPSR_abt = R[n];
                        when '10110'  SPSR_und = R[n];
                        when '11100'
                            if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                            SPSR_mon = R[n];
                        when '11110'  SPSR_hyp = R[n];
                else
                    BankedRegisterAccessValid(SYSm, mode);  // Check for UNPREDICTABLE cases
                    case SYSm of
                        when '00xxx'                       // Access the User mode registers
                            m = UInt(SYSm<2:0>) + 8;
                            Rmode[m,M32_User] = R[n];
                        when '01xxx'                       // Access the FIQ mode registers
                            m = UInt(SYSm<2:0>) + 8;
                            Rmode[m,M32_FIQ] = R[n];
                        when '1000x'                       // Access the IRQ mode registers
                            m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                            Rmode[m,M32_IRQ] = R[n];
                        when '1001x'                       // Access the Supervisor mode registers
                            m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                            Rmode[m,M32_Svc] = R[n];
                        when '1010x'                       // Access the Abort mode registers
                            m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                            Rmode[m,M32_Abort] = R[n];
                        when '1011x'                       // Access the Undefined mode registers
                            m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                            Rmode[m,M32_Undef] = R[n];
                        when '1110x'                       // Access Monitor registers
                            if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                            m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                            Rmode[m,M32_Monitor] = R[n];
                        when '11110'                       // Access ELR_hyp register
                            ELR_hyp = R[n];
                        when '11111'                       // Access SP_hyp register
                            Rmode[13,M32_Hyp] = R[n];

__instruction aarch32_USUB16_A
    __encoding aarch32_USUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_USUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);
            diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);
            R[d]<15:0>  = diff1<15:0>;
            R[d]<31:16> = diff2<15:0>;
            PSTATE.GE<1:0> = if diff1 >= 0 then '11' else '00';
            PSTATE.GE<3:2> = if diff2 >= 0 then '11' else '00';

__instruction aarch32_VMLA_f_A
    __encoding aarch32_VMLA_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x1xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;  add = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_f_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x00xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE; add = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VMLA_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x1xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE;  add = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMLA_f_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x00xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE; add = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if advsimd then  // Advanced SIMD instruction
                for r = 0 to regs-1
                    for e = 0 to elements-1
                        product = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
                        addend = if add then product else FPNeg(product);
                        Elem[D[d+r],e,esize] = FPAdd(Elem[D[d+r],e,esize], addend, StandardFPSCRValue());
            else             // VFP instruction
                case esize of
                    when 16
                        addend16 = if add then FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR) else FPNeg(FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR));
                        S[d] = Zeros(16) : FPAdd(S[d]<15:0>, addend16, FPSCR);
                    when 32
                        addend32 = if add then FPMul(S[n], S[m], FPSCR) else FPNeg(FPMul(S[n], S[m], FPSCR));
                        S[d] = FPAdd(S[d], addend32, FPSCR);
                    when 64
                        addend64 = if add then FPMul(D[n], D[m], FPSCR) else FPNeg(FPMul(D[n], D[m], FPSCR));
                        D[d] = FPAdd(D[d], addend64, FPSCR);

__instruction aarch32_SUB_rr_A
    __encoding aarch32_SUB_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 010xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SHA256SU1_A
    __encoding aarch32_SHA256SU1_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x10xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA256SU1_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x10xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            bits(128) result;
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            X = Q[d>>1]; Y = Q[n>>1]; Z = Q[m>>1];
            T0 = Z<31:0> : Y<127:32>;
        
            T1 = Z<127:64>;
            for e = 0 to 1
                elt = Elem[T1, e, 32];
                elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
                elt = elt + Elem[X, e, 32] + Elem[T0, e, 32];
                Elem[result, e, 32] = elt;
        
            T1 = result<63:0>;
            for e = 2 to 3
                elt = Elem[T1, e - 2, 32];
                elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
                elt = elt + Elem[X, e, 32] + Elem[T0, e, 32];
                Elem[result, e, 32] = elt;
        
            Q[d>>1] = result;

__instruction aarch32_STRT_A
    __encoding aarch32_STRT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0100 x010xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
            if n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_STRT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 x010xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_STRT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0100xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            EncodingSpecificOperations();
            offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if postindex then R[n] else offset_addr;
            if t == 15 then  // Only possible for encodings A1 and A2
                data = PCStoreValue();
            else
                data = R[t];
            MemU_unpriv[address,4] = data;
            if postindex then R[n] = offset_addr;

__instruction aarch32_MOV_r_A
    __encoding aarch32_MOV_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 101xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_MOV_r_T1_A
        __instruction_set T16
        __field D 7 +: 1
        __field Rm 3 +: 4
        __field Rd 0 +: 3
        __opcode '01000110 xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(D:Rd);  m = UInt(Rm);  setflags = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);
            if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_MOV_r_T2_A
        __instruction_set T16
        __field op 11 +: 2
        __field imm5 6 +: 5
        __field Rm 3 +: 3
        __field Rd 0 +: 3
        __opcode '000xxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = DecodeImmShift(op, imm5);
            if op == '00' && imm5 == '00000' && InITBlock() then UNPREDICTABLE;

    __encoding aarch32_MOV_r_T3_A
        __instruction_set T32
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 010x1111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = shifted;
            if d == 15 then
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_ADD_SP_r_A
    __encoding aarch32_ADD_SP_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 100x1101 xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_ADD_SP_r_T1_A
        __instruction_set T16
        __field DM 7 +: 1
        __field Rdm 0 +: 3
        __opcode '01000100 x1101xxx'
        __guard TRUE
        __decode
            d = UInt(DM:Rdm);  m = UInt(DM:Rdm);  setflags = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);
            if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_ADD_SP_r_T2_A
        __instruction_set T16
        __field Rm 3 +: 4
        __opcode '01000100 1xxxx101'
        __guard TRUE
        __decode
            if Rm == '1101' then SEE encoding T1;
            d = 13;  m = UInt(Rm);  setflags = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_ADD_SP_r_T3_A
        __instruction_set T32
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 000x1101 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE CMN (register);
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(SP, shifted, '0');
            if d == 15 then
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_RSB_i_A
    __encoding aarch32_RSB_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 011xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_RSB_i_T1_A
        __instruction_set T16
        __field Rn 3 +: 3
        __field Rd 0 +: 3
        __opcode '01000010 01xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = !InITBlock();  imm32 = Zeros(32); // immediate = #0

    __encoding aarch32_RSB_i_T2_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 110xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result, nzcv) = AddWithCarry(NOT(R[n]), imm32, '1');
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VCVTA_asimd_A
    __encoding aarch32_VCVTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckAdvSIMDEnabled();
        bits(esize) result;
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,
                                                 StandardFPSCRValue(), rounding);

__instruction aarch32_STRH_i_A
    __encoding aarch32_STRH_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x0xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE STRHT;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STRH_i_T1_A
        __instruction_set T16
        __field imm5 6 +: 5
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '10000xxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'0', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_STRH_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1010xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_STRH_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0010xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '1' && U == '1' && W == '0' then SEE STRHT;
            if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                MemU[address,2] = R[t]<15:0>;
                if wback then R[n] = offset_addr;
        else
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                MemU[address,2] = R[t]<15:0>;
                if wback then R[n] = offset_addr;

__instruction aarch32_VCVT_xv_A
    __encoding aarch32_VCVT_xv_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field op 18 +: 1
        __field U 16 +: 1
        __field Vd 12 +: 4
        __field sf 8 +: 2
        __field sx 7 +: 1
        __field i 5 +: 1
        __field imm4 0 +: 4
        __opcode 'xxxx1110 1x111x1x xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if sf == '00' || (sf == '01' && !HaveFP16Ext()) then UNDEFINED;
            if sf == '01' && cond != '1110' then UNPREDICTABLE;
            to_fixed = (op == '1');  unsigned = (U == '1');
            size = if sx == '0' then 16 else 32;
            frac_bits = size - UInt(imm4:i);
            case sf of
                when '01' fp_size = 16; d = UInt(Vd:D);
                when '10' fp_size = 32; d = UInt(Vd:D);
                when '11' fp_size = 64; d = UInt(D:Vd);
            
            if frac_bits < 0 then UNPREDICTABLE;

    __encoding aarch32_VCVT_xv_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 18 +: 1
        __field U 16 +: 1
        __field Vd 12 +: 4
        __field sf 8 +: 2
        __field sx 7 +: 1
        __field i 5 +: 1
        __field imm4 0 +: 4
        __opcode '11101110 1x111x1x xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if sf == '00' || (sf == '01' && !HaveFP16Ext()) then UNDEFINED;
            if sf == '01' && InITBlock() then UNPREDICTABLE;
            to_fixed = (op == '1');  unsigned = (U == '1');
            size = if sx == '0' then 16 else 32;
            frac_bits = size - UInt(imm4:i);
            case sf of
                when '01' fp_size = 16; d = UInt(Vd:D);
                when '10' fp_size = 32; d = UInt(Vd:D);
                when '11' fp_size = 64; d = UInt(D:Vd);
            
            if frac_bits < 0 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            if to_fixed then
                bits(size) result;
                case fp_size of
                    when 16
                        result = FPToFixed(S[d]<15:0>, frac_bits, unsigned, FPSCR, FPRounding_ZERO);
                        S[d] = Extend(result, 32, unsigned);
                    when 32
                        result = FPToFixed(S[d], frac_bits, unsigned, FPSCR, FPRounding_ZERO);
                        S[d] = Extend(result, 32, unsigned);
                    when 64
                        result = FPToFixed(D[d], frac_bits, unsigned, FPSCR, FPRounding_ZERO);
                        D[d] = Extend(result, 64, unsigned);
            else
                case fp_size of
                    when 16
                        bits(16) fp16 = FixedToFP(S[d]<size-1:0>, frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);
                        S[d] = Zeros(16):fp16;
                    when 32
                        S[d] = FixedToFP(S[d]<size-1:0>, frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);
                    when 64
                        D[d] = FixedToFP(D[d]<size-1:0>, frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);

__instruction aarch32_VFMA_A
    __encoding aarch32_VFMA_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE; op1_neg = (op == '1');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VFMA_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x10xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE; op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VFMA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE; op1_neg = (op == '1');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VFMA_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x10xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE; op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if advsimd then // Advanced SIMD instruction
                for r = 0 to regs-1
                    for e = 0 to elements-1
                        bits(esize) op1 = Elem[D[n+r],e,esize];
                        if op1_neg then op1 = FPNeg(op1);
                        Elem[D[d+r],e,esize] = FPMulAdd(Elem[D[d+r],e,esize],
                                               op1, Elem[D[m+r],e,esize], StandardFPSCRValue());
        
            else // VFP instruction
                case esize of
                    when 16
                        op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;
                        S[d] = Zeros(16) : FPMulAdd(S[d]<15:0>, op16, S[m]<15:0>, FPSCR);
                    when 32
                        op32 = if op1_neg then FPNeg(S[n]) else S[n];
                        S[d] = FPMulAdd(S[d], op32, S[m], FPSCR);
                    when 64
                        op64 = if op1_neg then FPNeg(D[n]) else D[n];
                        D[d] = FPMulAdd(D[d], op64, D[m], FPSCR);

__instruction aarch32_VMUL_s_A
    __encoding aarch32_VMUL_s_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1010 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;  floating_point = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMUL_s_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1010 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;  floating_point = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                    if floating_point then
                        Elem[D[d+r],e,esize] = FPMul(op1, op2, StandardFPSCRValue());
                    else
                        if long_destination then
                            Elem[Q[d>>1],e,2*esize] = (op1val*op2val)<2*esize-1:0>;
                        else
                            Elem[D[d+r],e,esize] = (op1val*op2val)<esize-1:0>;

__instruction aarch32_VADD_i_A
    __encoding aarch32_VADD_i_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0xxxxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VADD_i_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0xxxxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = Elem[D[n+r],e,esize] + Elem[D[m+r],e,esize];

__instruction aarch32_VMAX_i_A
    __encoding aarch32_VMAX_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAX_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Int(Elem[D[n+r],e,esize], unsigned);
                    op2 = Int(Elem[D[m+r],e,esize], unsigned);
                    result = if maximum then Max(op1,op2) else Min(op1,op2);
                    Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_VRINTA_asimd_A
    __encoding aarch32_VRINTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0110 1xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0110 1xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_VEOR_A
    __encoding aarch32_VEOR_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x00xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VEOR_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x00xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                D[d+r] = D[n+r] EOR D[m+r];

__instruction aarch32_ADR_A
    __encoding aarch32_ADR_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 10001111 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  imm32 = A32ExpandImm(imm12);  add = TRUE;

    __encoding aarch32_ADR_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 01001111 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  imm32 = A32ExpandImm(imm12);  add = FALSE;

    __encoding aarch32_ADR_T1_A
        __instruction_set T16
        __field Rd 8 +: 3
        __field imm8 0 +: 8
        __opcode '10100xxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  imm32 = ZeroExtend(imm8:'00', 32);  add = TRUE;

    __encoding aarch32_ADR_T2_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 10101111 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  imm32 = ZeroExtend(i:imm3:imm8, 32);  add = FALSE;
            if d == 15 then UNPREDICTABLE;     // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_ADR_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 00001111 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  imm32 = ZeroExtend(i:imm3:imm8, 32);  add = TRUE;
            if d == 15 then UNPREDICTABLE;   // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
            if d == 15 then          // Can only occur for A32 encodings
                ALUWritePC(result);
            else
                R[d] = result;

__instruction aarch32_LDREXB_A
    __encoding aarch32_LDREXB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1101xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDREXB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 0100xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            AArch32.SetExclusiveMonitors(address,1);
            R[t] = ZeroExtend(MemA[address,1], 32);

__instruction aarch32_STMDB_A
    __encoding aarch32_STMDB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1001 00x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __encoding aarch32_STMDB_T1_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field P 15 +: 1
        __field M 14 +: 1
        __field register_list 0 +: 14
        __opcode '11101001 00x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 13 == '0'
        __decode
            n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;
            if registers<13> == '1' then UNPREDICTABLE;
            if registers<15> == '1' then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n] - 4*BitCount(registers);
            for i = 0 to 14
                if registers<i> == '1' then
                    if i == n && wback && i != LowestSetBit(registers) then
                        MemA[address,4] = bits(32) UNKNOWN;  // Only possible for encoding A1
                    else
                        MemA[address,4] = R[i];
                    address = address + 4;
            if registers<15> == '1' then  // Only possible for encoding A1
                MemA[address,4] = PCStoreValue();
            if wback then R[n] = R[n] - 4*BitCount(registers);

__instruction aarch32_VCEQ_i_A
    __encoding aarch32_VCEQ_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x01 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCEQ_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x01 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if floating_point then
                        bits(esize) zero = FPZero('0');
                        test_passed = FPCompareEQ(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());
                    else
                        test_passed = (Elem[D[m+r],e,esize] == Zeros(esize));
                    Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_STR_r_A
    __encoding aarch32_STR_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx011x x0x0xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE STRT;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STR_r_T1_A
        __instruction_set T16
        __field Rm 6 +: 3
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '0101000x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_STR_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0100xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if t == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if index then offset_addr else R[n];
            if t == 15 then  // Only possible for encoding A1
                data = PCStoreValue();
            else
                data = R[t];
            MemU[address,4] = data;
            if wback then R[n] = offset_addr;

__instruction aarch32_UXTAB_A
    __encoding aarch32_UXTAB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1110xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE UXTB;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTAB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0101xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE UXTB;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d] = R[n] + ZeroExtend(rotated<7:0>, 32);

__instruction aarch32_LDAEXD_A
    __encoding aarch32_LDAEXD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1011xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  t2 = t + 1;  n = UInt(Rn);
            if Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAEXD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1111xxxx'
        __guard TRUE
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
            if t == 15 || t2 == 15 || t == t2 || n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            AArch32.SetExclusiveMonitors(address, 8);
            value = MemO[address, 8];
            // Extract words from 64-bit loaded value such that R[t] is
            // loaded from address and R[t2] from address+4.
            R[t]  = if BigEndian() then value<63:32> else value<31:0>;
            R[t2] = if BigEndian() then value<31:0>  else value<63:32>;

__instruction aarch32_SADD8_A
    __encoding aarch32_SADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);
            sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);
            sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);
            sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);
            R[d]<7:0>   = sum1<7:0>;
            R[d]<15:8>  = sum2<7:0>;
            R[d]<23:16> = sum3<7:0>;
            R[d]<31:24> = sum4<7:0>;
            PSTATE.GE<0>  = if sum1 >= 0 then '1' else '0';
            PSTATE.GE<1>  = if sum2 >= 0 then '1' else '0';
            PSTATE.GE<2>  = if sum3 >= 0 then '1' else '0';
            PSTATE.GE<3>  = if sum4 >= 0 then '1' else '0';

__instruction aarch32_VMOV_i_A
    __encoding aarch32_VMOV_i_T1A1_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx0xx0 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE VORR (immediate);
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field imm4H 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm4L 0 +: 4
        __opcode 'xxxx1110 1x11xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            single_register = (size != '11'); advsimd = FALSE;
            bits(16) imm16;
            bits(32) imm32;
            bits(64) imm64;
            case size of
                when '01' d = UInt(Vd:D);  imm16 = VFPExpandImm(imm4H:imm4L); imm32 = Zeros(16) : imm16;
                when '10' d = UInt(Vd:D);  imm32 = VFPExpandImm(imm4H:imm4L);
                when '11' d = UInt(D:Vd);  imm64 = VFPExpandImm(imm4H:imm4L);  regs = 1;

    __encoding aarch32_VMOV_i_T3A3_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx10x0 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE VORR (immediate);
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T4A4_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx11xx 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE VORR (immediate);
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T5A5_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx1110 0x11xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE VORR (immediate);
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T1A1_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx0xx0 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE VORR (immediate);
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm4H 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm4L 0 +: 4
        __opcode '11101110 1x11xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            single_register = (size != '11'); advsimd = FALSE;
            bits(16) imm16;
            bits(32) imm32;
            bits(64) imm64;
            case size of
                when '01' d = UInt(Vd:D);  imm16 = VFPExpandImm(imm4H:imm4L); imm32 = Zeros(16) : imm16;
                when '10' d = UInt(Vd:D);  imm32 = VFPExpandImm(imm4H:imm4L);
                when '11' d = UInt(D:Vd);  imm64 = VFPExpandImm(imm4H:imm4L);  regs = 1;

    __encoding aarch32_VMOV_i_T3A3_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx10x0 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE VORR (immediate);
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T4A4_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx11xx 0x01xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE VORR (immediate);
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMOV_i_T5A5_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field op 5 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx1110 0x11xxxx'
        __guard TRUE
        __decode
            if op == '0' && cmode<0> == '1' && cmode<3:2> != '11' then SEE VORR (immediate);
            if op == '1' && cmode != '1110' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if single_register then
                S[d] = imm32;
            else
                for r = 0 to regs-1
                    D[d+r] = imm64;

__instruction aarch32_VST1_m_A
    __encoding aarch32_VST1_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  if align == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 3;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T4A4_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 4;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  if align == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 3;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST1_m_T4A4_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 4;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = TRUE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if ebytes != 8 then
                        MemU[address,ebytes] = Elem[D[d+r],e];
                    else
                        - = AArch32.CheckAlignment(address, ebytes, AccType_NORMAL, iswrite);
                        bits(64) data = Elem[D[d+r],e];
                        MemU[address,4] = if BigEndian() then data<63:32> else data<31:0>;
                        MemU[address+4,4] = if BigEndian() then data<31:0> else data<63:32>;
                    address = address + ebytes;
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 8*regs;

__instruction aarch32_VRADDHN_A
    __encoding aarch32_VRADDHN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1xxxxxxx xxxx0100 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VRADDHN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1xxxxxxx xxxx0100 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            round_const = 1 << (esize-1);
            for e = 0 to elements-1
                result = Elem[Qin[n>>1],e,2*esize] + Elem[Qin[m>>1],e,2*esize] + round_const;
                Elem[D[d],e,esize] = result<2*esize-1:esize>;

__instruction aarch32_VRECPS_A
    __encoding aarch32_VRECPS_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRECPS_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = FPRecipStep(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize]);

__instruction aarch32_VSUBHN_A
    __encoding aarch32_VSUBHN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx0110 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VSUBHN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx0110 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                result = Elem[Qin[n>>1],e,2*esize] - Elem[Qin[m>>1],e,2*esize];
                Elem[D[d],e,esize] = result<2*esize-1:esize>;

__instruction aarch32_UXTAH_A
    __encoding aarch32_UXTAH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1111xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE UXTH;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTAH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0001xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE UXTH;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d] = R[n] + ZeroExtend(rotated<15:0>, 32);

__instruction aarch32_SRS_AS
    __encoding aarch32_SRS_A1_AS
        __instruction_set A32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field mode 0 +: 5
        __opcode '1111100x x1x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            wback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);

    __encoding aarch32_SRS_T1_AS
        __instruction_set T32
        __field W 21 +: 1
        __field mode 0 +: 5
        __opcode '11101000 00x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            wback = (W == '1');  increment = FALSE;  wordhigher = FALSE;

    __encoding aarch32_SRS_T2_AS
        __instruction_set T32
        __field W 21 +: 1
        __field mode 0 +: 5
        __opcode '11101001 10x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            wback = (W == '1');  increment = TRUE;  wordhigher = FALSE;

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if ConditionPassed() then
                EncodingSpecificOperations();
                if PSTATE.EL == EL2 then          // UNDEFINED at EL2
                    UNDEFINED;
            
                // Check for UNPREDICTABLE cases. The definition of UNPREDICTABLE does not permit these
                // to be security holes
                if PSTATE.M IN {M32_User,M32_System} then
                    UNPREDICTABLE;
                elsif mode == M32_Hyp then        // Check for attempt to access Hyp mode SP
                    UNPREDICTABLE;
                elsif mode == M32_Monitor then    // Check for attempt to access Monitor mode SP
                    if !HaveEL(EL3) || !IsSecure()  then
                        UNPREDICTABLE;
                    elsif !ELUsingAArch32(EL3) then
                        AArch64.MonitorModeTrap();
                elsif BadMode(mode) then
                    UNPREDICTABLE;
            
                base = Rmode[13,mode];
                address = if increment then base else base-8;
                if wordhigher then address = address+4;
                MemA[address,4]   = LR;
                MemA[address+4,4] = SPSR[];
                if wback then Rmode[13,mode] = if increment then base+8 else base-8;
        else
            if ConditionPassed() then
                EncodingSpecificOperations();
                if PSTATE.EL == EL2 then          // UNDEFINED at EL2
                    UNDEFINED;
            
                // Check for UNPREDICTABLE cases. The definition of UNPREDICTABLE does not permit these
                // to be security holes
                if PSTATE.M IN {M32_User,M32_System} then
                    UNPREDICTABLE;
                elsif mode == M32_Hyp then        // Check for attempt to access Hyp mode SP
                    UNPREDICTABLE;
                elsif mode == M32_Monitor then    // Check for attempt to access Monitor mode SP
                    if !HaveEL(EL3) || !IsSecure()  then
                        UNPREDICTABLE;
                    elsif !ELUsingAArch32(EL3) then
                        AArch64.MonitorModeTrap();
                elsif BadMode(mode) then
                    UNPREDICTABLE;
            
                base = Rmode[13,mode];
                address = if increment then base else base-8;
                if wordhigher then address = address+4;
                MemA[address,4]   = LR;
                MemA[address+4,4] = SPSR[];
                if wback then Rmode[13,mode] = if increment then base+8 else base-8;

__instruction aarch32_QADD16_A
    __encoding aarch32_QADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);
            sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);
            R[d]<15:0>  = SignedSat(sum1, 16);
            R[d]<31:16> = SignedSat(sum2, 16);

__instruction aarch32_VCVTB_A
    __encoding aarch32_VCVTB_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field op 16 +: 1
        __field Vd 12 +: 4
        __field sz 8 +: 1
        __field T 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x11001x xxxx101x 11x0xxxx'
        __guard cond != '1111'
        __decode
            uses_double = (sz == '1'); convert_from_half = (op == '0');
            lowbit = (if T == '1' then 16 else 0);
            if uses_double then
                if convert_from_half then
                    d = UInt(D:Vd); m = UInt(Vm:M);
                else
                    d = UInt(Vd:D); m = UInt(M:Vm);
            else
                d = UInt(Vd:D); m = UInt(Vm:M);

    __encoding aarch32_VCVTB_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 16 +: 1
        __field Vd 12 +: 4
        __field sz 8 +: 1
        __field T 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x11001x xxxx101x 11x0xxxx'
        __guard TRUE
        __decode
            uses_double = (sz == '1'); convert_from_half = (op == '0');
            lowbit = (if T == '1' then 16 else 0);
            if uses_double then
                if convert_from_half then
                    d = UInt(D:Vd); m = UInt(Vm:M);
                else
                    d = UInt(Vd:D); m = UInt(M:Vm);
            else
                d = UInt(Vd:D); m = UInt(Vm:M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
            bits(16) hp;
            if convert_from_half then
                hp = S[m]<lowbit+15:lowbit>;
                if uses_double then
                    D[d] = FPConvert(hp, FPSCR);
                else
                    S[d] = FPConvert(hp, FPSCR);
            else
                if uses_double then
                    hp = FPConvert(D[m], FPSCR);
                else
                    hp = FPConvert(S[m], FPSCR);
                S[d]<lowbit+15:lowbit> = hp;

__instruction aarch32_SXTAB16_A
    __encoding aarch32_SXTAB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1000xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE SXTB16;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTAB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0010xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE SXTB16;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d]<15:0>  = R[n]<15:0> + SignExtend(rotated<7:0>, 16);
            R[d]<31:16> = R[n]<31:16> + SignExtend(rotated<23:16>, 16);

__instruction aarch32_VMOV_d_A
    __encoding aarch32_VMOV_d_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field op 20 +: 1
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1100 010xxxxx xxxx1011 00x1xxxx'
        __guard cond != '1111'
        __decode
            to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(M:Vm);
            if t == 15 || t2 == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13
            if to_arm_registers && t == t2 then UNPREDICTABLE;

    __encoding aarch32_VMOV_d_T1A1_A
        __instruction_set T32
        __field op 20 +: 1
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101100 010xxxxx xxxx1011 00x1xxxx'
        __guard TRUE
        __decode
            to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(M:Vm);
            if t == 15 || t2 == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13
            if to_arm_registers && t == t2 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            if to_arm_registers then
                R[t] = D[m]<31:0>;
                R[t2] = D[m]<63:32>;
            else
                D[m]<31:0> = R[t];
                D[m]<63:32> = R[t2];

__instruction aarch32_ORN_r_A
    __encoding aarch32_ORN_r_T1_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 011xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rn == '1111' then SEE MVN (register);
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] OR NOT(shifted);
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_VLD4_a_A
    __encoding aarch32_VLD4_a_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' && a == '0' then UNDEFINED;
            if size == '11' then
                ebytes = 4;  alignment = 16;
            else
                ebytes = 1 << UInt(size);
                if size == '10' then
                    alignment = if a == '0' then 1 else 8;
                else
                    alignment = if a == '0' then 1 else 4*ebytes;
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_a_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' && a == '0' then UNDEFINED;
            if size == '11' then
                ebytes = 4;  alignment = 16;
            else
                ebytes = 1 << UInt(size);
                if size == '10' then
                    alignment = if a == '0' then 1 else 8;
                else
                    alignment = if a == '0' then 1 else 4*ebytes;
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = FALSE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            D[d] = Replicate(MemU[address,ebytes]);
            D[d2] = Replicate(MemU[address+ebytes,ebytes]);
            D[d3] = Replicate(MemU[address+2*ebytes,ebytes]);
            D[d4] = Replicate(MemU[address+3*ebytes,ebytes]);
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 4*ebytes;

__instruction aarch32_LDAEXH_A
    __encoding aarch32_LDAEXH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1111xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAEXH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1101xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            AArch32.SetExclusiveMonitors(address, 2);
            R[t] = ZeroExtend(MemO[address, 2], 32);

__instruction aarch32_TEQ_i_A
    __encoding aarch32_TEQ_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0011xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_TEQ_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm8 0 +: 8
        __opcode '11110x00 1001xxxx 0xxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = R[n] EOR imm32;
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_VRSHRN_A
    __encoding aarch32_VRSHRN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1000 01x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VRSHRN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1000 01x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            round_const = 1 << (shift_amount-1);
            for e = 0 to elements-1
                result = LSR(Elem[Qin[m>>1],e,2*esize] + round_const, shift_amount);
                Elem[D[d],e,esize] = result<esize-1:0>;

__instruction aarch32_VCVTA_asimd_A
    __encoding aarch32_VCVTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx0011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field RM 8 +: 2
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx0011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckAdvSIMDEnabled();
        bits(esize) result;
        for r = 0 to regs-1
            for e = 0 to elements-1
                Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,
                                                 StandardFPSCRValue(), rounding);

__instruction aarch32_VSLI_A
    __encoding aarch32_VSLI_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSLI_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            mask = LSL(Ones(esize), shift_amount);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    shifted_op = LSL(Elem[D[m+r],e,esize], shift_amount);
                    Elem[D[d+r],e,esize] = (Elem[D[d+r],e,esize] AND NOT(mask)) OR shifted_op;

__instruction aarch32_VMLA_s_A
    __encoding aarch32_VMLA_s_A1_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx000x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            add = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMLA_s_T1_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx000x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            add = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                    if floating_point then
                        fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));
                        Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());
                    else
                        addend = if add then op1val*op2val else -op1val*op2val;
                        if long_destination then
                            Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                        else
                            Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_VST3_1_A
    __encoding aarch32_VST3_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1:0> != '00' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1:0> != '00' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];
            MemU[address,         ebytes] = Elem[D[d], index];
            MemU[address+ebytes,  ebytes] = Elem[D[d2],index];
            MemU[address+2*ebytes,ebytes] = Elem[D[d3],index];
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 3*ebytes;

__instruction aarch32_VNMLA_A
    __encoding aarch32_VNMLA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x01xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            type1 = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VNMLA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x01xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            type1 = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL};
        
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            case esize of
                when 16
                    product16 = FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);
                    case type1 of
                        when VFPNegMul_VNMLA  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), FPNeg(product16), FPSCR);
                        when VFPNegMul_VNMLS  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), product16, FPSCR);
                        when VFPNegMul_VNMUL  S[d] = Zeros(16) : FPNeg(product16);
                when 32
                    product32 = FPMul(S[n], S[m], FPSCR);
                    case type1 of
                        when VFPNegMul_VNMLA  S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), FPSCR);
                        when VFPNegMul_VNMLS  S[d] = FPAdd(FPNeg(S[d]), product32, FPSCR);
                        when VFPNegMul_VNMUL  S[d] = FPNeg(product32);
                when 64
                    product64 = FPMul(D[n], D[m], FPSCR);
                    case type1 of
                        when VFPNegMul_VNMLA  D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), FPSCR);
                        when VFPNegMul_VNMLS  D[d] = FPAdd(FPNeg(D[d]), product64, FPSCR);
                        when VFPNegMul_VNMUL  D[d] = FPNeg(product64);

__instruction aarch32_QADD8_A
    __encoding aarch32_QADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);
            sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);
            sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);
            sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);
            R[d]<7:0>   = SignedSat(sum1, 8);
            R[d]<15:8>  = SignedSat(sum2, 8);
            R[d]<23:16> = SignedSat(sum3, 8);
            R[d]<31:24> = SignedSat(sum4, 8);

__instruction aarch32_VBIC_i_A
    __encoding aarch32_VBIC_i_T1A1_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx0xx1 0x11xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIC_i_T2A2_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx10x1 0x11xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIC_i_T1A1_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx0xx1 0x11xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIC_i_T2A2_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx10x1 0x11xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                D[d+r] = D[d+r] AND NOT(imm64);

__instruction aarch32_SHA1P_A
    __encoding aarch32_SHA1P_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x01xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA1P_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x01xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            X = Q[d>>1];
            Y = Q[n>>1]<31:0>; // Note: 32 bits wide
            W = Q[m>>1];
            for e = 0 to 3
                t = SHAparity(X<63:32>, X<95:64>, X<127:96>);
                Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
                X<63:32> = ROL(X<63:32>, 30);
                <Y, X> = ROL(Y:X, 32);
            Q[d>>1] = X;

__instruction aarch32_VORR_i_A
    __encoding aarch32_VORR_i_T1A1_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx0xx1 0x01xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE VMOV (immediate);
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VORR_i_T2A2_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx10x1 0x01xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE VMOV (immediate);
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VORR_i_T1A1_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx0xx1 0x01xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE VMOV (immediate);
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VORR_i_T2A2_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx10x1 0x01xxxx'
        __guard TRUE
        __decode
            if cmode<0> == '0' || cmode<3:2> == '11' then SEE VMOV (immediate);
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                D[d+r] = D[d+r] OR imm64;

__instruction aarch32_UADD8_A
    __encoding aarch32_UADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m  == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);
            sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);
            sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);
            sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);
            R[d]<7:0>   = sum1<7:0>;
            R[d]<15:8>  = sum2<7:0>;
            R[d]<23:16> = sum3<7:0>;
            R[d]<31:24> = sum4<7:0>;
            PSTATE.GE<0>  = if sum1 >= 0x100 then '1' else '0';
            PSTATE.GE<1>  = if sum2 >= 0x100 then '1' else '0';
            PSTATE.GE<2>  = if sum3 >= 0x100 then '1' else '0';
            PSTATE.GE<3>  = if sum4 >= 0x100 then '1' else '0';

__instruction aarch32_LDRSH_r_A
    __encoding aarch32_LDRSH_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x1xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if P == '0' && W == '1' then SEE LDRSHT;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = (SRType_LSL, 0);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRSH_r_T1_A
        __instruction_set T16
        __field Rm 6 +: 3
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '0101111x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_LDRSH_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0011xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDRSH (literal);
            if Rt == '1111' then SEE "Related instructions";
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if index then offset_addr else R[n];
            data = MemU[address,2];
            if wback then R[n] = offset_addr;
            R[t] = SignExtend(data, 32);

__instruction aarch32_VSRA_A
    __encoding aarch32_VSRA_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSRA_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    result = Int(Elem[D[m+r],e,esize], unsigned) >> shift_amount;
                    Elem[D[d+r],e,esize] = Elem[D[d+r],e,esize] + result;

__instruction aarch32_VFNMA_A
    __encoding aarch32_VFNMA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x01xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VFNMA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x01xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
            case esize of
                when 16
                    op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;
                    S[d] = Zeros(16) : FPMulAdd(FPNeg(S[d]<15:0>), op16, S[m]<15:0>, FPSCR);
                when 32
                    op32 = if op1_neg then FPNeg(S[n]) else S[n];
                    S[d] = FPMulAdd(FPNeg(S[d]), op32, S[m], FPSCR);
                when 64
                    op64 = if op1_neg then FPNeg(D[n]) else D[n];
                    D[d] = FPMulAdd(FPNeg(D[d]), op64, D[m], FPSCR);

__instruction aarch32_VST1_1_A
    __encoding aarch32_VST1_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  alignment = 1;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VST1_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VST1_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx1000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<2> != '0' then UNDEFINED;
            if index_align<1:0> != '00' && index_align<1:0> != '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            alignment = if index_align<1:0> == '00' then 1 else 4;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VST1_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  alignment = 1;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VST1_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VST1_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx1000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<2> != '0' then UNDEFINED;
            if index_align<1:0> != '00' && index_align<1:0> != '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            alignment = if index_align<1:0> == '00' then 1 else 4;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = TRUE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            MemU[address,ebytes] = Elem[D[d],index];
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + ebytes;

__instruction aarch32_QDSUB_A
    __encoding aarch32_QDSUB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0110xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QDSUB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 1011xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);
            (R[d], sat2)  = SignedSatQ(SInt(R[m]) - SInt(doubled), 32);
            if sat1 || sat2 then
                PSTATE.Q = '1';

__instruction aarch32_UHADD8_A
    __encoding aarch32_UHADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);
            sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);
            sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);
            sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);
            R[d]<7:0>   = sum1<8:1>;
            R[d]<15:8>  = sum2<8:1>;
            R[d]<23:16> = sum3<8:1>;
            R[d]<31:24> = sum4<8:1>;

__instruction aarch32_VLDM_A
    __encoding aarch32_VLDM_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx1xxxx xxxx1011 xxxxxxx0'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VLDR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FLDM*X".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VLDM_T2A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx1xxxx xxxx1010 xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VLDR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = TRUE;  add = (U == '1');  wback = (W == '1');  d = UInt(Vd:D);  n = UInt(Rn);
            imm32 = ZeroExtend(imm8:'00', 32);  regs = UInt(imm8);
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;

    __encoding aarch32_VLDM_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx1xxxx xxxx1011 xxxxxxx0'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VLDR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FLDM*X".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VLDM_T2A2_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx1xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VLDR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = TRUE;  add = (U == '1');  wback = (W == '1');  d = UInt(Vd:D);  n = UInt(Rn);
            imm32 = ZeroExtend(imm8:'00', 32);  regs = UInt(imm8);
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            address = if add then R[n] else R[n]-imm32;
            for r = 0 to regs-1
                if single_regs then
                    S[d+r] = MemA[address,4];  address = address+4;
                else
                    word1 = MemA[address,4];  word2 = MemA[address+4,4];  address = address+8;
                    // Combine the word-aligned words in the correct order for current endianness.
                    D[d+r] = if BigEndian() then word1:word2 else word2:word1;
            if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;

__instruction aarch32_SMUSD_A
    __encoding aarch32_SMUSD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0000xxxx 1111xxxx 01x1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMUSD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0100xxxx 1111xxxx 000xxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand2 = if m_swap then ROR(R[m],16) else R[m];
            product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
            product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
            result = product1 - product2;
            R[d] = result<31:0>;
            // Signed overflow cannot occur

__instruction aarch32_ISB_A
    __encoding aarch32_ISB_A1_A
        __instruction_set A32
        __field option 0 +: 4
        __opcode '11110101 0111xxxx xxxxxxxx 0110xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_ISB_T1_A
        __instruction_set T32
        __field option 0 +: 4
        __opcode '11110011 1011xxxx 10x0xxxx 0110xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            // No additional decoding required

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            InstructionSynchronizationBarrier();

__instruction aarch32_VSWP_A
    __encoding aarch32_VSWP_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x110010 xxxx0000 0xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSWP_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x110010 xxxx0000 0xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                if d == m then
                    D[d+r] = bits(64) UNKNOWN;
                else
                    D[d+r] = Din[m+r];
                    D[m+r] = Din[d+r];

__instruction aarch32_LDRH_i_A
    __encoding aarch32_LDRH_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x1xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE LDRH (literal);
            if P == '0' && W == '1' then SEE LDRHT;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRH_i_T1_A
        __instruction_set T16
        __field imm5 6 +: 5
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '10001xxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'0', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_LDRH_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1011xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE PLD (immediate);
            if Rn == '1111' then SEE LDRH (literal);
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_LDRH_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0011xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDRH (literal);
            if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE PLDW (immediate);
            if P == '1' && U == '1' && W == '0' then SEE LDRHT;
            if P == '0' && W == '0' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                data = MemU[address,2];
                if wback then R[n] = offset_addr;
                R[t] = ZeroExtend(data, 32);
        else
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                data = MemU[address,2];
                if wback then R[n] = offset_addr;
                R[t] = ZeroExtend(data, 32);

__instruction aarch32_VCLE_i_A
    __encoding aarch32_VCLE_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x01 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCLE_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x01 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if floating_point then
                        bits(esize) zero = FPZero('0');
                        test_passed = FPCompareGE(zero, Elem[D[m+r],e,esize], StandardFPSCRValue());
                    else
                        test_passed = (SInt(Elem[D[m+r],e,esize]) <= 0);
                    Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_UDF_A
    __encoding aarch32_UDF_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm12 8 +: 12
        __field imm4 0 +: 4
        __opcode '11100111 1111xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __decode
            imm32 = ZeroExtend(imm12:imm4, 32);
            // imm32 is for assembly and disassembly only, and is ignored by hardware.

    __encoding aarch32_UDF_T1_A
        __instruction_set T16
        __field imm8 0 +: 8
        __opcode '11011110 xxxxxxxx'
        __guard TRUE
        __decode
            imm32 = ZeroExtend(imm8, 32);
            // imm32 is for assembly and disassembly only, and is ignored by hardware.

    __encoding aarch32_UDF_T2_A
        __instruction_set T32
        __field imm4 16 +: 4
        __field imm12 0 +: 12
        __opcode '11110111 1111xxxx 1010xxxx xxxxxxxx'
        __guard TRUE
        __decode
            imm32 = ZeroExtend(imm4:imm12, 32);
            // imm32 is for assembly and disassembly only, and is ignored by hardware.

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            UNDEFINED;

__instruction aarch32_VMLA_s_A
    __encoding aarch32_VMLA_s_A1_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx010x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            add = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMLA_s_T1_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx010x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            add = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                    if floating_point then
                        fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));
                        Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());
                    else
                        addend = if add then op1val*op2val else -op1val*op2val;
                        if long_destination then
                            Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                        else
                            Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_VABD_i_A
    __encoding aarch32_VABD_i_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0111 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __encoding aarch32_VABD_i_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0111 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  long_destination = TRUE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];
                    op2 = Elem[Din[m+r],e,esize];
                    absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = absdiff<2*esize-1:0>;
                    else
                        Elem[D[d+r],e,esize] = absdiff<esize-1:0>;

__instruction aarch32_VRECPE_A
    __encoding aarch32_VRECPE_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx010x 0xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            floating_point = (F == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRECPE_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx010x 0xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            floating_point = (F == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if floating_point then
                        Elem[D[d+r],e,esize] = FPRecipEstimate(Elem[D[m+r],e,esize], StandardFPSCRValue());
                    else
                        Elem[D[d+r],e,esize] = UnsignedRecipEstimate(Elem[D[m+r],e,esize]);

__instruction aarch32_VBIC_r_A
    __encoding aarch32_VBIC_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x01xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIC_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x01xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                D[d+r] = D[n+r] AND NOT(D[m+r]);

__instruction aarch32_VBIF_A
    __encoding aarch32_VBIF_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x11xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE VEOR;
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIF_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x11xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE VEOR;
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL};
        
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                case operation of
                    when VBitOps_VBIF  D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));
                    when VBitOps_VBIT  D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));
                    when VBitOps_VBSL  D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));

__instruction aarch32_VSHRN_A
    __encoding aarch32_VSHRN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1000 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VSHRN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1000 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                result = LSR(Elem[Qin[m>>1],e,2*esize], shift_amount);
                Elem[D[d],e,esize] = result<esize-1:0>;

__instruction aarch32_UADD16_A
    __encoding aarch32_UADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);
            sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);
            R[d]<15:0>  = sum1<15:0>;
            R[d]<31:16> = sum2<15:0>;
            PSTATE.GE<1:0> = if sum1 >= 0x10000 then '11' else '00';
            PSTATE.GE<3:2> = if sum2 >= 0x10000 then '11' else '00';

__instruction aarch32_STR_i_A
    __encoding aarch32_STR_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x0x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE STRT;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STR_i_T1_A
        __instruction_set T16
        __field imm5 6 +: 5
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '01100xxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'00', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_STR_i_T2_A
        __instruction_set T16
        __field Rt 8 +: 3
        __field imm8 0 +: 8
        __opcode '10010xxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = 13;  imm32 = ZeroExtend(imm8:'00', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_STR_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1100xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            if t == 15 then UNPREDICTABLE;

    __encoding aarch32_STR_i_T4_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0100xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '1' && U == '1' && W == '0' then SEE STRT;
            if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE;

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                MemU[address,4] = if t == 15 then PCStoreValue() else R[t];
                if wback then R[n] = offset_addr;
        else
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                MemU[address,4] = R[t];
                if wback then R[n] = offset_addr;

__instruction aarch32_LDC_l_A
    __encoding aarch32_LDC_l_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field imm8 0 +: 8
        __opcode 'xxxx110x x0x11111 01011110 xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            index = (P == '1');  add = (U == '1');  cp = 14;  imm32 = ZeroExtend(imm8:'00', 32);
            if W == '1' || (P == '0' && CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;

    __encoding aarch32_LDC_l_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field imm8 0 +: 8
        __opcode '1110110x x0x11111 01011110 xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            index = (P == '1');  add = (U == '1');  cp = 14;  imm32 = ZeroExtend(imm8:'00', 32);
            if W == '1' || (P == '0' && CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            AArch32.CheckSystemAccess(cp, ThisInstr());
            offset_addr = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
            address = if index then offset_addr else Align(PC,4);
        
            // System register write to DBGDTRTXint.
            DBGDTR_EL0[] = MemA[address,4];

__instruction aarch32_VRSHL_A
    __encoding aarch32_VRSHL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRSHL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    shift = SInt(Elem[D[n+r],e,esize]<7:0>);
                    round_const = 1 << (-shift-1); // 0 for left shift, 2^(n-1) for right shift
                    result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) << shift;
                    Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_USAT16_A
    __encoding aarch32_USAT16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sat_imm 16 +: 4
        __field Rd 12 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0110 1110xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_USAT16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field sat_imm 0 +: 4
        __opcode '11110x11 1010xxxx 0000xxxx 00xxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
            if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result1, sat1) = UnsignedSatQ(SInt(R[n]<15:0>), saturate_to);
            (result2, sat2) = UnsignedSatQ(SInt(R[n]<31:16>), saturate_to);
            R[d]<15:0> = ZeroExtend(result1, 16);
            R[d]<31:16> = ZeroExtend(result2, 16);
            if sat1 || sat2 then
                PSTATE.Q = '1';

__instruction aarch32_LDRB_r_A
    __encoding aarch32_LDRB_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx011x x1x1xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE LDRBT;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRB_r_T1_A
        __instruction_set T16
        __field Rm 6 +: 3
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '0101110x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_LDRB_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0001xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE PLD;
            if Rn == '1111' then SEE LDRB (literal);
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if index then offset_addr else R[n];
            R[t] = ZeroExtend(MemU[address,1],32);
            if wback then R[n] = offset_addr;

__instruction aarch32_MOV_i_A
    __encoding aarch32_MOV_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 101xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  setflags = (S == '1');  (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_MOV_i_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm4 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0000xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(imm4:imm12, 32);
            if d == 15 then UNPREDICTABLE;

    __encoding aarch32_MOV_i_T1_A
        __instruction_set T16
        __field Rd 8 +: 3
        __field imm8 0 +: 8
        __opcode '00100xxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = !InITBlock();  imm32 = ZeroExtend(imm8, 32);  carry = PSTATE.C;

    __encoding aarch32_MOV_i_T2_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 010x1111 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = (S == '1');  (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_MOV_i_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm4 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 0100xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(imm4:i:imm3:imm8, 32);
            if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = imm32;
            if d == 15 then          // Can only occur for encoding A1
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_VSUB_i_A
    __encoding aarch32_VSUB_i_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSUB_i_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1000 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = Elem[D[n+r],e,esize] - Elem[D[m+r],e,esize];

__instruction aarch32_SHADD16_A
    __encoding aarch32_SHADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);
            sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);
            R[d]<15:0>  = sum1<16:1>;
            R[d]<31:16> = sum2<16:1>;

__instruction aarch32_UMULL_A
    __encoding aarch32_UMULL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 100xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_UMULL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1010xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = UInt(R[n]) * UInt(R[m]);
            R[dHi] = result<63:32>;
            R[dLo] = result<31:0>;
            if setflags then
                PSTATE.N = result<63>;
                PSTATE.Z = IsZeroBit(result<63:0>);
                // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_VMOV_ss_A
    __encoding aarch32_VMOV_ss_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field op 20 +: 1
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1100 010xxxxx xxxx1010 00x1xxxx'
        __guard cond != '1111'
        __decode
            to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(Vm:M);
            if t == 15 || t2 == 15 || m == 31 then UNPREDICTABLE;
            if to_arm_registers && t == t2 then UNPREDICTABLE;

    __encoding aarch32_VMOV_ss_T1A1_A
        __instruction_set T32
        __field op 20 +: 1
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101100 010xxxxx xxxx1010 00x1xxxx'
        __guard TRUE
        __decode
            to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(Vm:M);
            if t == 15 || t2 == 15 || m == 31 then UNPREDICTABLE;
            if to_arm_registers && t == t2 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            if to_arm_registers then
                R[t] = S[m];
                R[t2] = S[m+1];
            else
                S[m] = R[t];
                S[m+1] = R[t2];

__instruction aarch32_HLT_A
    __encoding aarch32_HLT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm12 8 +: 12
        __field imm4 0 +: 4
        __opcode 'xxxx0001 0000xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __decode
            if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;
            if cond != '1110' then UNPREDICTABLE; // HLT must be encoded with AL condition

    __encoding aarch32_HLT_T1_A
        __instruction_set T16
        __field imm6 0 +: 6
        __opcode '10111010 10xxxxxx'
        __guard TRUE
        __decode
            if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;

    __execute
        EncodingSpecificOperations();
        Halt(DebugHalt_HaltInstruction);

__instruction aarch32_LDAEX_A
    __encoding aarch32_LDAEX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1001xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAEX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1110xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            AArch32.SetExclusiveMonitors(address, 4);
            R[t] = MemO[address, 4];

__instruction aarch32_VRINTA_asimd_A
    __encoding aarch32_VRINTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0111 1xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0111 1xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_LDRB_i_A
    __encoding aarch32_LDRB_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x1x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE LDRB (literal);
            if P == '0' && W == '1' then SEE LDRBT;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRB_i_T1_A
        __instruction_set T16
        __field imm5 6 +: 5
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '01111xxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_LDRB_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1001xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE PLD;
            if Rn == '1111' then SEE LDRB (literal);
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_LDRB_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0001xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE PLD, PLDW (immediate);
            if Rn == '1111' then SEE LDRB (literal);
            if P == '1' && U == '1' && W == '0' then SEE LDRBT;
            if P == '0' && W == '0' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if  (t == 15 &&  W == '1') || (wback && n == t) then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                R[t] = ZeroExtend(MemU[address,1], 32);
                if wback then R[n] = offset_addr;
        else
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                R[t] = ZeroExtend(MemU[address,1], 32);
                if wback then R[n] = offset_addr;

__instruction aarch32_SEV_A
    __encoding aarch32_SEV_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000100'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_SEV_T1_A
        __instruction_set T16
        __opcode '10111111 01000000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_SEV_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000100'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            SendEvent();

__instruction aarch32_LDRHT_A
    __encoding aarch32_LDRHT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx0000 x111xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_LDRHT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0000 x011xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRHT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0011xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDRH (literal);
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            EncodingSpecificOperations();
            offset = if register_form then R[m] else imm32;
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if postindex then R[n] else offset_addr;
            data = MemU_unpriv[address,2];
            if postindex then R[n] = offset_addr;
            R[t] = ZeroExtend(data, 32);

__instruction aarch32_STMDA_A
    __encoding aarch32_STMDA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1000 00x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n] - 4*BitCount(registers) + 4;
            for i = 0 to 14
                if registers<i> == '1' then
                    if i == n && wback && i != LowestSetBit(registers) then
                        MemA[address,4] = bits(32) UNKNOWN;
                    else
                        MemA[address,4] = R[i];
                    address = address + 4;
            if registers<15> == '1' then
                MemA[address,4] = PCStoreValue();
            if wback then R[n] = R[n] - 4*BitCount(registers);

__instruction aarch32_STLEXD_A
    __encoding aarch32_STLEXD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1010xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);
            if d == 15 || Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t || d == t2 then UNPREDICTABLE;

    __encoding aarch32_STLEXD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1111xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
            if d == 15 || t == 15 || t2 == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t || d == t2 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            // Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.
            value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];
            if AArch32.ExclusiveMonitorsPass(address, 8) then
                MemO[address, 8] = value;
                R[d] = ZeroExtend('0');
            else
                R[d] = ZeroExtend('1');

__instruction aarch32_VMVN_r_A
    __encoding aarch32_VMVN_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0101 1xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0101 1xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                D[d+r] = NOT(D[m+r]);

__instruction aarch32_SMULWB_A
    __encoding aarch32_SMULWB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field M 6 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 1x10xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMULWB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0011xxxx 1111xxxx 000xxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
            product = SInt(R[n]) * SInt(operand2);
            R[d] = product<47:16>;
            // Signed overflow cannot occur

__instruction aarch32_STRB_i_A
    __encoding aarch32_STRB_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x1x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE STRBT;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STRB_i_T1_A
        __instruction_set T16
        __field imm5 6 +: 5
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '01110xxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_STRB_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1000xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_STRB_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0000xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '1' && U == '1' && W == '0' then SEE STRBT;
            if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                MemU[address,1] = R[t]<7:0>;
                if wback then R[n] = offset_addr;
        else
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                MemU[address,1] = R[t]<7:0>;
                if wback then R[n] = offset_addr;

__instruction aarch32_CLREX_A
    __encoding aarch32_CLREX_A1_A
        __instruction_set A32
        __opcode '11110101 0111xxxx xxxxxxxx 0001xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            // No additional decoding required

    __encoding aarch32_CLREX_T1_A
        __instruction_set T32
        __opcode '11110011 1011xxxx 10x0xxxx 0010xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            // No additional decoding required

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            ClearExclusiveLocal(ProcessorID());

__instruction aarch32_VMOV_h_A
    __encoding aarch32_VMOV_h_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field op 20 +: 1
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __opcode 'xxxx1110 000xxxxx xxxx1001 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            if cond != '1110' then UNPREDICTABLE;
            to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMOV_h_T1_A
        __instruction_set T32
        __field op 20 +: 1
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __opcode '11101110 000xxxxx xxxx1001 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            if to_arm_register then
                R[t] = Zeros(16) : S[n]<15:0>;
            else
                S[n] = Zeros(16) : R[t]<15:0>;

__instruction aarch32_DCPS_A
    __encoding aarch32_DCPS_T1_A
        __instruction_set T32
        __field opt 0 +: 2
        __opcode '11110111 10001111 10000000 000000xx'
        __guard TRUE
        __decode
            if !Halted() || opt == '00' then UNDEFINED;

    __execute
        DCPSInstruction(opt);

__instruction aarch32_SXTAH_A
    __encoding aarch32_SXTAH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1011xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE SXTH;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTAH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0000xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE SXTH;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d] = R[n] + SignExtend(rotated<15:0>, 32);

__instruction aarch32_VNMLA_A
    __encoding aarch32_VNMLA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x01xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            type1 = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VNMLA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x01xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            type1 = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL};
        
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            case esize of
                when 16
                    product16 = FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);
                    case type1 of
                        when VFPNegMul_VNMLA  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), FPNeg(product16), FPSCR);
                        when VFPNegMul_VNMLS  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), product16, FPSCR);
                        when VFPNegMul_VNMUL  S[d] = Zeros(16) : FPNeg(product16);
                when 32
                    product32 = FPMul(S[n], S[m], FPSCR);
                    case type1 of
                        when VFPNegMul_VNMLA  S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), FPSCR);
                        when VFPNegMul_VNMLS  S[d] = FPAdd(FPNeg(S[d]), product32, FPSCR);
                        when VFPNegMul_VNMUL  S[d] = FPNeg(product32);
                when 64
                    product64 = FPMul(D[n], D[m], FPSCR);
                    case type1 of
                        when VFPNegMul_VNMLA  D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), FPSCR);
                        when VFPNegMul_VNMLS  D[d] = FPAdd(FPNeg(D[d]), product64, FPSCR);
                        when VFPNegMul_VNMUL  D[d] = FPNeg(product64);

__instruction aarch32_VRHADD_A
    __encoding aarch32_VRHADD_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0001 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRHADD_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0001 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Int(Elem[D[n+r],e,esize], unsigned);
                    op2 = Int(Elem[D[m+r],e,esize], unsigned);
                    result = op1 + op2 + 1;
                    Elem[D[d+r],e,esize] = result<esize:1>;

__instruction aarch32_VSHL_r_A
    __encoding aarch32_VSHL_r_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0100 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSHL_r_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0100 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    shift = SInt(Elem[D[n+r],e,esize]<7:0>);
                    result = Int(Elem[D[m+r],e,esize], unsigned) << shift;
                    Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_VORR_r_A
    __encoding aarch32_VORR_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x10xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VORR_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x10xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                D[d+r] = D[n+r] OR D[m+r];

__instruction aarch32_MVN_rr_A
    __encoding aarch32_MVN_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 111xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = NOT(shifted);
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_VCGE_i_A
    __encoding aarch32_VCGE_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x00 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGE_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x00 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if floating_point then
                        bits(esize) zero = FPZero('0');
                        test_passed = FPCompareGE(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());
                    else
                        test_passed = (SInt(Elem[D[m+r],e,esize]) >= 0);
                    Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_VACGE_A
    __encoding aarch32_VACGE_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            or_equal = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VACGE_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            or_equal = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = FPAbs(Elem[D[n+r],e,esize]);  op2 = FPAbs(Elem[D[m+r],e,esize]);
                    if or_equal then
                        test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());
                    else
                        test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());
                    Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_USAD8_A
    __encoding aarch32_USAD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0111 1000xxxx 1111xxxx 0001xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_USAD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 0111xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            absdiff1 = Abs(UInt(R[n]<7:0>)   - UInt(R[m]<7:0>));
            absdiff2 = Abs(UInt(R[n]<15:8>)  - UInt(R[m]<15:8>));
            absdiff3 = Abs(UInt(R[n]<23:16>) - UInt(R[m]<23:16>));
            absdiff4 = Abs(UInt(R[n]<31:24>) - UInt(R[m]<31:24>));
            result = absdiff1 + absdiff2 + absdiff3 + absdiff4;
            R[d] = result<31:0>;

__instruction aarch32_VMSR_AS
    __encoding aarch32_VMSR_T1A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field reg 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx1110 1110xxxx xxxx1010 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            t = UInt(Rt);
            if reg != '000x' && reg != '1000' then UNPREDICTABLE;
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMSR_T1A1_AS
        __instruction_set T32
        __field reg 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101110 1110xxxx xxxx1010 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            t = UInt(Rt);
            if reg != '000x' && reg != '1000' then UNPREDICTABLE;
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if reg == '0001' then                 // FPSCR
                CheckVFPEnabled(TRUE);
                FPSCR = R[t];
            elsif PSTATE.EL == EL0 then
                UNDEFINED;                        // Non-FPSCR registers accessible only at PL1 or above
            else
                CheckVFPEnabled(FALSE);           // Non-FPSCR registers are not affected by FPEXC.EN
                case reg of
                    when '0000'                   // VMSR access to FPSID is ignored
                    when '1000'  FPEXC = R[t];
                    otherwise    Unreachable();   // Dealt with above or in encoding-specific pseudocode

__instruction aarch32_HVC_AS
    __encoding aarch32_HVC_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm12 8 +: 12
        __field imm4 0 +: 4
        __opcode 'xxxx0001 0100xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __decode
            if cond != '1110' then UNPREDICTABLE;
            imm16 = imm12:imm4;

    __encoding aarch32_HVC_T1_A
        __instruction_set T32
        __field imm4 16 +: 4
        __field imm12 0 +: 12
        __opcode '11110111 1110xxxx 1000xxxx xxxxxxxx'
        __guard TRUE
        __decode
            imm16 = imm4:imm12;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations();
        if !HaveEL(EL2) || PSTATE.EL == EL0 || IsSecure() then
            UNDEFINED;
        
        if HaveEL(EL3) then
            if ELUsingAArch32(EL3) && SCR.HCE == '0' && PSTATE.EL == EL2 then
                UNPREDICTABLE;
            else
                hvc_enable = SCR_GEN[].HCE;
        else
            hvc_enable = if ELUsingAArch32(EL2) then NOT(HCR.HCD) else NOT(HCR_EL2.HCD);
        
        if hvc_enable == '0' then
            UNDEFINED;
        else
            AArch32.CallHypervisor(imm16);

__instruction aarch32_SUB_r_A
    __encoding aarch32_SUB_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 010xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1101' then SEE SUB (SP minus register);
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_SUB_r_T1_A
        __instruction_set T16
        __field Rm 6 +: 3
        __field Rn 3 +: 3
        __field Rd 0 +: 3
        __opcode '0001101x xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_SUB_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 101xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE CMP (register);
            if Rn == '1101' then SEE SUB (SP minus register);
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_AESIMC_A
    __encoding aarch32_AESIMC_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0011 11x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_AESIMC_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0011 11x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            Q[d>>1] = AESInvMixColumns(Q[m>>1]);

__instruction aarch32_QADD_A
    __encoding aarch32_QADD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0000xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QADD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 1000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (R[d], sat) = SignedSatQ(SInt(R[m]) + SInt(R[n]), 32);
            if sat then
                PSTATE.Q = '1';

__instruction aarch32_VSUB_f_A
    __encoding aarch32_VSUB_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x1xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSUB_f_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x11xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VSUB_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x1xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSUB_f_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x11xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if advsimd then  // Advanced SIMD instruction
                for r = 0 to regs-1
                    for e = 0 to elements-1
                        Elem[D[d+r],e,esize] = FPSub(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
            else             // VFP instruction
                case esize of
                    when 16
                        S[d] = Zeros(16) : FPSub(S[n]<15:0>, S[m]<15:0>, FPSCR);
                    when 32
                        S[d] = FPSub(S[n], S[m], FPSCR);
                    when 64
                        D[d] = FPSub(D[n], D[m], FPSCR);

__instruction aarch32_VRINTA_asimd_A
    __encoding aarch32_VRINTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0100 0xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0100 0xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_VRSHR_A
    __encoding aarch32_VRSHR_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0010 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRSHR_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0010 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            round_const = 1 << (shift_amount - 1);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) >> shift_amount;
                    Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_LDMDA_A
    __encoding aarch32_LDMDA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1000 00x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n] - 4*BitCount(registers) + 4;
            for i = 0 to 14
                if registers<i> == '1' then
                    R[i] = MemA[address,4];  address = address + 4;
            if registers<15> == '1' then
                LoadWritePC(MemA[address,4]);
            if wback && registers<n> == '0' then R[n] = R[n] - 4*BitCount(registers);
            if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;

__instruction aarch32_VRINTZ_vfp_A
    __encoding aarch32_VRINTZ_vfp_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110110 xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
            exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTZ_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110110 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
            exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
            case esize of
                when 16
                    S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
                when 32
                    S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
                when 64
                    D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_LDM_u_AS
    __encoding aarch32_LDM_u_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 15
        __opcode 'xxxx100x x1x1xxxx 0xxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 21 == '0'
        __decode
            n = UInt(Rn);  registers = register_list;  increment = (U == '1');  wordhigher = (P == U);
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if PSTATE.EL == EL2 then UNDEFINED;
            elsif PSTATE.M IN {M32_User,M32_System} then UNPREDICTABLE;
            else
                length = 4*BitCount(registers);
                address = if increment then R[n] else R[n]-length;
                if wordhigher then address = address+4;
                for i = 0 to 14
                    if registers<i> == '1' then  // Load User mode register
                        Rmode[i, M32_User] = MemA[address,4];  address = address + 4;

__instruction aarch32_LDREX_A
    __encoding aarch32_LDREX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1001xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = Zeros(32); // Zero offset
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDREX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11101000 0101xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            if t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n] + imm32;
            AArch32.SetExclusiveMonitors(address,4);
            R[t] = MemA[address,4];

__instruction aarch32_SSUB16_A
    __encoding aarch32_SSUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SSUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);
            diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);
            R[d]<15:0>  = diff1<15:0>;
            R[d]<31:16> = diff2<15:0>;
            PSTATE.GE<1:0> = if diff1 >= 0 then '11' else '00';
            PSTATE.GE<3:2> = if diff2 >= 0 then '11' else '00';

__instruction aarch32_VRINTX_vfp_A
    __encoding aarch32_VRINTX_vfp_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110111 xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            exact = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTX_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110111 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            exact = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
            rounding = FPRoundingMode(FPSCR);
            case esize of
                when 16
                    S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
                when 32
                    S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
                when 64
                    D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_VCGE_r_A
    __encoding aarch32_VCGE_r_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0011 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            type1 = if U == '1' then VCGEtype_unsigned else VCGEtype_signed;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGE_r_A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            type1 = VCGEtype_fp;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGE_r_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0011 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            type1 = if U == '1' then VCGEtype_unsigned else VCGEtype_signed;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGE_r_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            type1 = VCGEtype_fp;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        enumeration VCGEtype {VCGEtype_signed, VCGEtype_unsigned, VCGEtype_fp};
        
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                    case type1 of
                        when VCGEtype_signed    test_passed = (SInt(op1) >= SInt(op2));
                        when VCGEtype_unsigned  test_passed = (UInt(op1) >= UInt(op2));
                        when VCGEtype_fp        test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());
                    Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_SHSUB8_A
    __encoding aarch32_SHSUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHSUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);
            diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);
            diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);
            diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);
            R[d]<7:0>   = diff1<8:1>;
            R[d]<15:8>  = diff2<8:1>;
            R[d]<23:16> = diff3<8:1>;
            R[d]<31:24> = diff4<8:1>;

__instruction aarch32_LDREXD_A
    __encoding aarch32_LDREXD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1011xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  t2 = t + 1;  n = UInt(Rn);
            if Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDREXD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 0111xxxx'
        __guard TRUE
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
            if t == 15 || t2 == 15 || t == t2 || n == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            AArch32.SetExclusiveMonitors(address,8);
            value = MemA[address,8];
            // Extract words from 64-bit loaded value such that R[t] is
            // loaded from address and R[t2] from address+4.
            R[t]  = if BigEndian() then value<63:32> else value<31:0>;
            R[t2] = if BigEndian() then value<31:0> else value<63:32>;

__instruction aarch32_QSUB_A
    __encoding aarch32_QSUB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QSUB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 1010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (R[d], sat) = SignedSatQ(SInt(R[m]) - SInt(R[n]), 32);
            if sat then
                PSTATE.Q = '1';

__instruction aarch32_EOR_r_A
    __encoding aarch32_EOR_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 001xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_EOR_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rdn 0 +: 3
        __opcode '01000000 01xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_EOR_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 100xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE TEQ (register);
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] EOR shifted;
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_VABA_A
    __encoding aarch32_VABA_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0111 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VABA_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0111 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];
                    op2 = Elem[Din[m+r],e,esize];
                    absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + absdiff;
                    else
                        Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + absdiff;

__instruction aarch32_SMULBB_A
    __encoding aarch32_SMULBB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field M 6 +: 1
        __field N 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0110xxxx xxxxxxxx 1xx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            n_high = (N == '1');  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMULBB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field N 5 +: 1
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0001xxxx 1111xxxx 00xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            n_high = (N == '1');  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;
            operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
            result = SInt(operand1) * SInt(operand2);
            R[d] = result<31:0>;
            // Signed overflow cannot occur

__instruction aarch32_VQABS_A
    __encoding aarch32_VQABS_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0111 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQABS_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0111 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    result = Abs(SInt(Elem[D[m+r],e,esize]));
                    (Elem[D[d+r],e,esize], sat) = SignedSatQ(result, esize);
                    if sat then FPSCR.QC = '1';

__instruction aarch32_SHA1H_A
    __encoding aarch32_SHA1H_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0010 11x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_SHA1H_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0010 11x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            Q[d>>1] = ZeroExtend(ROL(Q[m>>1]<31:0>, 30), 128);

__instruction aarch32_SMC_AS
    __encoding aarch32_SMC_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field imm4 0 +: 4
        __opcode 'xxxx0001 0110xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // imm4 is for assembly/disassembly only and is ignored by hardware

    __encoding aarch32_SMC_T1_AS
        __instruction_set T32
        __field imm4 16 +: 4
        __opcode '11110111 1111xxxx 1000xxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            // imm4 is for assembly/disassembly only and is ignored by hardware
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
        
            if !HaveEL(EL3) || PSTATE.EL == EL0 then
                UNDEFINED;
        
            AArch32.CheckForSMCTrap();
        
            if !ELUsingAArch32(EL3) then
                if SCR_EL3.SMD == '1' then
                    // SMC disabled.
                    UNDEFINED;
            else
                if SCR.SCD == '1' then
                    // SMC disabled
                    if IsSecure() then
                        // Executes either as a NOP or UNALLOCATED.
                        c = ConstrainUnpredictable(Unpredictable_SMD);
                        assert c IN {Constraint_NOP, Constraint_UNDEF};
                        if c == Constraint_NOP then EndOfInstruction();
                    UNDEFINED;
        
            if !ELUsingAArch32(EL3) then
                AArch64.CallSecureMonitor(Zeros(16));
            else
                AArch32.TakeSMCException();

__instruction aarch32_LDRSH_i_A
    __encoding aarch32_LDRSH_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x1xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE LDRSH (literal);
            if P == '0' && W == '1' then SEE LDRSHT;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRSH_i_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111001 1011xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDRSH (literal);
            if Rt == '1111' then SEE "Related instructions";
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_LDRSH_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111001 0011xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDRSH (literal);
            if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE "Related instructions";
            if P == '1' && U == '1' && W == '0' then SEE LDRSHT;
            if P == '0' && W == '0' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            data = MemU[address,2];
            if wback then R[n] = offset_addr;
            R[t] = SignExtend(data, 32);

__instruction aarch32_MUL_A
    __encoding aarch32_MUL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 000xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_MUL_T1_A
        __instruction_set T16
        __field Rn 3 +: 3
        __field Rdm 0 +: 3
        __opcode '01000011 01xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rdm);  n = UInt(Rn);  m = UInt(Rdm);  setflags = !InITBlock();

    __encoding aarch32_MUL_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 0000xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results
            operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results
            result = operand1 * operand2;
            R[d] = result<31:0>;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result<31:0>);
                // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_CMN_rr_A
    __encoding aarch32_CMN_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0111xxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            shift_t = DecodeRegShift(type1);
            if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], shifted, '0');
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_NOP_A
    __encoding aarch32_NOP_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000000'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_NOP_T1_A
        __instruction_set T16
        __opcode '10111111 00000000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_NOP_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000000'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            // Do nothing

__instruction aarch32_VPMAX_i_A
    __encoding aarch32_VPMAX_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx1010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPMAX_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx1010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            bits(64) dest;
            h = elements DIV 2;
        
            for e = 0 to h-1
                op1 = Int(Elem[D[n],2*e,esize], unsigned);
                op2 = Int(Elem[D[n],2*e+1,esize], unsigned);
                result = if maximum then Max(op1,op2) else Min(op1,op2);
                Elem[dest,e,esize] = result<esize-1:0>;
                op1 = Int(Elem[D[m],2*e,esize], unsigned);
                op2 = Int(Elem[D[m],2*e+1,esize], unsigned);
                result = if maximum then Max(op1,op2) else Min(op1,op2);
                Elem[dest,e+h,esize] = result<esize-1:0>;
        
            D[d] = dest;

__instruction aarch32_VCVTA_vfp_A
    __encoding aarch32_VCVTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111100 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __encoding aarch32_VCVTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111100 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
            when 32
                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
            when 64
                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_VQDMULH_A
    __encoding aarch32_VQDMULH_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0xxxxxxx xxxx1011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQDMULH_T2A2_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1100 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQDMULH_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0xxxxxxx xxxx1011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQDMULH_T2A2_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1100 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
                    op1 = SInt(Elem[D[n+r],e,esize]);
                    // The following only saturates if both op1 and op2 equal -(2^(esize-1))
                    (result, sat) = SignedSatQ((2*op1*op2) >> esize, esize);
                    Elem[D[d+r],e,esize] = result;
                    if sat then FPSCR.QC = '1';

__instruction aarch32_VST2_m_A
    __encoding aarch32_VST2_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx100x xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align == '11' then UNDEFINED;
            if size == '11' then UNDEFINED;
            inc = if type1 == '1001' then 2 else 1;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST2_m_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  inc = 2;
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST2_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx100x xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align == '11' then UNDEFINED;
            if size == '11' then UNDEFINED;
            inc = if type1 == '1001' then 2 else 1;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VST2_m_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  inc = 2;
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = TRUE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    MemU[address,       ebytes] = Elem[D[d+r], e];
                    MemU[address+ebytes,ebytes] = Elem[D[d2+r],e];
                    address = address + 2*ebytes;
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 16*regs;

__instruction aarch32_MRS_br_AS
    __encoding aarch32_MRS_br_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field R 22 +: 1
        __field M1 16 +: 4
        __field Rd 12 +: 4
        __field M 8 +: 1
        __opcode 'xxxx0001 0x00xxxx xxxxxx1x 0000xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            d = UInt(Rd);  read_spsr = (R == '1');
            if d == 15 then UNPREDICTABLE;
            SYSm = M:M1;

    __encoding aarch32_MRS_br_T1_AS
        __instruction_set T32
        __field R 20 +: 1
        __field M1 16 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __opcode '11110011 111xxxxx 10x0xxxx xx1xxxxx'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            d = UInt(Rd);  read_spsr = (R == '1');
            if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13
            SYSm = M:M1;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if PSTATE.EL == EL0 then
               UNPREDICTABLE;
            else
                mode = PSTATE.M;
                if read_spsr then
                    SPSRaccessValid(SYSm, mode);           // Check for UNPREDICTABLE cases
                    case SYSm of
                        when '01110'  R[d] = SPSR_fiq;
                        when '10000'  R[d] = SPSR_irq;
                        when '10010'  R[d] = SPSR_svc;
                        when '10100'  R[d] = SPSR_abt;
                        when '10110'  R[d] = SPSR_und;
                        when '11100'
                            if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                            R[d] = SPSR_mon;
                        when '11110'  R[d] = SPSR_hyp;
                else
                    BankedRegisterAccessValid(SYSm, mode); // Check for UNPREDICTABLE cases
                    case SYSm of
                        when '00xxx'                       // Access the User mode registers
                            m = UInt(SYSm<2:0>) + 8;
                            R[d] = Rmode[m,M32_User];
                        when '01xxx'                       // Access the FIQ mode registers
                            m = UInt(SYSm<2:0>) + 8;
                            R[d] = Rmode[m,M32_FIQ];
                        when '1000x'                       // Access the IRQ mode registers
                            m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                            R[d] = Rmode[m,M32_IRQ];
                        when '1001x'                       // Access the Supervisor mode registers
                            m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                            R[d] = Rmode[m,M32_Svc];
                        when '1010x'                       // Access the Abort mode registers
                            m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                            R[d] = Rmode[m,M32_Abort];
                        when '1011x'                       // Access the Undefined mode registers
                            m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                            R[d] = Rmode[m,M32_Undef];
                        when '1110x'                       // Access Monitor registers
                            if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                            m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP
                            R[d] = Rmode[m,M32_Monitor];
                        when '11110'                       // Access ELR_hyp register
                            R[d] = ELR_hyp;
                        when '11111'                       // Access SP_hyp register
                            R[d] = Rmode[13,M32_Hyp];

__instruction aarch32_SHSAX_A
    __encoding aarch32_SHSAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHSAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum  = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);
            diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);
            R[d]<15:0>  = sum<16:1>;
            R[d]<31:16> = diff<16:1>;

__instruction aarch32_SMLALBB_A
    __encoding aarch32_SMLALBB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field M 6 +: 1
        __field N 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0100xxxx xxxxxxxx 1xx0xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
            n_high = (N == '1');  m_high = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_SMLALBB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field N 5 +: 1
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 1100xxxx xxxxxxxx 10xxxxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
            n_high = (N == '1');  m_high = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;
            operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
            result = SInt(operand1) * SInt(operand2) + SInt(R[dHi]:R[dLo]);
            R[dHi] = result<63:32>;
            R[dLo] = result<31:0>;

__instruction aarch32_LDRB_l_A
    __encoding aarch32_LDRB_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x1x11111 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE LDRBT;
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);
            add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || wback then UNPREDICTABLE;

    __encoding aarch32_LDRB_l_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 x0011111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE PLD;
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            base = Align(PC,4);
            address = if add then (base + imm32) else (base - imm32);
            R[t] = ZeroExtend(MemU[address,1], 32);

__instruction aarch32_VMLA_i_A
    __encoding aarch32_VMLA_i_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            add = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __encoding aarch32_VMLA_i_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            add = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);
                    addend = if add then product else -product;
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                    else
                        Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_SMMUL_A
    __encoding aarch32_SMMUL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field R 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0101xxxx 1111xxxx 00x1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMMUL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field R 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0101xxxx 1111xxxx 000xxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = SInt(R[n]) * SInt(R[m]);
            if round then result = result + 0x80000000;
            R[d] = result<63:32>;

__instruction aarch32_CRC32_A
    __encoding aarch32_CRC32_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sz 21 +: 2
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field C 9 +: 1
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0xx0xxxx xxxxxx1x 0100xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if ! HaveCRCExt() then UNDEFINED;
            d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
            size = 8 << UInt(sz);
            crc32c = (C == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if size == 64 then UNPREDICTABLE;
            if cond != '1110' then UNPREDICTABLE;

    __encoding aarch32_CRC32_T1_A
        __instruction_set T32
        __field C 20 +: 1
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field sz 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 10xxxxxx'
        __guard TRUE
        __decode
            if ! HaveCRCExt() then UNDEFINED;
            d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
            size = 8 << UInt(sz);
            crc32c = (C == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if size == 64 then UNPREDICTABLE;
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
        
            acc = R[n];             // accumulator
            val = R[m]<size-1:0>;   // input value
            poly = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;
            tempacc = BitReverse(acc):Zeros(size);
            tempval = BitReverse(val):Zeros(32);
            // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
            R[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));

__instruction aarch32_SHA1SU1_A
    __encoding aarch32_SHA1SU1_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0011 10x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_SHA1SU1_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0011 10x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '10' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            X = Q[d>>1]; Y = Q[m>>1];
            T = X EOR LSR(Y, 32);
            W0 = ROL(T<31:0>, 1);
            W1 = ROL(T<63:32>, 1);
            W2 = ROL(T<95:64>, 1);
            W3 = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);
            Q[d>>1] = W3:W2:W1:W0;

__instruction aarch32_SHA1SU0_A
    __encoding aarch32_SHA1SU0_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x11xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA1SU0_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x11xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            op1 = Q[d>>1]; op2 = Q[n>>1]; op3 = Q[m>>1];
            op2 = op2<63:0> : op1<127:64>;
            Q[d>>1] = op1 EOR op2 EOR op3;

__instruction aarch32_VMUL_i_A
    __encoding aarch32_VMUL_i_A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx11x0 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            unsigned = (U == '1'); polynomial = (op == '1'); long_destination = TRUE;
            esize = 8 << UInt(size); elements = 64 DIV esize;
            if polynomial then
                if U == '1' || size == '01' then UNDEFINED;
                if size == '10' then    // .p64
                    if !HaveCryptoExt() then UNDEFINED;
                    esize = 64; elements = 1;
            if Vd<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;

    __encoding aarch32_VMUL_i_T2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx11x0 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            unsigned = (U == '1'); polynomial = (op == '1'); long_destination = TRUE;
            esize = 8 << UInt(size); elements = 64 DIV esize;
            if polynomial then
                if U == '1' || size == '01' then UNDEFINED;
                if size == '10' then    // .p64
                    if !HaveCryptoExt() then UNDEFINED;
                    if InITBlock() then UNPREDICTABLE;
                    esize = 64; elements = 1;
            if Vd<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                    op2 = Elem[Din[m+r],e,esize];  op2val = Int(op2, unsigned);
                    if polynomial then
                        product = PolynomialMult(op1,op2);
                    else
                        product = (op1val*op2val)<2*esize-1:0>;
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = product;
                    else
                        Elem[D[d+r],e,esize] = product<esize-1:0>;

__instruction aarch32_AND_i_A
    __encoding aarch32_AND_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 000xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_AND_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 000xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE TST (immediate);
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = R[n] AND imm32;
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_EOR_i_A
    __encoding aarch32_EOR_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 001xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_EOR_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 100xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE TEQ (immediate);
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = R[n] EOR imm32;
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_VLD3_m_A
    __encoding aarch32_VLD3_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx010x xxxxxxxx'
        __guard TRUE
        __decode
            case type1 of
                when '0100'
                    inc = 1;
                when '0101'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            if size == '11' || align<1> == '1' then UNDEFINED;
            alignment = if align<0> == '0' then 1 else 8;
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx010x xxxxxxxx'
        __guard TRUE
        __decode
            case type1 of
                when '0100'
                    inc = 1;
                when '0101'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            if size == '11' || align<1> == '1' then UNDEFINED;
            alignment = if align<0> == '0' then 1 else 8;
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = FALSE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            for e = 0 to elements-1
                Elem[D[d], e] = MemU[address,ebytes];
                Elem[D[d2],e] = MemU[address+ebytes,ebytes];
                Elem[D[d3],e] = MemU[address+2*ebytes,ebytes];
                address = address + 3*ebytes;
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 24;

__instruction aarch32_VACGE_A
    __encoding aarch32_VACGE_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x1xxxxx xxxx1110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            or_equal = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VACGE_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x1xxxxx xxxx1110 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            or_equal = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = FPAbs(Elem[D[n+r],e,esize]);  op2 = FPAbs(Elem[D[m+r],e,esize]);
                    if or_equal then
                        test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());
                    else
                        test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());
                    Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_VRSRA_A
    __encoding aarch32_VRSRA_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0011 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRSRA_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0011 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            round_const = 1 << (shift_amount - 1);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) >> shift_amount;
                    Elem[D[d+r],e,esize] = Elem[D[d+r],e,esize] + result;

__instruction aarch32_TST_r_A
    __encoding aarch32_TST_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0001xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_TST_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rn 0 +: 3
        __opcode '01000010 00xxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_TST_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 0001xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] AND shifted;
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_AESE_A
    __encoding aarch32_AESE_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0011 00x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_AESE_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0011 00x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            op1 = Q[d>>1]; op2 = Q[m>>1];
            Q[d>>1] = AESSubBytes(AESShiftRows(op1 EOR op2));

__instruction aarch32_BFC_A
    __encoding aarch32_BFC_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field msb 16 +: 5
        __field Rd 12 +: 4
        __field lsb 7 +: 5
        __opcode 'xxxx0111 110xxxxx xxxxxxxx x0011111'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  msbit = UInt(msb);  lsbit = UInt(lsb);
            if d == 15 then UNPREDICTABLE;

    __encoding aarch32_BFC_T1_A
        __instruction_set T32
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field msb 0 +: 5
        __opcode '11110x11 01101111 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            d = UInt(Rd);  msbit = UInt(msb);  lsbit = UInt(imm3:imm2);
            if d == 15 then UNPREDICTABLE;  // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if msbit >= lsbit then
                R[d]<msbit:lsbit> = Replicate('0', msbit-lsbit+1);
                // Other bits of R[d] are unchanged
            else
                UNPREDICTABLE;

__instruction aarch32_VCVT_iv_A
    __encoding aarch32_VCVT_iv_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x111000 xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __encoding aarch32_VCVT_iv_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x111000 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            if to_integer then
                case esize of
                    when 16
                        S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
                    when 32
                        S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
                    when 64
                        S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);
            else
                case esize of
                    when 16
                        bits(16) fp16 = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                        S[d] = Zeros(16):fp16;
                    when 32
                        S[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                    when 64
                        D[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_DBG_A
    __encoding aarch32_DBG_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field option 0 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // DBG executes as a NOP. The 'option' field is ignored

    __encoding aarch32_DBG_T1_A
        __instruction_set T32
        __field option 0 +: 4
        __opcode '11110011 1010xxxx 10x0x000 1111xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // DBG executes as a NOP. The 'option' field is ignored

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();

__instruction aarch32_BIC_r_A
    __encoding aarch32_BIC_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 110xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_BIC_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rdn 0 +: 3
        __opcode '01000011 10xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_BIC_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 001xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;  // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] AND NOT(shifted);
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_VMAX_f_A
    __encoding aarch32_VMAX_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1111 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAX_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1111 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                    if maximum then
                        Elem[D[d+r],e,esize] = FPMax(op1, op2, StandardFPSCRValue());
                    else
                        Elem[D[d+r],e,esize] = FPMin(op1, op2, StandardFPSCRValue());

__instruction aarch32_SMMLS_A
    __encoding aarch32_SMMLS_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field R 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0101xxxx xxxxxxxx 11x1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

    __encoding aarch32_SMMLS_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field R 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0110xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = (SInt(R[a]) << 32) - SInt(R[n]) * SInt(R[m]);
            if round then result = result + 0x80000000;
            R[d] = result<63:32>;

__instruction aarch32_VABS_A
    __encoding aarch32_VABS_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x11 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            advsimd = TRUE;  floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VABS_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110000 xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VABS_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x11 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            advsimd = TRUE;  floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VABS_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110000 xxxx10xx 11x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if advsimd then  // Advanced SIMD instruction
                for r = 0 to regs-1
                    for e = 0 to elements-1
                        if floating_point then
                            Elem[D[d+r],e,esize] = FPAbs(Elem[D[m+r],e,esize]);
                        else
                            result = Abs(SInt(Elem[D[m+r],e,esize]));
                            Elem[D[d+r],e,esize] = result<esize-1:0>;
            else             // VFP instruction
                case esize of
                    when 16 S[d] = Zeros(16) : FPAbs(S[m]<15:0>);
                    when 32 S[d] = FPAbs(S[m]);
                    when 64 D[d] = FPAbs(D[m]);

__instruction aarch32_RSB_rr_A
    __encoding aarch32_RSB_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 011xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, '1');
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VBIF_A
    __encoding aarch32_VBIF_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x01xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE VEOR;
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIF_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x01xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE VEOR;
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL};
        
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                case operation of
                    when VBitOps_VBIF  D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));
                    when VBitOps_VBIT  D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));
                    when VBitOps_VBSL  D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));

__instruction aarch32_VSHL_i_A
    __encoding aarch32_VSHL_i_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if L:imm6 == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSHL_i_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if L:imm6 == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = LSL(Elem[D[m+r],e,esize], shift_amount);

__instruction aarch32_VPADDL_A
    __encoding aarch32_VPADDL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (op == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VPADDL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (op == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            h = elements DIV 2;
        
            for r = 0 to regs-1
                for e = 0 to h-1
                    op1 = Elem[D[m+r],2*e,esize];  op2 = Elem[D[m+r],2*e+1,esize];
                    result = Int(op1, unsigned) + Int(op2, unsigned);
                    Elem[D[d+r],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_UMLAL_A
    __encoding aarch32_UMLAL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 101xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_UMLAL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1110xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]:R[dLo]);
            R[dHi] = result<63:32>;
            R[dLo] = result<31:0>;
            if setflags then
                PSTATE.N = result<63>;
                PSTATE.Z = IsZeroBit(result<63:0>);
                // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_VSUBL_A
    __encoding aarch32_VSUBL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0011 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VSUBL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0011 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                if is_vsubw then
                    op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
                else
                    op1 = Int(Elem[Din[n],e,esize], unsigned);
                result = op1 - Int(Elem[Din[m],e,esize], unsigned);
                Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_YIELD_A
    __encoding aarch32_YIELD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000001'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_YIELD_T1_A
        __instruction_set T16
        __opcode '10111111 00010000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_YIELD_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000001'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            Hint_Yield();

__instruction aarch32_VCNT_A
    __encoding aarch32_VCNT_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0101 0xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8;  elements = 8;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCNT_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0101 0xx0xxxx'
        __guard TRUE
        __decode
            if size != '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8;  elements = 8;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = BitCount(Elem[D[m+r],e,esize])<esize-1:0>;

__instruction aarch32_VDUP_r_A
    __encoding aarch32_VDUP_r_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field B 22 +: 1
        __field Q 21 +: 1
        __field Vd 16 +: 4
        __field Rt 12 +: 4
        __field D 7 +: 1
        __field E 5 +: 1
        __opcode 'xxxx1110 1xx0xxxx xxxx1011 x0x1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            d = UInt(D:Vd);  t = UInt(Rt);  regs = if Q == '0' then 1 else 2;
            case B:E of
                when '00'  esize = 32;  elements = 2;
                when '01'  esize = 16;  elements = 4;
                when '10'  esize = 8;   elements = 8;
                when '11'  UNDEFINED;
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VDUP_r_T1A1_A
        __instruction_set T32
        __field B 22 +: 1
        __field Q 21 +: 1
        __field Vd 16 +: 4
        __field Rt 12 +: 4
        __field D 7 +: 1
        __field E 5 +: 1
        __opcode '11101110 1xx0xxxx xxxx1011 x0x1xxxx'
        __guard TRUE
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            d = UInt(D:Vd);  t = UInt(Rt);  regs = if Q == '0' then 1 else 2;
            case B:E of
                when '00'  esize = 32;  elements = 2;
                when '01'  esize = 16;  elements = 4;
                when '10'  esize = 8;   elements = 8;
                when '11'  UNDEFINED;
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            scalar = R[t]<esize-1:0>;
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = scalar;

__instruction aarch32_UMAAL_A
    __encoding aarch32_UMAAL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 0100xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_UMAAL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1110xxxx xxxxxxxx 0110xxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]) + UInt(R[dLo]);
            R[dHi] = result<63:32>;
            R[dLo] = result<31:0>;

__instruction aarch32_UHSUB16_A
    __encoding aarch32_UHSUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHSUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);
            diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);
            R[d]<15:0>  = diff1<16:1>;
            R[d]<31:16> = diff2<16:1>;

__instruction aarch32_VQSUB_A
    __encoding aarch32_VQSUB_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0010 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQSUB_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0010 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    diff = Int(Elem[D[n+r],e,esize], unsigned) - Int(Elem[D[m+r],e,esize], unsigned);
                    (Elem[D[d+r],e,esize], sat) = SatQ(diff, esize, unsigned);
                    if sat then FPSCR.QC = '1';

__instruction aarch32_BIC_i_A
    __encoding aarch32_BIC_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 110xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_BIC_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 001xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if d == 15 || n == 15 then UNPREDICTABLE;  // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = R[n] AND NOT(imm32);
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_VQSHRN_A
    __encoding aarch32_VQSHRN_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx100x 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then SEE VSHRN;
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VQSHRN_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx100x 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then SEE VSHRN;
            if Vm<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
                (result, sat) = SatQ(operand >> shift_amount, esize, dest_unsigned);
                Elem[D[d],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_VQRDMLAH_A
    __encoding aarch32_VQRDMLAH_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            add = TRUE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMLAH_A2_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1110 x1x0xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            add = TRUE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQRDMLAH_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '00' || size == '11' then UNDEFINED;
            add = TRUE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRDMLAH_T2_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1110 x1x0xxxx'
        __guard TRUE
        __decode
            if !HaveQRDMLAHExt() then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            if size == '11' then SEE "Related encodings";
            if size == '00' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            add = TRUE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        EncodingSpecificOperations();  CheckAdvSIMDEnabled();
        round_const = 1 << (esize-1);
        if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = SInt(Elem[D[n+r],e,esize]);
                op3 = SInt(Elem[D[d+r],e,esize]) << esize;
                if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
                (result, sat) = SignedSatQ((op3 + 2*(op1*op2) + round_const) >> esize, esize);
                Elem[D[d+r],e,esize] = result;
                if sat then FPSCR.QC = '1';

__instruction aarch32_UHSUB8_A
    __encoding aarch32_UHSUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHSUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);
            diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);
            diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);
            diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);
            R[d]<7:0>   = diff1<8:1>;
            R[d]<15:8>  = diff2<8:1>;
            R[d]<23:16> = diff3<8:1>;
            R[d]<31:24> = diff4<8:1>;

__instruction aarch32_UXTB16_A
    __encoding aarch32_UXTB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 11001111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTB16_T1_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 00111111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d]<15:0>  = ZeroExtend(rotated<7:0>, 16);
            R[d]<31:16> = ZeroExtend(rotated<23:16>, 16);

__instruction aarch32_TST_i_A
    __encoding aarch32_TST_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0001xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_TST_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm8 0 +: 8
        __opcode '11110x00 0001xxxx 0xxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = R[n] AND imm32;
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_VCVT_xs_A
    __encoding aarch32_VCVT_xs_A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx11xx 0xx1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if op<1> == '0' && !HaveFP16Ext() then UNDEFINED;
            if op<1> == '0' && imm6 == '10xxxx' then UNDEFINED;
            if imm6 == '0xxxxx' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            to_fixed = (op<0> == '1');  frac_bits = 64 - UInt(imm6);
            unsigned = (U == '1');
            case op<1> of
                 when '0' esize = 16; elements = 4;
                 when '1' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVT_xs_T1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx11xx 0xx1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if op<1> == '0' && !HaveFP16Ext() then UNDEFINED;
            if op<1> == '0' && imm6 == '10xxxx' then UNDEFINED;
            if imm6 == '0xxxxx' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            to_fixed = (op<0> == '1');  frac_bits = 64 - UInt(imm6);
            unsigned = (U == '1');
            case op<1> of
                 when '0' esize = 16; elements = 4;
                 when '1' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            bits(esize) result;
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[m+r],e,esize];
                    if to_fixed then
                        result = FPToFixed(op1, frac_bits, unsigned, StandardFPSCRValue(),
                                           FPRounding_ZERO);
                    else
                        result = FixedToFP(op1, frac_bits, unsigned, StandardFPSCRValue(),
                                           FPRounding_TIEEVEN);
                    Elem[D[d+r],e,esize] = result;

__instruction aarch32_VST4_m_A
    __encoding aarch32_VST4_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx000x xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            case type1 of
                when '0000'
                    inc = 1;
                when '0001'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx000x xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            case type1 of
                when '0000'
                    inc = 1;
                when '0001'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = TRUE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            for e = 0 to elements-1
                MemU[address,         ebytes] = Elem[D[d], e];
                MemU[address+ebytes,  ebytes] = Elem[D[d2],e];
                MemU[address+2*ebytes,ebytes] = Elem[D[d3],e];
                MemU[address+3*ebytes,ebytes] = Elem[D[d4],e];
                address = address + 4*ebytes;
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 32;

__instruction aarch32_VRSQRTE_A
    __encoding aarch32_VRSQRTE_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx010x 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            floating_point = (F == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRSQRTE_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx010x 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            floating_point = (F == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if floating_point then
                        Elem[D[d+r],e,esize] = FPRSqrtEstimate(Elem[D[m+r],e,esize], StandardFPSCRValue());
                    else
                        Elem[D[d+r],e,esize] = UnsignedRSqrtEstimate(Elem[D[m+r],e,esize]);

__instruction aarch32_RSC_i_A
    __encoding aarch32_RSC_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 111xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result, nzcv) = AddWithCarry(NOT(R[n]), imm32, PSTATE.C);
            if d == 15 then
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VDIV_A
    __encoding aarch32_VDIV_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x00xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VDIV_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x00xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            case esize of
                when 16
                    S[d] = Zeros(16) : FPDiv(S[n]<15:0>, S[m]<15:0>, FPSCR);
                when 32
                    S[d] = FPDiv(S[n], S[m], FPSCR);
                when 64
                    D[d] = FPDiv(D[n], D[m], FPSCR);

__instruction aarch32_VSQRT_A
    __encoding aarch32_VSQRT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110001 xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VSQRT_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110001 xxxx10xx 11x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            case esize of
                when 16 S[d] = Zeros(16) : FPSqrt(S[m]<15:0>, FPSCR);
                when 32 S[d] = FPSqrt(S[m], FPSCR);
                when 64 D[d] = FPSqrt(D[m], FPSCR);

__instruction aarch32_MVN_r_A
    __encoding aarch32_MVN_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 111xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_MVN_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rd 0 +: 3
        __opcode '01000011 11xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_MVN_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 011x1111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = NOT(shifted);
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_UQASX_A
    __encoding aarch32_UQASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);
            sum  = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);
            R[d]<15:0>  = UnsignedSat(diff, 16);
            R[d]<31:16> = UnsignedSat(sum, 16);

__instruction aarch32_LDRSHT_A
    __encoding aarch32_LDRSHT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx0000 x111xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_LDRSHT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0000 x011xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRSHT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111001 0011xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDRSH (literal);
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            EncodingSpecificOperations();
            offset = if register_form then R[m] else imm32;
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if postindex then R[n] else offset_addr;
            data = MemU_unpriv[address,2];
            if postindex then R[n] = offset_addr;
            R[t] = SignExtend(data, 32);

__instruction aarch32_VMVN_i_A
    __encoding aarch32_VMVN_i_T1A1_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx0xx0 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_i_T2A2_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx10x0 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_i_T3A3_A
        __instruction_set A32
        __field i 24 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '1111001x 1x000xxx xxxx110x 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_i_T1A1_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx0xx0 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_i_T2A2_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx10x0 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMVN_i_T3A3_A
        __instruction_set T32
        __field i 28 +: 1
        __field D 22 +: 1
        __field imm3 16 +: 3
        __field Vd 12 +: 4
        __field cmode 8 +: 4
        __field Q 6 +: 1
        __field imm4 0 +: 4
        __opcode '111x1111 1x000xxx xxxx110x 0x11xxxx'
        __guard TRUE
        __decode
            if (cmode<0> == '1' && cmode<3:2> != '11') || cmode<3:1> == '111' then SEE "Related encodings";
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
            d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                D[d+r] = NOT(imm64);

__instruction aarch32_VRINTZ_asimd_A
    __encoding aarch32_VRINTZ_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0101 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPRounding_ZERO;  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTZ_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0101 1xx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            rounding = FPRounding_ZERO;  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_USAT_A
    __encoding aarch32_USAT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sat_imm 16 +: 5
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field sh 6 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0110 111xxxxx xxxxxxxx xx01xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
            (shift_t, shift_n) = DecodeImmShift(sh:'0', imm5);
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_USAT_T1_A
        __instruction_set T32
        __field sh 21 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field sat_imm 0 +: 5
        __opcode '11110x11 10x0xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            if sh == '1' && (imm3:imm2) == '00000' then SEE USAT16;
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
            (shift_t, shift_n) = DecodeImmShift(sh:'0', imm3:imm2);
            if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand = Shift(R[n], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored
            (result, sat) = UnsignedSatQ(SInt(operand), saturate_to);
            R[d] = ZeroExtend(result, 32);
            if sat then
                PSTATE.Q = '1';

__instruction aarch32_VDUP_s_A
    __encoding aarch32_VDUP_s_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field imm4 16 +: 4
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xxxx xxxx1100 0xx0xxxx'
        __guard TRUE
        __decode
            if imm4 == 'x000' then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            case imm4 of
                when 'xxx1'  esize = 8;  elements = 8;  index = UInt(imm4<3:1>);
                when 'xx10'  esize = 16;  elements = 4;  index = UInt(imm4<3:2>);
                when 'x100'  esize = 32;  elements = 2;  index = UInt(imm4<3>);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VDUP_s_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field imm4 16 +: 4
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xxxx xxxx1100 0xx0xxxx'
        __guard TRUE
        __decode
            if imm4 == 'x000' then UNDEFINED;
            if Q == '1' && Vd<0> == '1' then UNDEFINED;
            case imm4 of
                when 'xxx1'  esize = 8;  elements = 8;  index = UInt(imm4<3:1>);
                when 'xx10'  esize = 16;  elements = 4;  index = UInt(imm4<3:2>);
                when 'x100'  esize = 32;  elements = 2;  index = UInt(imm4<3>);
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            scalar = Elem[D[m],index,esize];
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = scalar;

__instruction aarch32_MSR_i_AS
    __encoding aarch32_MSR_i_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field R 22 +: 1
        __field mask 16 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0x10xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            if mask == '0000' && R == '0' then SEE "Related encodings";
            imm32 = A32ExpandImm(imm12);  write_spsr = (R == '1');
            if mask == '0000' then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if write_spsr then
                if PSTATE.M IN {M32_User,M32_System} then
                    UNPREDICTABLE;
                else
                    SPSRWriteByInstr(imm32, mask);
            else
                // Attempts to change to an illegal mode will invoke the Illegal Execution state mechanism
                CPSRWriteByInstr(imm32, mask);

__instruction aarch32_MOV_rr_A
    __encoding aarch32_MOV_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 101xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __encoding aarch32_MOV_rr_T1_A
        __instruction_set T16
        __field op 6 +: 4
        __field Rs 3 +: 3
        __field Rdm 0 +: 3
        __opcode '0100000x xxxxxxxx'
        __guard TRUE
        __decode
            if !(op IN {'0010', '0011', '0100', '0111'}) then SEE "Related encodings";
            d = UInt(Rdm);  m = UInt(Rdm);  s = UInt(Rs);
            setflags = !InITBlock();  shift_t = DecodeRegShift(op<2>:op<0>);

    __encoding aarch32_MOV_rr_T2_A
        __instruction_set T32
        __field type1 21 +: 2
        __field S 20 +: 1
        __field Rm 16 +: 4
        __field Rd 8 +: 4
        __field Rs 0 +: 4
        __opcode '11111010 0xxxxxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || m == 15 || s == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            (result, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_UHSAX_A
    __encoding aarch32_UHSAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHSAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum  = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);
            diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);
            R[d]<15:0>  = sum<16:1>;
            R[d]<31:16> = diff<16:1>;

__instruction aarch32_LDREXH_A
    __encoding aarch32_LDREXH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1111xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDREXH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 0101xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            AArch32.SetExclusiveMonitors(address,2);
            R[t] = ZeroExtend(MemA[address,2], 32);

__instruction aarch32_UBFX_A
    __encoding aarch32_UBFX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field widthm1 16 +: 5
        __field Rd 12 +: 4
        __field lsb 7 +: 5
        __field Rn 0 +: 4
        __opcode 'xxxx0111 111xxxxx xxxxxxxx x101xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);
            lsbit = UInt(lsb);  widthminus1 = UInt(widthm1);
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_UBFX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field widthm1 0 +: 5
        __opcode '11110x11 1100xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);
            lsbit = UInt(imm3:imm2);  widthminus1 = UInt(widthm1);
            if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            msbit = lsbit + widthminus1;
            if msbit <= 31 then
                R[d] = ZeroExtend(R[n]<msbit:lsbit>, 32);
            else
                UNPREDICTABLE;

__instruction aarch32_VMLA_i_A
    __encoding aarch32_VMLA_i_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1000 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            add = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __encoding aarch32_VMLA_i_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1000 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            add = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);
                    addend = if add then product else -product;
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                    else
                        Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

__instruction aarch32_LDRSB_l_A
    __encoding aarch32_LDRSB_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x11111 xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE LDRSBT;
            t = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || wback then UNPREDICTABLE;

    __encoding aarch32_LDRSB_l_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111001 x0011111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE PLI;
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            base = Align(PC,4);
            address = if add then (base + imm32) else (base - imm32);
            R[t] = SignExtend(MemU[address,1], 32);

__instruction aarch32_VCVT_iv_A
    __encoding aarch32_VCVT_iv_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x11110x xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __encoding aarch32_VCVT_iv_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field opc2 16 +: 3
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x11110x xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            to_integer = (opc2<2> == '1');
            if to_integer then
                unsigned = (opc2<0> == '0');
                rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
                d = UInt(Vd:D);
                case size of
                    when '01' esize = 16; m = UInt(Vm:M);
                    when '10' esize = 32; m = UInt(Vm:M);
                    when '11' esize = 64; m = UInt(M:Vm);
            else
                unsigned = (op == '0');
                rounding = FPRoundingMode(FPSCR);
                m = UInt(Vm:M);
                case size of
                    when '01' esize = 16; d = UInt(Vd:D);
                    when '10' esize = 32; d = UInt(Vd:D);
                    when '11' esize = 64; d = UInt(D:Vd);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            if to_integer then
                case esize of
                    when 16
                        S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
                    when 32
                        S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
                    when 64
                        S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);
            else
                case esize of
                    when 16
                        bits(16) fp16 = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                        S[d] = Zeros(16):fp16;
                    when 32
                        S[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
                    when 64
                        D[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_STLH_A
    __encoding aarch32_STLH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1110xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_STLH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1001xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            MemO[address, 2] = R[t]<15:0>;

__instruction aarch32_LDRH_r_A
    __encoding aarch32_LDRH_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x1xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if P == '0' && W == '1' then SEE LDRHT;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = (SRType_LSL, 0);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRH_r_T1_A
        __instruction_set T16
        __field Rm 6 +: 3
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '0101101x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_LDRH_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0011xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDRH (literal);
            if Rt == '1111' then SEE PLDW (register);
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if index then offset_addr else R[n];
            data = MemU[address,2];
            if wback then R[n] = offset_addr;
            R[t] = ZeroExtend(data, 32);

__instruction aarch32_VQSHL_r_A
    __encoding aarch32_VQSHL_r_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQSHL_r_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    shift = SInt(Elem[D[n+r],e,esize]<7:0>);
                    operand = Int(Elem[D[m+r],e,esize], unsigned);
                    (result,sat) = SatQ(operand << shift, esize, unsigned);
                    Elem[D[d+r],e,esize] = result;
                    if sat then FPSCR.QC = '1';

__instruction aarch32_CBNZ_A
    __encoding aarch32_CBNZ_T1_A
        __instruction_set T16
        __field op 11 +: 1
        __field i 9 +: 1
        __field imm5 3 +: 5
        __field Rn 0 +: 3
        __opcode '1011x0x1 xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  imm32 = ZeroExtend(i:imm5:'0', 32);  nonzero = (op == '1');
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations();
        if nonzero != IsZero(R[n]) then
            BranchWritePC(PC + imm32);

__instruction aarch32_SUB_i_A
    __encoding aarch32_SUB_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 010xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' && S == '0' then SEE ADR;
            if Rn == '1101' then SEE SUB (SP minus immediate);
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_SUB_i_T1_A
        __instruction_set T16
        __field imm3 6 +: 3
        __field Rn 3 +: 3
        __field Rd 0 +: 3
        __opcode '0001111x xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm3, 32);

    __encoding aarch32_SUB_i_T2_A
        __instruction_set T16
        __field Rdn 8 +: 3
        __field imm8 0 +: 8
        __opcode '00111xxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm8, 32);

    __encoding aarch32_SUB_i_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 101xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE CMP (immediate);
            if Rn == '1101' then SEE SUB (SP minus immediate);
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_SUB_i_T4_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 1010xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE ADR;
            if Rn == '1101' then SEE SUB (SP minus immediate);
            d = UInt(Rd);  n = UInt(Rn);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
            if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_SUB_i_T5_AS
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode '11110011 1101xxxx 10x0xxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            if Rn == '1110' && IsZero(imm8) then SEE ERET;
            d = 15;  n = UInt(Rn);  setflags = TRUE;  imm32 = ZeroExtend(imm8, 32);
            if n != 14 then UNPREDICTABLE;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result, nzcv) = AddWithCarry(R[n], NOT(imm32), '1');
            if d == 15 then
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VQNEG_A
    __encoding aarch32_VQNEG_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0111 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQNEG_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0111 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    result = -SInt(Elem[D[m+r],e,esize]);
                    (Elem[D[d+r],e,esize], sat) = SignedSatQ(result, esize);
                    if sat then FPSCR.QC = '1';

__instruction aarch32_SDIV_A
    __encoding aarch32_SDIV_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0001xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE;

    __encoding aarch32_SDIV_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1001xxxx xxxxxxxx 1111xxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if SInt(R[m]) == 0 then
                result = 0;
            else
                result = RoundTowardsZero(Real(SInt(R[n])) / Real(SInt(R[m])));
            R[d] = result<31:0>;

__instruction aarch32_ADD_rr_A
    __encoding aarch32_ADD_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 100xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], shifted, '0');
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_QDADD_A
    __encoding aarch32_QDADD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0100xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QDADD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 1001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);
            (R[d], sat2)  = SignedSatQ(SInt(R[m]) + SInt(doubled), 32);
            if sat1 || sat2 then
                PSTATE.Q = '1';

__instruction aarch32_VMUL_f_A
    __encoding aarch32_VMUL_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMUL_f_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x10xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE;
            
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VMUL_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMUL_f_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x10xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE;
            
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if advsimd then  // Advanced SIMD instruction
                for r = 0 to regs-1
                    for e = 0 to elements-1
                        Elem[D[d+r],e,esize] = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
            else             // VFP instruction
                case esize of
                    when 16
                        S[d] = Zeros(16) : FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);
                    when 32
                        S[d] = FPMul(S[n], S[m], FPSCR);
                    when 64
                        D[d] = FPMul(D[n], D[m], FPSCR);

__instruction aarch32_VUZP_A
    __encoding aarch32_VUZP_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0001 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || (Q == '0' && size == '10') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            quadword_operation = (Q == '1');  esize = 8 << UInt(size);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VUZP_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0001 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || (Q == '0' && size == '10') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            quadword_operation = (Q == '1');  esize = 8 << UInt(size);
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            if quadword_operation then
                if d == m then
                    Q[d>>1] = bits(128) UNKNOWN;  Q[m>>1] = bits(128) UNKNOWN;
                else
                    zipped_q = Q[m>>1]:Q[d>>1];
                    for e = 0 to (128 DIV esize) - 1
                        Elem[Q[d>>1],e,esize] = Elem[zipped_q,2*e,esize];
                        Elem[Q[m>>1],e,esize] = Elem[zipped_q,2*e+1,esize];
            else
                if d == m then
                    D[d] = bits(64) UNKNOWN;  D[m] = bits(64) UNKNOWN;
                else
                    zipped_d = D[m]:D[d];
                    for e = 0 to (64 DIV esize) - 1
                        Elem[D[d],e,esize] = Elem[zipped_d,2*e,esize];
                        Elem[D[m],e,esize] = Elem[zipped_d,2*e+1,esize];

__instruction aarch32_PKH_A
    __encoding aarch32_PKH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field tb 6 +: 1
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1000xxxx xxxxxxxx xx01xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  tbform = (tb == '1');
            (shift_t, shift_n) = DecodeImmShift(tb:'0', imm5);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_PKH_T1_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field tb 5 +: 1
        __field T 4 +: 1
        __field Rm 0 +: 4
        __opcode '11101010 1100xxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if S == '1' || T == '1' then UNDEFINED;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  tbform = (tb == '1');
            (shift_t, shift_n) = DecodeImmShift(tb:'0', imm3:imm2);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand2 = Shift(R[m], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored
            R[d]<15:0>  = if tbform then operand2<15:0> else R[n]<15:0>;
            R[d]<31:16> = if tbform then R[n]<31:16>    else operand2<31:16>;

__instruction aarch32_MSR_r_AS
    __encoding aarch32_MSR_r_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field R 22 +: 1
        __field mask 16 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0x10xxxx xxxxxx0x 0000xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            n = UInt(Rn);  write_spsr = (R == '1');
            if mask == '0000' then UNPREDICTABLE;
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_MSR_r_T1_AS
        __instruction_set T32
        __field R 20 +: 1
        __field Rn 16 +: 4
        __field mask 8 +: 4
        __opcode '11110011 100xxxxx 10x0xxxx xx0xxxxx'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            n = UInt(Rn);  write_spsr = (R == '1');
            if mask == '0000' then UNPREDICTABLE;
            if n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if write_spsr then
                if PSTATE.M IN {M32_User,M32_System} then
                    UNPREDICTABLE;
                else
                    SPSRWriteByInstr(R[n], mask);
            else
                // Attempts to change to an illegal mode will invoke the Illegal Execution state mechanism
                CPSRWriteByInstr(R[n], mask);

__instruction aarch32_VHADD_A
    __encoding aarch32_VHADD_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            add = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VHADD_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 9 +: 1
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            add = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Int(Elem[D[n+r],e,esize], unsigned);
                    op2 = Int(Elem[D[m+r],e,esize], unsigned);
                    result = if add then op1+op2 else op1-op2;
                    Elem[D[d+r],e,esize] = result<esize:1>;

__instruction aarch32_VQRSHL_A
    __encoding aarch32_VQRSHL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQRSHL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0101 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    shift = SInt(Elem[D[n+r],e,esize]<7:0>);
                    round_const = 1 << (-1-shift); // 0 for left shift, 2^(n-1) for right shift
                    operand = Int(Elem[D[m+r],e,esize], unsigned);
                    (result, sat) = SatQ((operand + round_const) << shift, esize, unsigned);
                    Elem[D[d+r],e,esize] = result;
                    if sat then FPSCR.QC = '1';

__instruction aarch32_STRD_r_A
    __encoding aarch32_STRD_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x0xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rt<0> == '1' then UNPREDICTABLE;
            t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if P == '0' && W == '1' then UNPREDICTABLE;
            if t2 == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);
            address = if index then offset_addr else R[n];
            if address == Align(address, 8) then
                bits(64) data;
                if BigEndian() then
                    data<63:32> = R[t];
                    data<31:0> = R[t2];
                else
                    data<31:0> = R[t];
                    data<63:32> = R[t2];
                MemA[address,8] = data;
            else
                MemA[address,4] = R[t];
                MemA[address+4,4] = R[t2];
            if wback then R[n] = offset_addr;

__instruction aarch32_VPADAL_A
    __encoding aarch32_VPADAL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0110 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (op == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VPADAL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0110 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (op == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            h = elements DIV 2;
        
            for r = 0 to regs-1
                for e = 0 to h-1
                    op1 = Elem[D[m+r],2*e,esize];  op2 = Elem[D[m+r],2*e+1,esize];
                    result = Int(op1, unsigned) + Int(op2, unsigned);
                    Elem[D[d+r],e,2*esize] = Elem[D[d+r],e,2*esize] + result;

__instruction aarch32_USUB8_A
    __encoding aarch32_USUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_USUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);
            diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);
            diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);
            diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);
            R[d]<7:0>   = diff1<7:0>;
            R[d]<15:8>  = diff2<7:0>;
            R[d]<23:16> = diff3<7:0>;
            R[d]<31:24> = diff4<7:0>;
            PSTATE.GE<0>  = if diff1 >= 0 then '1' else '0';
            PSTATE.GE<1>  = if diff2 >= 0 then '1' else '0';
            PSTATE.GE<2>  = if diff3 >= 0 then '1' else '0';
            PSTATE.GE<3>  = if diff4 >= 0 then '1' else '0';

__instruction aarch32_SMUAD_A
    __encoding aarch32_SMUAD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0000xxxx 1111xxxx 00x1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMUAD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0010xxxx 1111xxxx 000xxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand2 = if m_swap then ROR(R[m],16) else R[m];
            product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
            product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
            result = product1 + product2;
            R[d] = result<31:0>;
            if result != SInt(result<31:0>) then  // Signed overflow
                PSTATE.Q = '1';

__instruction aarch32_TEQ_r_A
    __encoding aarch32_TEQ_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0011xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_TEQ_r_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 1001xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] EOR shifted;
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_USAX_A
    __encoding aarch32_USAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0101xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_USAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0100xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum  = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);
            diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);
            R[d]<15:0>  = sum<15:0>;
            R[d]<31:16> = diff<15:0>;
            PSTATE.GE<1:0> = if sum  >= 0x10000 then '11' else '00';
            PSTATE.GE<3:2> = if diff >= 0 then '11' else '00';

__instruction aarch32_RSC_r_A
    __encoding aarch32_RSC_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 111xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, PSTATE.C);
            if d == 15 then
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_ORN_i_A
    __encoding aarch32_ORN_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 011xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE MVN (immediate);
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = R[n] OR NOT(imm32);
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_UHASX_A
    __encoding aarch32_UHASX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0111xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UHASX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1010xxxx 1111xxxx 0110xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);
            sum  = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);
            R[d]<15:0>  = diff<16:1>;
            R[d]<31:16> = sum<16:1>;

__instruction aarch32_BIC_rr_A
    __encoding aarch32_BIC_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 110xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] AND NOT(shifted);
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_STLEX_A
    __encoding aarch32_STLEX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1000xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STLEX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1110xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            if AArch32.ExclusiveMonitorsPass(address,4) then
                MemO[address, 4] = R[t];
                R[d] = ZeroExtend('0');
            else
                R[d] = ZeroExtend('1');

__instruction aarch32_LDRSBT_A
    __encoding aarch32_LDRSBT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx0000 x111xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_LDRSBT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0000 x011xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRSBT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111001 0001xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDRSB (literal);
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            EncodingSpecificOperations();
            offset = if register_form then R[m] else imm32;
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if postindex then R[n] else offset_addr;
            R[t] = SignExtend(MemU_unpriv[address,1], 32);
            if postindex then R[n] = offset_addr;

__instruction aarch32_SHSUB16_A
    __encoding aarch32_SHSUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0011xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SHSUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);
            diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);
            R[d]<15:0>  = diff1<16:1>;
            R[d]<31:16> = diff2<16:1>;

__instruction aarch32_REV16_A
    __encoding aarch32_REV16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1011xxxx xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  m = UInt(Rm);
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_REV16_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rd 0 +: 3
        __opcode '10111010 01xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);

    __encoding aarch32_REV16_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 1001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
            if m != n || d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            bits(32) result;
            result<31:24> = R[m]<23:16>;
            result<23:16> = R[m]<31:24>;
            result<15:8>  = R[m]<7:0>;
            result<7:0>   = R[m]<15:8>;
            R[d] = result;

__instruction aarch32_SMLAD_A
    __encoding aarch32_SMLAD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0000xxxx xxxxxxxx 00x1xxxx'
        __guard cond != '1111'
        __decode
            if Ra == '1111' then SEE SMUAD;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMLAD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0010xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE SMUAD;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand2 = if m_swap then ROR(R[m],16) else R[m];
            product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
            product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
            result = product1 + product2 + SInt(R[a]);
            R[d] = result<31:0>;
            if result != SInt(result<31:0>) then  // Signed overflow
                PSTATE.Q = '1';

__instruction aarch32_UXTAB16_A
    __encoding aarch32_UXTAB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1100xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE UXTB16;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UXTAB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0011xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE UXTB16;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d]<15:0>  = R[n]<15:0> + ZeroExtend(rotated<7:0>, 16);
            R[d]<31:16> = R[n]<31:16> + ZeroExtend(rotated<23:16>, 16);

__instruction aarch32_ORR_r_A
    __encoding aarch32_ORR_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 100xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_ORR_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rdn 0 +: 3
        __opcode '01000011 00xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_ORR_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 010xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rn == '1111' then SEE "Related encodings";
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] OR shifted;
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_STREXH_A
    __encoding aarch32_STREXH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1110xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STREXH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 0101xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13
            if d == n || d == t then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            if AArch32.ExclusiveMonitorsPass(address,2) then
                MemA[address,2] = R[t]<15:0>;
                R[d] = ZeroExtend('0');
            else
                R[d] = ZeroExtend('1');

__instruction aarch32_SMULL_A
    __encoding aarch32_SMULL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 110xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_SMULL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1000xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = SInt(R[n]) * SInt(R[m]);
            R[dHi] = result<63:32>;
            R[dLo] = result<31:0>;
            if setflags then
                PSTATE.N = result<63>;
                PSTATE.Z = IsZeroBit(result<63:0>);
                // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_MVN_i_A
    __encoding aarch32_MVN_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 111xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '0'
        __unpredictable_unless 18 == '0'
        __unpredictable_unless 17 == '0'
        __unpredictable_unless 16 == '0'
        __decode
            d = UInt(Rd);  setflags = (S == '1');
            (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

    __encoding aarch32_MVN_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x00 011x1111 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = (S == '1');
            (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
            if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = NOT(imm32);
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_MLA_A
    __encoding aarch32_MLA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 001xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  setflags = (S == '1');
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

    __encoding aarch32_MLA_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 0000xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE MUL;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  setflags = FALSE;
            if d == 15 || n == 15 || m  == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results
            operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results
            addend   = SInt(R[a]);  // addend   = UInt(R[a]) produces the same final results
            result = operand1 * operand2 + addend;
            R[d] = result<31:0>;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result<31:0>);
                // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_LDRH_l_A
    __encoding aarch32_LDRH_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x11111 xxxxxxxx 1011xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE LDRHT;
            t = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || wback then UNPREDICTABLE;

    __encoding aarch32_LDRH_l_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 x0111111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE PLD (literal);
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            base = Align(PC,4);
            address = if add then (base + imm32) else (base - imm32);
            data = MemU[address,2];
            R[t] = ZeroExtend(data, 32);

__instruction aarch32_VADD_f_A
    __encoding aarch32_VADD_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VADD_f_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x11xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VADD_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1101 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VADD_f_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x11xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if advsimd then  // Advanced SIMD instruction
                for r = 0 to regs-1
                    for e = 0 to elements-1
                        Elem[D[d+r],e,esize] = FPAdd(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize],
                                                     StandardFPSCRValue());
            else             // VFP instruction
                case esize of
                    when 16
                        S[d] = Zeros(16) : FPAdd(S[n]<15:0>, S[m]<15:0>, FPSCR);
                    when 32
                        S[d] = FPAdd(S[n], S[m], FPSCR);
                    when 64
                        D[d] = FPAdd(D[n], D[m], FPSCR);

__instruction aarch32_SXTH_A
    __encoding aarch32_SXTH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 10111111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTH_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rd 0 +: 3
        __opcode '10110010 00xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

    __encoding aarch32_SXTH_T2_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 00001111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d] = SignExtend(rotated<15:0>, 32);

__instruction aarch32_VRSQRTS_A
    __encoding aarch32_VRSQRTS_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x1xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRSQRTS_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x1xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = FPRSqrtStep(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize]);

__instruction aarch32_PLI_i_A
    __encoding aarch32_PLI_i_A1_A
        __instruction_set A32
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode '11110100 x101xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

    __encoding aarch32_PLI_i_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode '11111001 1001xxxx 1111xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE encoding T3;
            n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = TRUE;

    __encoding aarch32_PLI_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode '11111001 0001xxxx 11111100 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE encoding T3;
            n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);  add = FALSE;

    __encoding aarch32_PLI_i_T3_A
        __instruction_set T32
        __field U 23 +: 1
        __field imm12 0 +: 12
        __opcode '11111001 x0011111 1111xxxx xxxxxxxx'
        __guard TRUE
        __decode
            n = 15;  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            base = if n == 15 then Align(PC,4) else R[n];
            address = if add then (base + imm32) else (base - imm32);
            Hint_PreloadInstr(address);

__instruction aarch32_LDRSB_r_A
    __encoding aarch32_LDRSB_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx000x x0x1xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if P == '0' && W == '1' then SEE LDRSBT;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = (SRType_LSL, 0);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRSB_r_T1_A
        __instruction_set T16
        __field Rm 6 +: 3
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '0101011x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_LDRSB_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0001xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE PLI;
            if Rn == '1111' then SEE LDRSB (literal);
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if index then offset_addr else R[n];
            R[t] = SignExtend(MemU[address,1], 32);
            if wback then R[n] = offset_addr;

__instruction aarch32_MOVT_A
    __encoding aarch32_MOVT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm4 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0100xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  imm16 = imm4:imm12;
            if d == 15 then UNPREDICTABLE;

    __encoding aarch32_MOVT_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm4 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 1100xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  imm16 = imm4:i:imm3:imm8;
            if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            R[d]<31:16> = imm16;
            // R[d]<15:0> unchanged

__instruction aarch32_VNMLA_A
    __encoding aarch32_VNMLA_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 0x10xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '01' && !HaveFP16Ext() then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            type1 = VFPNegMul_VNMUL;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VNMLA_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 0x10xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '01' && !HaveFP16Ext() then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            type1 = VFPNegMul_VNMUL;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL};
        
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            case esize of
                when 16
                    product16 = FPMul(S[n]<15:0>, S[m]<15:0>, FPSCR);
                    case type1 of
                        when VFPNegMul_VNMLA  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), FPNeg(product16), FPSCR);
                        when VFPNegMul_VNMLS  S[d] = Zeros(16) : FPAdd(FPNeg(S[d]<15:0>), product16, FPSCR);
                        when VFPNegMul_VNMUL  S[d] = Zeros(16) : FPNeg(product16);
                when 32
                    product32 = FPMul(S[n], S[m], FPSCR);
                    case type1 of
                        when VFPNegMul_VNMLA  S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), FPSCR);
                        when VFPNegMul_VNMLS  S[d] = FPAdd(FPNeg(S[d]), product32, FPSCR);
                        when VFPNegMul_VNMUL  S[d] = FPNeg(product32);
                when 64
                    product64 = FPMul(D[n], D[m], FPSCR);
                    case type1 of
                        when VFPNegMul_VNMLA  D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), FPSCR);
                        when VFPNegMul_VNMLS  D[d] = FPAdd(FPNeg(D[d]), product64, FPSCR);
                        when VFPNegMul_VNMUL  D[d] = FPNeg(product64);

__instruction aarch32_QSUB8_A
    __encoding aarch32_QSUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QSUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);
            diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);
            diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);
            diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);
            R[d]<7:0>   = SignedSat(diff1, 8);
            R[d]<15:8>  = SignedSat(diff2, 8);
            R[d]<23:16> = SignedSat(diff3, 8);
            R[d]<31:24> = SignedSat(diff4, 8);

__instruction aarch32_VABD_i_A
    __encoding aarch32_VABD_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0111 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VABD_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0111 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];
                    op2 = Elem[Din[m+r],e,esize];
                    absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = absdiff<2*esize-1:0>;
                    else
                        Elem[D[d+r],e,esize] = absdiff<esize-1:0>;

__instruction aarch32_LDRBT_A
    __encoding aarch32_LDRBT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0100 x111xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_LDRBT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 x111xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRBT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0001xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDRB (literal);
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            EncodingSpecificOperations();
            offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if postindex then R[n] else offset_addr;
            R[t] = ZeroExtend(MemU_unpriv[address,1],32);
            if postindex then R[n] = offset_addr;

__instruction aarch32_STM_u_AS
    __encoding aarch32_STM_u_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx100x x1x0xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 21 == '0'
        __decode
            n = UInt(Rn);  registers = register_list;  increment = (U == '1');  wordhigher = (P == U);
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if PSTATE.EL == EL2 then
                UNDEFINED;
            elsif PSTATE.M IN {M32_User,M32_System} then
                UNPREDICTABLE;
            else
                length = 4*BitCount(registers);
                address = if increment then R[n] else R[n]-length;
                if wordhigher then address = address+4;
                for i = 0 to 14
                    if registers<i> == '1' then  // Store User mode register
                        MemA[address,4] = Rmode[i, M32_User];
                        address = address + 4;
                if registers<15> == '1' then
                    MemA[address,4] = PCStoreValue();

__instruction aarch32_ADC_r_A
    __encoding aarch32_ADC_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 101xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_ADC_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rdn 0 +: 3
        __opcode '01000001 01xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_ADC_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 010xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SMLSD_A
    __encoding aarch32_SMLSD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0000xxxx xxxxxxxx 01x1xxxx'
        __guard cond != '1111'
        __decode
            if Ra == '1111' then SEE SMUSD;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMLSD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0100xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE SMUSD;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_swap = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand2 = if m_swap then ROR(R[m],16) else R[m];
            product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
            product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
            result = product1 - product2 + SInt(R[a]);
            R[d] = result<31:0>;
            if result != SInt(result<31:0>) then  // Signed overflow
                PSTATE.Q = '1';

__instruction aarch32_VLD3_1_A
    __encoding aarch32_VLD3_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD3 (single 3-element structure to all lanes);
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD3 (single 3-element structure to all lanes);
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD3 (single 3-element structure to all lanes);
            if index_align<1:0> != '00' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD3 (single 3-element structure to all lanes);
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD3 (single 3-element structure to all lanes);
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD3 (single 3-element structure to all lanes);
            if index_align<1:0> != '00' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];
            Elem[D[d], index] = MemU[address,ebytes];
            Elem[D[d2],index] = MemU[address+ebytes,ebytes];
            Elem[D[d3],index] = MemU[address+2*ebytes,ebytes];
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 3*ebytes;

__instruction aarch32_SXTB_A
    __encoding aarch32_SXTB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 10101111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTB_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rd 0 +: 3
        __opcode '10110010 01xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

    __encoding aarch32_SXTB_T2_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 01001111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d] = SignExtend(rotated<7:0>, 32);

__instruction aarch32_VMUL_s_A
    __encoding aarch32_VMUL_s_A1_A
        __instruction_set A32
        __field Q 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx100x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMUL_s_T1_A
        __instruction_set T32
        __field Q 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field F 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx100x x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            floating_point = (F == '1');  long_destination = FALSE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                    if floating_point then
                        Elem[D[d+r],e,esize] = FPMul(op1, op2, StandardFPSCRValue());
                    else
                        if long_destination then
                            Elem[Q[d>>1],e,2*esize] = (op1val*op2val)<2*esize-1:0>;
                        else
                            Elem[D[d+r],e,esize] = (op1val*op2val)<esize-1:0>;

__instruction aarch32_STRB_r_A
    __encoding aarch32_STRB_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx011x x1x0xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE STRBT;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if t == 15 || m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_STRB_r_T1_A
        __instruction_set T16
        __field Rm 6 +: 3
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '0101010x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_STRB_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0000xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = TRUE;  add = TRUE;  wback = FALSE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if t == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if index then offset_addr else R[n];
            MemU[address,1] = R[t]<7:0>;
            if wback then R[n] = offset_addr;

__instruction aarch32_VMOV_r_A
    __encoding aarch32_VMOV_r_T2A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110000 xxxx101x 01x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            single_register = (sz == '0');  advsimd = FALSE;
            if single_register then
                d = UInt(Vd:D);  m = UInt(Vm:M);
            else
                d = UInt(D:Vd);  m = UInt(M:Vm);  regs = 1;

    __encoding aarch32_VMOV_r_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110000 xxxx101x 01x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            single_register = (sz == '0');  advsimd = FALSE;
            if single_register then
                d = UInt(Vd:D);  m = UInt(Vm:M);
            else
                d = UInt(D:Vd);  m = UInt(M:Vm);  regs = 1;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if single_register then
                S[d] = S[m];
            else
                for r = 0 to regs-1
                    D[d+r] = D[m+r];

__instruction aarch32_VQADD_A
    __encoding aarch32_VQADD_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQADD_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    sum = Int(Elem[D[n+r],e,esize], unsigned) + Int(Elem[D[m+r],e,esize], unsigned);
                    (Elem[D[d+r],e,esize], sat) = SatQ(sum, esize, unsigned);
                    if sat then FPSCR.QC = '1';

__instruction aarch32_SXTAB_A
    __encoding aarch32_SXTAB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1010xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if Rn == '1111' then SEE SXTB;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTAB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 0100xxxx 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            if Rn == '1111' then SEE SXTB;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d] = R[n] + SignExtend(rotated<7:0>, 32);

__instruction aarch32_PLD_l_A
    __encoding aarch32_PLD_l_A1_A
        __instruction_set A32
        __field U 23 +: 1
        __field imm12 0 +: 12
        __opcode '11110101 xx011111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 22 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

    __encoding aarch32_PLD_l_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field imm12 0 +: 12
        __opcode '11111000 x0x11111 1111xxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 21 == '0'
        __decode
            imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
            Hint_PreloadData(address);

__instruction aarch32_SMLAL_A
    __encoding aarch32_SMLAL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0000 111xxxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_SMLAL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1100xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = SInt(R[n]) * SInt(R[m]) + SInt(R[dHi]:R[dLo]);
            R[dHi] = result<63:32>;
            R[dLo] = result<31:0>;
            if setflags then
                PSTATE.N = result<63>;
                PSTATE.Z = IsZeroBit(result<63:0>);
                // PSTATE.C, PSTATE.V unchanged

__instruction aarch32_AESMC_A
    __encoding aarch32_AESMC_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0011 10x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_AESMC_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0011 10x0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if size != '00' then UNDEFINED;
            if Vd<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            Q[d>>1] = AESMixColumns(Q[m>>1]);

__instruction aarch32_VCVTA_vfp_A
    __encoding aarch32_VCVTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111101 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);

    __encoding aarch32_VCVTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111101 xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  unsigned = (op == '0');
            d = UInt(Vd:D);
            case size of
                when '01' esize = 16; m = UInt(Vm:M);
                when '10' esize = 32; m = UInt(Vm:M);
                when '11' esize = 64; m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = FPToFixed(S[m]<15:0>, 0, unsigned, FPSCR, rounding);
            when 32
                S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
            when 64
                S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);

__instruction aarch32_VMOVN_A
    __encoding aarch32_VMOVN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0010 00x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VMOVN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0010 00x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                Elem[D[d],e,esize] = Elem[Qin[m>>1],e,2*esize]<esize-1:0>;

__instruction aarch32_STLEXB_A
    __encoding aarch32_STLEXB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1100xxxx xxxxxx10 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STLEXB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1100xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            if AArch32.ExclusiveMonitorsPass(address,1) then
                MemO[address, 1] = R[t]<7:0>;
                R[d] = ZeroExtend('0');
            else
                R[d] = ZeroExtend('1');

__instruction aarch32_VRINTA_asimd_A
    __encoding aarch32_VRINTA_asimd_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0101 0xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VRINTA_asimd_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 3
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0101 0xx0xxxx'
        __guard TRUE
        __decode
            if op<2> != op<0> then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            // Rounding encoded differently from other VCVT and VRINT instructions
            rounding = FPDecodeRM(op<2>:NOT(op<1>));  exact = FALSE;
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckAdvSIMDEnabled();
        for r = 0 to regs-1
            for e = 0 to elements-1
                op1 = Elem[D[m+r],e,esize];
                result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
                Elem[D[d+r],e,esize] = result;

__instruction aarch32_VREV16_A
    __encoding aarch32_VREV16_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0001 0xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VREV16_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0001 0xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
        
            bits(64) result;
            integer element;
            integer rev_element;
            for r = 0 to regs-1
                element = 0;
                for c = 0 to containers-1
                    rev_element = element + elements_per_container - 1;
                    for e = 0 to elements_per_container-1
                        Elem[result, rev_element, esize] = Elem[D[m+r], element, esize];
                        element = element + 1;
                        rev_element = rev_element - 1;
                D[d+r] = result;

__instruction aarch32_VQDMULL_A
    __encoding aarch32_VQDMULL_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1101 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMULL_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 1xxxxxxx xxxx1011 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VQDMULL_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1101 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
            esize = 8 << UInt(size);  elements = 64 DIV esize;

    __encoding aarch32_VQDMULL_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 1xxxxxxx xxxx1011 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
            for e = 0 to elements-1
                if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
                op1 = SInt(Elem[Din[n],e,esize]);
                // The following only saturates if both op1 and op2 equal -(2^(esize-1))
                (product, sat) = SignedSatQ(2*op1*op2, 2*esize);
                Elem[Q[d>>1],e,2*esize] = product;
                if sat then FPSCR.QC = '1';

__instruction aarch32_LDC_i_A
    __encoding aarch32_LDC_i_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x x0x1xxxx 01011110 xxxxxxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE LDC (literal);
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            n = UInt(Rn);  cp = 14;
            imm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');

    __encoding aarch32_LDC_i_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x x0x1xxxx 01011110 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDC (literal);
            if P == '0' && U == '0' && W == '0' then UNDEFINED;
            n = UInt(Rn);  cp = 14;
            imm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            AArch32.CheckSystemAccess(cp, ThisInstr());
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
        
            // System register write to DBGDTRTXint.
            DBGDTR_EL0[] = MemA[address,4];
        
            if wback then R[n] = offset_addr;

__instruction aarch32_VINS_A
    __encoding aarch32_VINS_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x110000 xxxx1010 11x0xxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            d = UInt(Vd:D); m = UInt(Vm:M);

    __encoding aarch32_VINS_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x110000 xxxx1010 11x0xxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            d = UInt(Vd:D); m = UInt(Vm:M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            S[d] = S[m]<15:0> : S[d]<15:0>;

__instruction aarch32_AND_r_A
    __encoding aarch32_AND_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 000xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_AND_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rdn 0 +: 3
        __opcode '01000000 00xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_AND_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101010 000xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE TST (register);
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] AND shifted;
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.N = result<31>;
                    PSTATE.Z = IsZeroBit(result);
                    PSTATE.C = carry;
                    // PSTATE.V unchanged

__instruction aarch32_ORR_rr_A
    __encoding aarch32_ORR_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 100xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] OR shifted;
            R[d] = result;
            if setflags then
                PSTATE.N = result<31>;
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry;
                // PSTATE.V unchanged

__instruction aarch32_ADD_r_A
    __encoding aarch32_ADD_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 100xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1101' then SEE ADD (SP plus register);
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_ADD_r_T1_A
        __instruction_set T16
        __field Rm 6 +: 3
        __field Rn 3 +: 3
        __field Rd 0 +: 3
        __opcode '0001100x xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_ADD_r_T2_A
        __instruction_set T16
        __field DN 7 +: 1
        __field Rm 3 +: 4
        __field Rdn 0 +: 3
        __opcode '01000100 xxxxxxxx'
        __guard TRUE
        __decode
            if (DN:Rdn) == '1101' || Rm == '1101' then SEE ADD (SP plus register);
            d = UInt(DN:Rdn);  n = d;  m = UInt(Rm);  setflags = FALSE;  (shift_t, shift_n) = (SRType_LSL, 0);
            if n == 15 && m == 15 then UNPREDICTABLE;
            if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_ADD_r_T3_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 000xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            if Rd == '1111' && S == '1' then SEE CMN (register);
            if Rn == '1101' then SEE ADD (SP plus register);
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], shifted, '0');
            if d == 15 then
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_RFE_AS
    __encoding aarch32_RFE_A1_AS
        __instruction_set A32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __opcode '1111100x x0x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            n = UInt(Rn);
            wback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_RFE_T1_AS
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __opcode '11101000 00x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            n = UInt(Rn);  wback = (W == '1');  increment = FALSE;  wordhigher = FALSE;
            if n == 15 then UNPREDICTABLE;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_RFE_T2_AS
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __opcode '11101001 10x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            n = UInt(Rn);  wback = (W == '1');  increment = TRUE;  wordhigher = FALSE;
            if n == 15 then UNPREDICTABLE;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if PSTATE.EL == EL2 then
                UNDEFINED;
            elsif PSTATE.EL == EL0 then
                UNPREDICTABLE;                        // UNDEFINED or NOP
            else
                address = if increment then R[n] else R[n]-8;
                if wordhigher then address = address+4;
                new_pc_value = MemA[address,4];
                spsr = MemA[address+4,4];
                if wback then R[n] = if increment then R[n]+8 else R[n]-8;
                AArch32.ExceptionReturn(new_pc_value, spsr);

__instruction aarch32_UQSAX_A
    __encoding aarch32_UQSAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQSAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum  = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);
            diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);
            R[d]<15:0>  = UnsignedSat(sum, 16);
            R[d]<31:16> = UnsignedSat(diff, 16);

__instruction aarch32_VQSHL_i_A
    __encoding aarch32_VQSHL_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx011x xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VQSHL_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx011x xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if U == '0' && op == '0' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
            src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    operand = Int(Elem[D[m+r],e,esize], src_unsigned);
                    (result, sat) = SatQ(operand << shift_amount, esize, dest_unsigned);
                    Elem[D[d+r],e,esize] = result;
                    if sat then FPSCR.QC = '1';

__instruction aarch32_SMMLA_A
    __encoding aarch32_SMMLA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field R 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0101xxxx xxxxxxxx 00x1xxxx'
        __guard cond != '1111'
        __decode
            if Ra == '1111' then SEE SMMUL;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SMMLA_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field R 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0101xxxx xxxxxxxx 000xxxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE SMMUL;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = (SInt(R[a]) << 32) + SInt(R[n]) * SInt(R[m]);
            if round then result = result + 0x80000000;
            R[d] = result<63:32>;

__instruction aarch32_ADD_i_A
    __encoding aarch32_ADD_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 100xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' && S == '0' then SEE ADR;
            if Rn == '1101' then SEE ADD (SP plus immediate);
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_ADD_i_T1_A
        __instruction_set T16
        __field imm3 6 +: 3
        __field Rn 3 +: 3
        __field Rd 0 +: 3
        __opcode '0001110x xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm3, 32);

    __encoding aarch32_ADD_i_T2_A
        __instruction_set T16
        __field Rdn 8 +: 3
        __field imm8 0 +: 8
        __opcode '00110xxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm8, 32);

    __encoding aarch32_ADD_i_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 000xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE CMN (immediate);
            if Rn == '1101' then SEE ADD (SP plus immediate);
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_ADD_i_T4_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 0000xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE ADR;
            if Rn == '1101' then SEE ADD (SP plus immediate);
            d = UInt(Rd);  n = UInt(Rn);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
            if d == 15 then UNPREDICTABLE;   // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if ConditionPassed() then
                EncodingSpecificOperations();
                (result, nzcv) = AddWithCarry(R[n], imm32, '0');
                if d == 15 then          // Can only occur for A32 encoding
                    if setflags then
                        ALUExceptionReturn(result);
                    else
                        ALUWritePC(result);
                else
                    R[d] = result;
                    if setflags then
                        PSTATE.<N,Z,C,V> = nzcv;
        else
            if ConditionPassed() then
                EncodingSpecificOperations();
                (result, nzcv) = AddWithCarry(R[n], imm32, '0');
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_SHA256H_A
    __encoding aarch32_SHA256H_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x00xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA256H_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x00xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            X = Q[d>>1]; Y = Q[n>>1]; W = Q[m>>1]; part1 = TRUE;
            Q[d>>1] = SHA256hash(X, Y, W, part1);

__instruction aarch32_VMAX_i_A
    __encoding aarch32_VMAX_i_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAX_i_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field op 4 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            maximum = (op == '0');  unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Int(Elem[D[n+r],e,esize], unsigned);
                    op2 = Int(Elem[D[m+r],e,esize], unsigned);
                    result = if maximum then Max(op1,op2) else Min(op1,op2);
                    Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_UQSUB16_A
    __encoding aarch32_UQSUB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQSUB16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1101xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);
            diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);
            R[d]<15:0>  = UnsignedSat(diff1, 16);
            R[d]<31:16> = UnsignedSat(diff2, 16);

__instruction aarch32_LDA_A
    __encoding aarch32_LDA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1001xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDA_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1010xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            R[t] = MemO[address, 4];

__instruction aarch32_VCGT_r_A
    __encoding aarch32_VCGT_r_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx0011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            type1 = if U == '1' then VCGTtype_unsigned else VCGTtype_signed;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGT_r_A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x1xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            type1 = VCGTtype_fp;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGT_r_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx0011 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            type1 = if U == '1' then VCGTtype_unsigned else VCGTtype_signed;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGT_r_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x1xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            type1 = VCGTtype_fp;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        enumeration VCGTtype {VCGTtype_signed, VCGTtype_unsigned, VCGTtype_fp};
        
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                    case type1 of
                        when VCGTtype_signed    test_passed = (SInt(op1) > SInt(op2));
                        when VCGTtype_unsigned  test_passed = (UInt(op1) > UInt(op2));
                        when VCGTtype_fp        test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());
                    Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_VST2_1_A
    __encoding aarch32_VST2_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST2_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST2_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx1001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST2_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST2_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST2_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx1001 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = TRUE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            MemU[address,       ebytes] = Elem[D[d], index];
            MemU[address+ebytes,ebytes] = Elem[D[d2],index];
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 2*ebytes;

__instruction aarch32_VLD2_a_A
    __encoding aarch32_VLD2_a_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 1 << UInt(size);
            alignment = if a == '0' then 1 else 2*ebytes;
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD2_a_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1101 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            ebytes = 1 << UInt(size);
            alignment = if a == '0' then 1 else 2*ebytes;
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = FALSE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            D[d] = Replicate(MemU[address,ebytes]);
            D[d2] = Replicate(MemU[address+ebytes,ebytes]);
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 2*ebytes;

__instruction aarch32_VCLT_i_A
    __encoding aarch32_VCLT_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x10 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCLT_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x10 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if floating_point then
                        bits(esize) zero = FPZero('0');
                        test_passed = FPCompareGT(zero, Elem[D[m+r],e,esize], StandardFPSCRValue());
                    else
                        test_passed = (SInt(Elem[D[m+r],e,esize]) < 0);
                    Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_VREV16_A
    __encoding aarch32_VREV16_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0000 1xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VREV16_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0000 1xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
        
            bits(64) result;
            integer element;
            integer rev_element;
            for r = 0 to regs-1
                element = 0;
                for c = 0 to containers-1
                    rev_element = element + elements_per_container - 1;
                    for e = 0 to elements_per_container-1
                        Elem[result, rev_element, esize] = Elem[D[m+r], element, esize];
                        element = element + 1;
                        rev_element = rev_element - 1;
                D[d+r] = result;

__instruction aarch32_STRD_i_A
    __encoding aarch32_STRD_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x0xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __decode
            if Rt<0> == '1' then UNPREDICTABLE;
            t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if P == '0' && W == '1' then UNPREDICTABLE;
            if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;
            if t2 == 15 then UNPREDICTABLE;

    __encoding aarch32_STRD_i_T1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rt2 8 +: 4
        __field imm8 0 +: 8
        __opcode '1110100x x1x0xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && W == '0' then SEE "Related encodings";
            t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if wback && (n == t || n == t2) then UNPREDICTABLE;
            if n == 15 || t == 15 || t2 == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            if address == Align(address, 8) then
                bits(64) data;
                if BigEndian() then
                    data<63:32> = R[t];
                    data<31:0> = R[t2];
                else
                    data<31:0> = R[t];
                    data<63:32> = R[t2];
                MemA[address,8] = data;
            else
                MemA[address,4] = R[t];
                MemA[address+4,4] = R[t2];
            if wback then R[n] = offset_addr;

__instruction aarch32_STREXB_A
    __encoding aarch32_STREXB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1100xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STREXB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 0 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 0100xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13
            if d == n || d == t then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            if AArch32.ExclusiveMonitorsPass(address,1) then
                MemA[address,1] = R[t]<7:0>;
                R[d] = ZeroExtend('0');
            else
                R[d] = ZeroExtend('1');

__instruction aarch32_ESB_A
    __encoding aarch32_ESB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00010000'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            if cond != '1110' then UNPREDICTABLE;  // ESB must be encoded with AL condition

    __encoding aarch32_ESB_T1_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00010000'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
        
            ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);
            AArch32.ESBOperation();
            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch32.vESBOperation();
            TakeUnmaskedSErrorInterrupts();

__instruction aarch32_VADDL_A
    __encoding aarch32_VADDL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0001 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VADDL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0001 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                if is_vaddw then
                    op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
                else
                    op1 = Int(Elem[Din[n],e,esize], unsigned);
                result = op1 + Int(Elem[Din[m],e,esize],unsigned);
                Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_VREV16_A
    __encoding aarch32_VREV16_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0000 0xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VREV16_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0000 0xx0xxxx'
        __guard TRUE
        __decode
            if UInt(op)+UInt(size) >= 3 then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            
            esize = 8 << UInt(size);
            integer container_size;
            case op of
                when '10' container_size = 16;
                when '01' container_size = 32;
                when '00' container_size = 64;
            integer containers = 64 DIV container_size;
            integer elements_per_container = container_size DIV esize;
            
            d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
        
            bits(64) result;
            integer element;
            integer rev_element;
            for r = 0 to regs-1
                element = 0;
                for c = 0 to containers-1
                    rev_element = element + elements_per_container - 1;
                    for e = 0 to elements_per_container-1
                        Elem[result, rev_element, esize] = Elem[D[m+r], element, esize];
                        element = element + 1;
                        rev_element = rev_element - 1;
                D[d+r] = result;

__instruction aarch32_LDRSB_i_A
    __encoding aarch32_LDRSB_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x1xxxx xxxxxxxx 1101xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE LDRSB (literal);
            if P == '0' && W == '1' then SEE LDRSBT;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || (wback && n == t) then UNPREDICTABLE;

    __encoding aarch32_LDRSB_i_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111001 1001xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE PLI;
            if Rn == '1111' then SEE LDRSB (literal);
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = TRUE;  add = TRUE;  wback = FALSE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_LDRSB_i_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111001 0001xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE PLI;
            if Rn == '1111' then SEE LDRSB (literal);
            if P == '1' && U == '1' && W == '0' then SEE LDRSBT;
            if P == '0' && W == '0' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
            index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
            address = if index then offset_addr else R[n];
            R[t] = SignExtend(MemU[address,1], 32);
            if wback then R[n] = offset_addr;

__instruction aarch32_IT_A
    __encoding aarch32_IT_T1_A
        __instruction_set T16
        __field firstcond 4 +: 4
        __field mask 0 +: 4
        __opcode '10111111 xxxxxxxx'
        __guard TRUE
        __decode
            if mask == '0000' then SEE "Related encodings";
            if firstcond == '1111' || (firstcond == '1110' && BitCount(mask) != 1) then UNPREDICTABLE;
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations();
        AArch32.CheckITEnabled(mask);
        PSTATE.IT<7:0> = firstcond:mask;

__instruction aarch32_VCMP_A
    __encoding aarch32_VCMP_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110100 xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VCMP_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __opcode 'xxxx1110 1x110101 xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D);
                when '10' esize = 32; d = UInt(Vd:D);
                when '11' esize = 64; d = UInt(D:Vd);

    __encoding aarch32_VCMP_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110100 xxxx10xx 11x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VCMP_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field E 7 +: 1
        __opcode '11101110 1x110101 xxxx10xx 11x0xxxx'
        __guard TRUE
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            quiet_nan_exc = (E == '1');  with_zero = TRUE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D);
                when '10' esize = 32; d = UInt(Vd:D);
                when '11' esize = 64; d = UInt(D:Vd);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            case esize of
                when 16
                    bits(16) op16 = if with_zero then FPZero('0') else S[m]<15:0>;
                    FPSCR.<N,Z,C,V> = FPCompare(S[d]<15:0>, op16, quiet_nan_exc, FPSCR);
                when 32
                    bits(32) op32 = if with_zero then FPZero('0') else S[m];
                    FPSCR.<N,Z,C,V> = FPCompare(S[d], op32, quiet_nan_exc, FPSCR);
                when 64
                    bits(64) op64 = if with_zero then FPZero('0') else D[m];
                    FPSCR.<N,Z,C,V> = FPCompare(D[d], op64, quiet_nan_exc, FPSCR);

__instruction aarch32_VRINTA_vfp_A
    __encoding aarch32_VRINTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111011 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111011 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_LDAB_A
    __encoding aarch32_LDAB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1101xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1000xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            R[t] = ZeroExtend(MemO[address, 1], 32);

__instruction aarch32_VCLS_A
    __encoding aarch32_VCLS_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0100 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCLS_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0100 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = CountLeadingSignBits(Elem[D[m+r],e,esize])<esize-1:0>;

__instruction aarch32_WFE_A
    __encoding aarch32_WFE_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000010'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_WFE_T1_A
        __instruction_set T16
        __opcode '10111111 00100000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_WFE_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000010'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if IsEventRegisterSet() then
                ClearEventRegister();
            else
                if PSTATE.EL == EL0 then
                    // Check for traps described by the OS which may be EL1 or EL2.
                    AArch32.CheckForWFxTrap(EL1, TRUE);
                if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                    // Check for traps described by the Hypervisor.
                    AArch32.CheckForWFxTrap(EL2, TRUE);
                if HaveEL(EL3) && PSTATE.M != M32_Monitor then
                    // Check for traps described by the Secure Monitor.
                    AArch32.CheckForWFxTrap(EL3, TRUE);
                WaitForEvent();

__instruction aarch32_LDMDB_A
    __encoding aarch32_LDMDB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1001 00x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;

    __encoding aarch32_LDMDB_T1_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field P 15 +: 1
        __field M 14 +: 1
        __field register_list 0 +: 14
        __opcode '11101001 00x1xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 13 == '0'
        __decode
            n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 2 || (P == '1' && M == '1') then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;
            if registers<13> == '1' then UNPREDICTABLE;
            if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n] - 4*BitCount(registers);
            for i = 0 to 14
                if registers<i> == '1' then
                    R[i] = MemA[address,4];  address = address + 4;
            if registers<15> == '1' then
                LoadWritePC(MemA[address,4]);
            if wback && registers<n> == '0' then R[n] = R[n] - 4*BitCount(registers);
            if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;

__instruction aarch32_BL_i_A
    __encoding aarch32_BL_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm24 0 +: 24
        __opcode 'xxxx1011 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            imm32 = SignExtend(imm24:'00', 32);  targetInstrSet = InstrSet_A32;

    __encoding aarch32_BL_i_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field H 24 +: 1
        __field imm24 0 +: 24
        __opcode '1111101x xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            imm32 = SignExtend(imm24:H:'0', 32);  targetInstrSet = InstrSet_T32;

    __encoding aarch32_BL_i_T1_A
        __instruction_set T32
        __field S 26 +: 1
        __field imm10 16 +: 10
        __field J1 13 +: 1
        __field J2 11 +: 1
        __field imm11 0 +: 11
        __opcode '11110xxx xxxxxxxx 11x1xxxx xxxxxxxx'
        __guard TRUE
        __decode
            I1 = NOT(J1 EOR S);  I2 = NOT(J2 EOR S);  imm32 = SignExtend(S:I1:I2:imm10:imm11:'0', 32);
            targetInstrSet = InstrSet_T32;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_BL_i_T2_A
        __instruction_set T32
        __field S 26 +: 1
        __field imm10H 16 +: 10
        __field J1 13 +: 1
        __field J2 11 +: 1
        __field imm10L 1 +: 10
        __field H 0 +: 1
        __opcode '11110xxx xxxxxxxx 11x0xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if H == '1' then UNDEFINED;
            I1 = NOT(J1 EOR S);  I2 = NOT(J2 EOR S);  imm32 = SignExtend(S:I1:I2:imm10H:imm10L:'00', 32);
            targetInstrSet = InstrSet_A32;
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if CurrentInstrSet() == InstrSet_A32 then
                LR = PC - 4;
            else
                LR = PC<31:1> : '1';
            if targetInstrSet == InstrSet_A32 then
                targetAddress = Align(PC,4) + imm32;
            else
                targetAddress = PC + imm32;
            SelectInstrSet(targetInstrSet);
            BranchWritePC(targetAddress);

__instruction aarch32_VSHLL_A
    __encoding aarch32_VSHLL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx1010 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
            if shift_amount == 0 then SEE VMOVL;
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VSHLL_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0011 00x0xxxx'
        __guard TRUE
        __decode
            if size == '11' || Vd<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;  shift_amount = esize;
            unsigned = FALSE;  // Or TRUE without change of functionality
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VSHLL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx1010 00x1xxxx'
        __guard TRUE
        __decode
            if imm6 == '000xxx' then SEE "Related encodings";
            if Vd<0> == '1' then UNDEFINED;
            case imm6 of
                when '001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
                when '01xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
                when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
            if shift_amount == 0 then SEE VMOVL;
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VSHLL_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0011 00x0xxxx'
        __guard TRUE
        __decode
            if size == '11' || Vd<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;  shift_amount = esize;
            unsigned = FALSE;  // Or TRUE without change of functionality
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                result = Int(Elem[Din[m],e,esize], unsigned) << shift_amount;
                Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_VFMA_A
    __encoding aarch32_VFMA_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x1xxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            advsimd = TRUE; op1_neg = (op == '1');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VFMA_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x10xxxx xxxx10xx x1x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            advsimd = FALSE; op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VFMA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x1xxxxx xxxx1100 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            advsimd = TRUE; op1_neg = (op == '1');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VFMA_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x10xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            advsimd = FALSE; op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if advsimd then // Advanced SIMD instruction
                for r = 0 to regs-1
                    for e = 0 to elements-1
                        bits(esize) op1 = Elem[D[n+r],e,esize];
                        if op1_neg then op1 = FPNeg(op1);
                        Elem[D[d+r],e,esize] = FPMulAdd(Elem[D[d+r],e,esize],
                                               op1, Elem[D[m+r],e,esize], StandardFPSCRValue());
        
            else // VFP instruction
                case esize of
                    when 16
                        op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;
                        S[d] = Zeros(16) : FPMulAdd(S[d]<15:0>, op16, S[m]<15:0>, FPSCR);
                    when 32
                        op32 = if op1_neg then FPNeg(S[n]) else S[n];
                        S[d] = FPMulAdd(S[d], op32, S[m], FPSCR);
                    when 64
                        op64 = if op1_neg then FPNeg(D[n]) else D[n];
                        D[d] = FPMulAdd(D[d], op64, D[m], FPSCR);

__instruction aarch32_PLI_r_A
    __encoding aarch32_PLI_r_A1_A
        __instruction_set A32
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode '11110110 x101xxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  add = (U == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if m == 15 then UNPREDICTABLE;

    __encoding aarch32_PLI_r_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0001xxxx 11110000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE PLI (immediate, literal);
            n = UInt(Rn);  m = UInt(Rm);  add = TRUE;
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            address = if add then (R[n] + offset) else (R[n] - offset);
            Hint_PreloadInstr(address);

__instruction aarch32_DSB_A
    __encoding aarch32_DSB_A1_A
        __instruction_set A32
        __field option 0 +: 4
        __opcode '11110101 0111xxxx xxxxxxxx 0100xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_DSB_T1_A
        __instruction_set T32
        __field option 0 +: 4
        __opcode '11110011 1011xxxx 10x0xxxx 0100xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            // No additional decoding required

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            case option of
                when '0001'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Reads;
                when '0010'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Writes;
                when '0011'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_All;
                when '0101'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Reads;
                when '0110'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Writes;
                when '0111'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_All;
                when '1001'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Reads;
                when '1010'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Writes;
                when '1011'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_All;
                when '1101'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Reads;
                when '1110'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Writes;
                otherwise    domain = MBReqDomain_FullSystem;      types = MBReqTypes_All;
        
            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1}  then
                if HCR.BSU == '11' then
                    domain = MBReqDomain_FullSystem;
                if HCR.BSU == '10' && domain != MBReqDomain_FullSystem then
                    domain = MBReqDomain_OuterShareable;
                if HCR.BSU == '01' && domain == MBReqDomain_Nonshareable then
                    domain = MBReqDomain_InnerShareable;
        
            DataSynchronizationBarrier(domain, types);

__instruction aarch32_LDAH_A
    __encoding aarch32_LDAH_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode 'xxxx0001 1111xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_LDAH_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1101xxxx xxxxxxxx 1001xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt);  n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            R[t] = ZeroExtend(MemO[address, 2], 32);

__instruction aarch32_VTST_A
    __encoding aarch32_VTST_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0xxxxxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VTST_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0xxxxxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if !IsZero(Elem[D[n+r],e,esize] AND Elem[D[m+r],e,esize]) then
                        Elem[D[d+r],e,esize] = Ones(esize);
                    else
                        Elem[D[d+r],e,esize] = Zeros(esize);

__instruction aarch32_VTRN_A
    __encoding aarch32_VTRN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0000 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VTRN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0000 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            h = elements DIV 2;
        
            for r = 0 to regs-1
                if d == m then
                    D[d+r] = bits(64) UNKNOWN;
                else
                    for e = 0 to h-1
                        Elem[D[d+r],2*e+1,esize] = Elem[Din[m+r],2*e,esize];
                        Elem[D[m+r],2*e,esize] = Elem[Din[d+r],2*e+1,esize];

__instruction aarch32_VMOV_s_A
    __encoding aarch32_VMOV_s_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field op 20 +: 1
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __opcode 'xxxx1110 000xxxxx xxxx1010 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMOV_s_T1_A
        __instruction_set T32
        __field op 20 +: 1
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __opcode '11101110 000xxxxx xxxx1010 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            if to_arm_register then
                R[t] = S[n];
            else
                S[n] = R[t];

__instruction aarch32_RBIT_A
    __encoding aarch32_RBIT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 1111xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  m = UInt(Rm);
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_RBIT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 1010xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
            if m != n || d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            bits(32) result;
            for i = 0 to 31
                result<31-i> = R[m]<i>;
            R[d] = result;

__instruction aarch32_VLD3_a_A
    __encoding aarch32_VLD3_a_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || a == '1' then UNDEFINED;
            ebytes = 1 << UInt(size);
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD3_a_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field T 5 +: 1
        __field a 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if size == '11' || a == '1' then UNDEFINED;
            ebytes = 1 << UInt(size);
            inc = if T == '0' then 1 else 2;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];
            D[d] = Replicate(MemU[address,ebytes]);
            D[d2] = Replicate(MemU[address+ebytes,ebytes]);
            D[d3] = Replicate(MemU[address+2*ebytes,ebytes]);
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 3*ebytes;

__instruction aarch32_STLB_A
    __encoding aarch32_STLB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1100xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_STLB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1000xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            MemO[address, 1] = R[t]<7:0>;

__instruction aarch32_VAND_r_A
    __encoding aarch32_VAND_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x00xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VAND_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x00xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                D[d+r] = D[n+r] AND D[m+r];

__instruction aarch32_VCVT_ds_A
    __encoding aarch32_VCVT_ds_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110111 xxxx101x 11x0xxxx'
        __guard cond != '1111'
        __decode
            double_to_single = (sz == '1');
            d = if double_to_single then UInt(Vd:D) else UInt(D:Vd);
            m = if double_to_single then UInt(M:Vm) else UInt(Vm:M);

    __encoding aarch32_VCVT_ds_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110111 xxxx101x 11x0xxxx'
        __guard TRUE
        __decode
            double_to_single = (sz == '1');
            d = if double_to_single then UInt(Vd:D) else UInt(D:Vd);
            m = if double_to_single then UInt(M:Vm) else UInt(Vm:M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            if double_to_single then
                S[d] = FPConvert(D[m], FPSCR);
            else
                D[d] = FPConvert(S[m], FPSCR);

__instruction aarch32_CMP_r_A
    __encoding aarch32_CMP_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0101xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_CMP_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rn 0 +: 3
        __opcode '01000010 10xxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_CMP_r_T2_A
        __instruction_set T16
        __field N 7 +: 1
        __field Rm 3 +: 4
        __field Rn 0 +: 3
        __opcode '01000101 xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(N:Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, 0);
            if n < 8 && m < 8 then UNPREDICTABLE;
            if n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_CMP_r_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 1011xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VMOVL_A
    __encoding aarch32_VMOVL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm3H 19 +: 3
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxx000 xxxx1010 00x1xxxx'
        __guard TRUE
        __decode
            if imm3H == '000' then SEE "Related encodings";
            if imm3H != '001' && imm3H != '010' && imm3H != '100' then SEE VSHLL;
            if Vd<0> == '1' then UNDEFINED;
            esize = 8 * UInt(imm3H);
            unsigned = (U == '1');  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VMOVL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm3H 19 +: 3
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxx000 xxxx1010 00x1xxxx'
        __guard TRUE
        __decode
            if imm3H == '000' then SEE "Related encodings";
            if imm3H != '001' && imm3H != '010' && imm3H != '100' then SEE VSHLL;
            if Vd<0> == '1' then UNDEFINED;
            esize = 8 * UInt(imm3H);
            unsigned = (U == '1');  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                result = Int(Elem[Din[m],e,esize], unsigned);
                Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_SBC_rr_A
    __encoding aarch32_SBC_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 110xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], NOT(shifted), PSTATE.C);
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_DMB_A
    __encoding aarch32_DMB_A1_A
        __instruction_set A32
        __field option 0 +: 4
        __opcode '11110101 0111xxxx xxxxxxxx 0101xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_DMB_T1_A
        __instruction_set T32
        __field option 0 +: 4
        __opcode '11110011 1011xxxx 10x0xxxx 0101xxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            // No additional decoding required

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            case option of
                when '0001'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Reads;
                when '0010'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Writes;
                when '0011'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_All;
                when '0101'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Reads;
                when '0110'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Writes;
                when '0111'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_All;
                when '1001'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Reads;
                when '1010'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Writes;
                when '1011'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_All;
                when '1101'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Reads;
                when '1110'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Writes;
                otherwise    domain = MBReqDomain_FullSystem;      types = MBReqTypes_All;
        
            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then
                if HCR.BSU == '11' then
                    domain = MBReqDomain_FullSystem;
                if HCR.BSU == '10' && domain != MBReqDomain_FullSystem then
                    domain = MBReqDomain_OuterShareable;
                if HCR.BSU == '01' && domain == MBReqDomain_Nonshareable then
                    domain = MBReqDomain_InnerShareable;
        
            DataMemoryBarrier(domain, types);

__instruction aarch32_SBC_r_A
    __encoding aarch32_SBC_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 110xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_SBC_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rdn 0 +: 3
        __opcode '01000001 10xxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_SBC_r_T2_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 011xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], NOT(shifted), PSTATE.C);
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VCVT_hs_A
    __encoding aarch32_VCVT_hs_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx011x 00x0xxxx'
        __guard TRUE
        __decode
            if size != '01' then UNDEFINED;
            half_to_single = (op == '1');
            if half_to_single && Vd<0> == '1' then UNDEFINED;
            if !half_to_single && Vm<0> == '1' then UNDEFINED;
            esize = 16;  elements = 4;
            m = UInt(M:Vm);  d = UInt(D:Vd);

    __encoding aarch32_VCVT_hs_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx011x 00x0xxxx'
        __guard TRUE
        __decode
            if size != '01' then UNDEFINED;
            half_to_single = (op == '1');
            if half_to_single && Vd<0> == '1' then UNDEFINED;
            if !half_to_single && Vm<0> == '1' then UNDEFINED;
            esize = 16;  elements = 4;
            m = UInt(M:Vm);  d = UInt(D:Vd);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                if half_to_single then
                    Elem[Q[d>>1],e,32] = FPConvert(Elem[Din[m],e,16], StandardFPSCRValue());
                else
                    Elem[D[d],e,16] = FPConvert(Elem[Qin[m>>1],e,32], StandardFPSCRValue());

__instruction aarch32_VLDR_A
    __encoding aarch32_VLDR_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode 'xxxx1101 xx01xxxx xxxx10xx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);

    __encoding aarch32_VLDR_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode '11101101 xx01xxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            base = if n == 15 then Align(PC,4) else R[n];
            address = if add then (base + imm32) else (base - imm32);
            case esize of
                when 16
                    S[d] = Zeros(16) : MemA[address,2];
                when 32
                    S[d] = MemA[address,4];
                when 64
                    word1 = MemA[address,4];  word2 = MemA[address+4,4];
                    // Combine the word-aligned words in the correct order for current endianness.
                    D[d] = if BigEndian() then word1:word2 else word2:word1;

__instruction aarch32_VRINTZ_vfp_A
    __encoding aarch32_VRINTZ_vfp_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110110 xxxx10xx 11x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
            exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTZ_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field op 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110110 xxxx10xx 11x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
            exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
            case esize of
                when 16
                    S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
                when 32
                    S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
                when 64
                    D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_VSTM_A
    __encoding aarch32_VSTM_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx0xxxx xxxx1011 xxxxxxx0'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VSTR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VSTM_T2A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode 'xxxx110x xxx0xxxx xxxx1010 xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VSTR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = TRUE;  add = (U == '1');  wback = (W == '1');  d = UInt(Vd:D);  n = UInt(Rn);
            imm32 = ZeroExtend(imm8:'00', 32);  regs = UInt(imm8);
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;

    __encoding aarch32_VSTM_T1A1_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx0xxxx xxxx1011 xxxxxxx0'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VSTR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
            d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
            if imm8<0> == '1' && (d+regs) > 16 then UNPREDICTABLE;

    __encoding aarch32_VSTM_T2A2_A
        __instruction_set T32
        __field P 24 +: 1
        __field U 23 +: 1
        __field D 22 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field imm8 0 +: 8
        __opcode '1110110x xxx0xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
            if P == '1' && W == '0' then SEE VSTR;
            if P == U && W == '1' then UNDEFINED;
            // Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
            single_regs = TRUE;  add = (U == '1');  wback = (W == '1');  d = UInt(Vd:D);  n = UInt(Rn);
            imm32 = ZeroExtend(imm8:'00', 32);  regs = UInt(imm8);
            if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
            if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            address = if add then R[n] else R[n]-imm32;
            for r = 0 to regs-1
                if single_regs then
                    MemA[address,4] = S[d+r];  address = address+4;
                else
                    // Store as two word-aligned words in the correct order for current endianness.
                    MemA[address,4] = if BigEndian() then D[d+r]<63:32> else D[d+r]<31:0>;
                    MemA[address+4,4] = if BigEndian() then D[d+r]<31:0> else D[d+r]<63:32>;
                    address = address+8;
            if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;

__instruction aarch32_SXTB16_A
    __encoding aarch32_SXTB16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field rotate 10 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 10001111 xxxxxxxx 0111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SXTB16_T1_A
        __instruction_set T32
        __field Rd 8 +: 4
        __field rotate 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111010 00101111 1111xxxx 1xxxxxxx'
        __guard TRUE
        __unpredictable_unless 6 == '0'
        __decode
            d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
            if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            rotated = ROR(R[m], rotation);
            R[d]<15:0>  = SignExtend(rotated<7:0>, 16);
            R[d]<31:16> = SignExtend(rotated<23:16>, 16);

__instruction aarch32_PLD_r_A
    __encoding aarch32_PLD_r_A1_A
        __instruction_set A32
        __field U 23 +: 1
        __field R 22 +: 1
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode '11110111 xx01xxxx xxxxxxxx xxx0xxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  add = (U == '1');  is_pldw = (R == '0');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if m == 15 || (n == 15 && is_pldw) then UNPREDICTABLE;

    __encoding aarch32_PLD_r_T1_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 00x1xxxx 11110000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE PLD (literal);
            n = UInt(Rn);  m = UInt(Rm);  add = TRUE;  is_pldw = (W == '1');
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
            address = if add then (R[n] + offset) else (R[n] - offset);
            if is_pldw then
                Hint_PreloadDataForWrite(address);
            else
                Hint_PreloadData(address);

__instruction aarch32_WFI_A
    __encoding aarch32_WFI_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __opcode 'xxxx0011 00100000 xxxxxxxx 00000011'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 9 == '0'
        __unpredictable_unless 8 == '0'
        __decode
            // No additional decoding required

    __encoding aarch32_WFI_T1_A
        __instruction_set T16
        __opcode '10111111 00110000'
        __guard TRUE
        __decode
            // No additional decoding required

    __encoding aarch32_WFI_T2_A
        __instruction_set T32
        __opcode '11110011 1010xxxx 10x0x000 00000011'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 11 == '0'
        __decode
            // No additional decoding required

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if !InterruptPending() then
                if PSTATE.EL == EL0 then
                    // Check for traps described by the OS which may be EL1 or EL2.
                    AArch32.CheckForWFxTrap(EL1, FALSE);
                if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then
                    // Check for traps described by the Hypervisor.
                    AArch32.CheckForWFxTrap(EL2, FALSE);
                if HaveEL(EL3) && PSTATE.M != M32_Monitor then
                    // Check for traps described by the Secure Monitor.
                    AArch32.CheckForWFxTrap(EL3, FALSE);
                WaitForInterrupt();

__instruction aarch32_VST3_m_A
    __encoding aarch32_VST3_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x00xxxx xxxx010x xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' || align<1> == '1' then UNDEFINED;
            case type1 of
                when '0100'
                    inc = 1;
                when '0101'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            alignment = if align<0> == '0' then 1 else 8;
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST3_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x00xxxx xxxx010x xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' || align<1> == '1' then UNDEFINED;
            case type1 of
                when '0100'
                    inc = 1;
                when '0101'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            alignment = if align<0> == '0' then 1 else 8;
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d3 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = TRUE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            for e = 0 to elements-1
                MemU[address,         ebytes] = Elem[D[d], e];
                MemU[address+ebytes,  ebytes] = Elem[D[d2],e];
                MemU[address+2*ebytes,ebytes] = Elem[D[d3],e];
                address = address + 3*ebytes;
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 24;

__instruction aarch32_SSAT16_A
    __encoding aarch32_SSAT16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sat_imm 16 +: 4
        __field Rd 12 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0110 1010xxxx xxxxxxxx 0011xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_SSAT16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field sat_imm 0 +: 4
        __opcode '11110x11 0010xxxx 0000xxxx 00xxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __unpredictable_unless 4 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
            if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result1, sat1) = SignedSatQ(SInt(R[n]<15:0>), saturate_to);
            (result2, sat2) = SignedSatQ(SInt(R[n]<31:16>), saturate_to);
            R[d]<15:0> = SignExtend(result1, 16);
            R[d]<31:16> = SignExtend(result2, 16);
            if sat1 || sat2 then
                PSTATE.Q = '1';

__instruction aarch32_VPMAX_f_A
    __encoding aarch32_VPMAX_f_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x0xxxxx xxxx1111 x0x0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPMAX_f_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x0xxxxx xxxx1111 x0x0xxxx'
        __guard TRUE
        __decode
            if Q == '1' then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            maximum = (op == '0');
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            bits(64) dest;
            h = elements DIV 2;
        
            for e = 0 to h-1
                op1 = Elem[D[n],2*e,esize];  op2 = Elem[D[n],2*e+1,esize];
                Elem[dest,e,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());
                op1 = Elem[D[m],2*e,esize];  op2 = Elem[D[m],2*e+1,esize];
                Elem[dest,e+h,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());
        
            D[d] = dest;

__instruction aarch32_SMLALD_A
    __encoding aarch32_SMLALD_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field RdHi 16 +: 4
        __field RdLo 12 +: 4
        __field Rm 8 +: 4
        __field M 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0100xxxx xxxxxxxx 00x1xxxx'
        __guard cond != '1111'
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            if dHi == dLo then UNPREDICTABLE;

    __encoding aarch32_SMLALD_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field RdLo 12 +: 4
        __field RdHi 8 +: 4
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 1100xxxx xxxxxxxx 110xxxxx'
        __guard TRUE
        __decode
            dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
            if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13
            if dHi == dLo then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand2 = if m_swap then ROR(R[m],16) else R[m];
            product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
            product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
            result = product1 + product2 + SInt(R[dHi]:R[dLo]);
            R[dHi] = result<63:32>;
            R[dLo] = result<31:0>;

__instruction aarch32_STREX_A
    __encoding aarch32_STREX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1000xxxx xxxxxx11 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);  imm32 = Zeros(32); // Zero offset
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
            if d == n || d == t then UNPREDICTABLE;

    __encoding aarch32_STREX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11101000 0100xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
            if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13
            if d == n || d == t then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n] + imm32;
            if AArch32.ExclusiveMonitorsPass(address,4) then
                MemA[address,4] = R[t];
                R[d] = ZeroExtend('0');
            else
                R[d] = ZeroExtend('1');

__instruction aarch32_UQSUB8_A
    __encoding aarch32_UQSUB8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQSUB8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1100xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);
            diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);
            diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);
            diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);
            R[d]<7:0>   = UnsignedSat(diff1, 8);
            R[d]<15:8>  = UnsignedSat(diff2, 8);
            R[d]<23:16> = UnsignedSat(diff3, 8);
            R[d]<31:24> = UnsignedSat(diff4, 8);

__instruction aarch32_MCRR_A
    __encoding aarch32_MCRR_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc1 4 +: 4
        __field CRm 0 +: 4
        __opcode 'xxxx1100 0100xxxx xxxx111x xxxxxxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15 || t2 == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_MCRR_T1A1_A
        __instruction_set T32
        __field Rt2 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc1 4 +: 4
        __field CRm 0 +: 4
        __opcode '11101100 0100xxxx xxxx111x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc<0> == '0' then 14 else 15;
            if t == 15 || t2 == 15 then UNPREDICTABLE;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            AArch32.CheckSystemAccess(cp, ThisInstr());
            value = R[t2]:R[t];
            AArch32.SysRegWrite64(cp, ThisInstr(), value);

__instruction aarch32_CMP_rr_A
    __encoding aarch32_CMP_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0101xxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            shift_t = DecodeRegShift(type1);
            if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VSUBL_A
    __encoding aarch32_VSUBL_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VSUBL_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 8 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0010 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vd<0> == '1' || (op == '1' && Vn<0> == '1') then UNDEFINED;
            unsigned = (U == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                if is_vsubw then
                    op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
                else
                    op1 = Int(Elem[Din[n],e,esize], unsigned);
                result = op1 - Int(Elem[Din[m],e,esize], unsigned);
                Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;

__instruction aarch32_UDIV_A
    __encoding aarch32_UDIV_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0111 0011xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE;

    __encoding aarch32_UDIV_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 1011xxxx xxxxxxxx 1111xxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if UInt(R[m]) == 0 then
                result = 0;
            else
                result = RoundTowardsZero(Real(UInt(R[n])) / Real(UInt(R[m])));
            R[d] = result<31:0>;

__instruction aarch32_VST4_1_A
    __encoding aarch32_VST4_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '00' then SEE "Related encodings";
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '01' then SEE "Related encodings";
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x00xxxx xxxx1011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '00' then SEE "Related encodings";
            if index_align<1:0> == '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<1:0> == '00' then 1 else 4 << UInt(index_align<1:0>);
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '00' then SEE "Related encodings";
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '01' then SEE "Related encodings";
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VST4_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x00xxxx xxxx1011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if size != '00' then SEE "Related encodings";
            if index_align<1:0> == '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<1:0> == '00' then 1 else 4 << UInt(index_align<1:0>);
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = TRUE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            MemU[address,         ebytes] = Elem[D[d], index];
            MemU[address+ebytes,  ebytes] = Elem[D[d2],index];
            MemU[address+2*ebytes,ebytes] = Elem[D[d3],index];
            MemU[address+3*ebytes,ebytes] = Elem[D[d4],index];
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 4*ebytes;

__instruction aarch32_POP_A
    __encoding aarch32_POP_T1_A
        __instruction_set T16
        __field P 8 +: 1
        __field register_list 0 +: 8
        __opcode '1011110x xxxxxxxx'
        __guard TRUE
        __decode
            registers = P:'0000000':register_list;   UnalignedAllowed = FALSE;
            if BitCount(registers) < 1 then UNPREDICTABLE;
            if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = SP;
            for i = 0 to 14
                if registers<i> == '1' then
                    R[i] = if UnalignedAllowed then MemU[address,4] else MemA[address,4];
                    address = address + 4;
            if registers<15> == '1' then
                if UnalignedAllowed then
                    if address<1:0> == '00' then
                        LoadWritePC(MemU[address,4]);
                    else
                        UNPREDICTABLE;
                else
                    LoadWritePC(MemA[address,4]);
            if registers<13> == '0' then SP = SP + 4*BitCount(registers);
            if registers<13> == '1' then SP = bits(32) UNKNOWN;

__instruction aarch32_ADD_SP_i_A
    __encoding aarch32_ADD_SP_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 100x1101 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_ADD_SP_i_T1_A
        __instruction_set T16
        __field Rd 8 +: 3
        __field imm8 0 +: 8
        __opcode '10101xxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(imm8:'00', 32);

    __encoding aarch32_ADD_SP_i_T2_A
        __instruction_set T16
        __field imm7 0 +: 7
        __opcode '10110000 0xxxxxxx'
        __guard TRUE
        __decode
            d = 13;  setflags = FALSE;  imm32 = ZeroExtend(imm7:'00', 32);

    __encoding aarch32_ADD_SP_i_T3_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 000x1101 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rd == '1111' && S == '1' then SEE CMN (immediate);
            d = UInt(Rd);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if d == 15 && !setflags then UNPREDICTABLE;

    __encoding aarch32_ADD_SP_i_T4_A
        __instruction_set T32
        __field i 26 +: 1
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x10 00001101 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
            if d == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result, nzcv) = AddWithCarry(SP, imm32, '0');
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_LDMIB_A
    __encoding aarch32_LDMIB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field register_list 0 +: 16
        __opcode 'xxxx1001 10x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            n = UInt(Rn);  registers = register_list;  wback = (W == '1');
            if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
            if wback && registers<n> == '1' then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n] + 4;
            for i = 0 to 14
                if registers<i> == '1' then
                    R[i] = MemA[address,4];  address = address + 4;
            if registers<15> == '1' then
                LoadWritePC(MemA[address,4]);
            if wback && registers<n> == '0' then R[n] = R[n] + 4*BitCount(registers);
            if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;

__instruction aarch32_MRC_A
    __encoding aarch32_MRC_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field opc1 21 +: 3
        __field CRn 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc2 5 +: 3
        __field CRm 0 +: 4
        __opcode 'xxxx1110 xxx1xxxx xxxx111x xxx1xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  cp = if coproc<0> == '0' then 14 else 15;
            // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_MRC_T1A1_A
        __instruction_set T32
        __field opc1 21 +: 3
        __field CRn 16 +: 4
        __field Rt 12 +: 4
        __field coproc 8 +: 4
        __field opc2 5 +: 3
        __field CRm 0 +: 4
        __opcode '11101110 xxx1xxxx xxxx111x xxx1xxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  cp = if coproc<0> == '0' then 14 else 15;
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            AArch32.CheckSystemAccess(cp, ThisInstr());
            bits(32) value = AArch32.SysRegRead(cp, ThisInstr());
            if t != 15 then
                R[t] = value;
            elsif AArch32.SysRegReadCanWriteAPSR(cp, ThisInstr()) then
                PSTATE.<N,Z,C,V> = value<31:28>;
                // value<27:0> are not used.
            else
                PSTATE.<N,Z,C,V> = bits(4) UNKNOWN;

__instruction aarch32_SHA1M_A
    __encoding aarch32_SHA1M_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x10xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_SHA1M_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x10xxxx xxxx1100 xxx0xxxx'
        __guard TRUE
        __decode
            if ! HaveCryptoExt() then UNDEFINED;
            if Q != '1' then UNDEFINED;
            if Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckCryptoEnabled32();
            X = Q[d>>1];
            Y = Q[n>>1]<31:0>; // Note: 32 bits wide
            W = Q[m>>1];
            for e = 0 to 3
                t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);
                Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
                X<63:32> = ROL(X<63:32>, 30);
                <Y, X> = ROL(Y:X, 32);
            Q[d>>1] = X;

__instruction aarch32_VLD1_m_A
    __encoding aarch32_VLD1_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  if align == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 3;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T4A4_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 4;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx1010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  if align == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx0110 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 3;  if align<1> == '1' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD1_m_T4A4_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx0010 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 4;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d+regs > 32 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = FALSE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    bits(ebytes*8) data;
                    if ebytes != 8 then
                        data = MemU[address,ebytes];
                    else
                        - = AArch32.CheckAlignment(address, ebytes, AccType_NORMAL, iswrite);
                        data<31:0> = if BigEndian() then MemU[address+4,4] else MemU[address,4];
                        data<63:32> = if BigEndian() then MemU[address,4] else MemU[address+4,4];
                    Elem[D[d+r],e] = data;
                    address = address + ebytes;
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 8*regs;

__instruction aarch32_VCGT_i_A
    __encoding aarch32_VCGT_i_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x00 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCGT_i_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x00 0xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    if floating_point then
                        bits(esize) zero = FPZero('0');
                        test_passed = FPCompareGT(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());
                    else
                        test_passed = (SInt(Elem[D[m+r],e,esize]) > 0);
                    Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_LDR_r_A
    __encoding aarch32_LDR_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx011x x0x1xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE LDRT;
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if m == 15 then UNPREDICTABLE;
            if wback && (n == 15 || n == t) then UNPREDICTABLE;

    __encoding aarch32_LDR_r_T1_A
        __instruction_set T16
        __field Rm 6 +: 3
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '0101100x xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_LDR_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm2 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111000 0101xxxx xxxx0000 00xxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDR (literal);
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
            if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13
            if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
                offset_addr = if add then (R[n] + offset) else (R[n] - offset);
                address = if index then offset_addr else R[n];
                data = MemU[address,4];
                if wback then R[n] = offset_addr;
                if t == 15 then
                    if address<1:0> == '00' then
                        LoadWritePC(data);
                    else
                        UNPREDICTABLE;
                else
                    R[t] = data;
        else
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
                offset_addr = (R[n] + offset);
                address = offset_addr;
                data = MemU[address,4];
                if t == 15 then
                    if address<1:0> == '00' then
                        LoadWritePC(data);
                    else
                        UNPREDICTABLE;
                else
                    R[t] = data;

__instruction aarch32_CLZ_A
    __encoding aarch32_CLZ_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0110xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  m = UInt(Rm);
            if d == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_CLZ_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1011xxxx 1111xxxx 1000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
            if m != n || d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            result = CountLeadingZeroBits(R[m]);
            R[d] = result<31:0>;

__instruction aarch32_LDR_i_A
    __encoding aarch32_LDR_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x0x1xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE LDR (literal);
            if P == '0' && W == '1' then SEE LDRT;
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
            index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
            if wback && n == t then UNPREDICTABLE;

    __encoding aarch32_LDR_i_T1_A
        __instruction_set T16
        __field imm5 6 +: 5
        __field Rn 3 +: 3
        __field Rt 0 +: 3
        __opcode '01101xxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'00', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_LDR_i_T2_A
        __instruction_set T16
        __field Rt 8 +: 3
        __field imm8 0 +: 8
        __opcode '10011xxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  n = 13;  imm32 = ZeroExtend(imm8:'00', 32);
            index = TRUE;  add = TRUE;  wback = FALSE;

    __encoding aarch32_LDR_i_T3_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 1101xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDR (literal);
            t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32); index = TRUE;  add = TRUE;
            wback = FALSE; if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_LDR_i_T4_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field P 10 +: 1
        __field U 9 +: 1
        __field W 8 +: 1
        __field imm8 0 +: 8
        __opcode '11111000 0101xxxx xxxx1xxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDR (literal);
            if P == '1' && U == '1' && W == '0' then SEE LDRT;
            if P == '0' && W == '0' then UNDEFINED;
            t = UInt(Rt);  n = UInt(Rn);
            imm32 = ZeroExtend(imm8, 32); index = (P == '1');  add = (U == '1');  wback = (W == '1');
            if (wback && n == t) || (t == 15 && InITBlock() && !LastInITBlock()) then UNPREDICTABLE;

    __execute
        if CurrentInstrSet() == InstrSet_A32 then
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                data = MemU[address,4];
                if wback then R[n] = offset_addr;
                if t == 15 then
                    if address<1:0> == '00' then
                        LoadWritePC(data);
                    else
                        UNPREDICTABLE;
                else
                    R[t] = data;
        else
            if ConditionPassed() then
                EncodingSpecificOperations();
                offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
                address = if index then offset_addr else R[n];
                data = MemU[address,4];
                if wback then R[n] = offset_addr;
                if t == 15 then
                    if address<1:0> == '00' then
                        LoadWritePC(data);
                    else
                        UNPREDICTABLE;
                else
                    R[t] = data;

__instruction aarch32_VMUL_i_A
    __encoding aarch32_VMUL_i_T1A1_A
        __instruction_set A32
        __field op 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 0xxxxxxx xxxx1001 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' || (op == '1' && size != '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            polynomial = (op == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMUL_i_T1A1_A
        __instruction_set T32
        __field op 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 0xxxxxxx xxxx1001 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' || (op == '1' && size != '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
            polynomial = (op == '1');  long_destination = FALSE;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                    op2 = Elem[Din[m+r],e,esize];  op2val = Int(op2, unsigned);
                    if polynomial then
                        product = PolynomialMult(op1,op2);
                    else
                        product = (op1val*op2val)<2*esize-1:0>;
                    if long_destination then
                        Elem[Q[d>>1],e,2*esize] = product;
                    else
                        Elem[D[d+r],e,esize] = product<esize-1:0>;

__instruction aarch32_VCLZ_A
    __encoding aarch32_VCLZ_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx00 xxxx0100 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCLZ_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx00 xxxx0100 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r],e,esize] = CountLeadingZeroBits(Elem[D[m+r],e,esize])<esize-1:0>;

__instruction aarch32_LDRSH_l_A
    __encoding aarch32_LDRSH_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field imm4H 8 +: 4
        __field imm4L 0 +: 4
        __opcode 'xxxx000x x1x11111 xxxxxxxx 1111xxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE LDRSHT;
            t = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);
            add = (U == '1');  wback = (P == '0') || (W == '1');
            if t == 15 || wback then UNPREDICTABLE;

    __encoding aarch32_LDRSH_l_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111001 x0111111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rt == '1111' then SEE "Related instructions";
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
            // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            base = Align(PC,4);
            address = if add then (base + imm32) else (base - imm32);
            data = MemU[address,2];
            R[t] = SignExtend(data, 32);

__instruction aarch32_UQADD8_A
    __encoding aarch32_UQADD8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQADD8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1000xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);
            sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);
            sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);
            sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);
            R[d]<7:0>   = UnsignedSat(sum1, 8);
            R[d]<15:8>  = UnsignedSat(sum2, 8);
            R[d]<23:16> = UnsignedSat(sum3, 8);
            R[d]<31:24> = UnsignedSat(sum4, 8);

__instruction aarch32_VBIF_A
    __encoding aarch32_VBIF_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x10xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE VEOR;
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VBIF_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x10xxxx xxxx0001 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if op == '00' then SEE VEOR;
            if op == '01' then operation = VBitOps_VBSL;
            if op == '10' then operation = VBitOps_VBIT;
            if op == '11' then operation = VBitOps_VBIF;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL};
        
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                case operation of
                    when VBitOps_VBIF  D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));
                    when VBitOps_VBIT  D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));
                    when VBitOps_VBSL  D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));

__instruction aarch32_VPADD_i_A
    __encoding aarch32_VPADD_i_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0xxxxxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VPADD_i_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0xxxxxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __decode
            if size == '11' || Q == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            bits(64) dest;
            h = elements DIV 2;
        
            for e = 0 to h-1
                Elem[dest,e,esize]   = Elem[D[n],2*e,esize] + Elem[D[n],2*e+1,esize];
                Elem[dest,e+h,esize] = Elem[D[m],2*e,esize] + Elem[D[m],2*e+1,esize];
        
            D[d] = dest;

__instruction aarch32_SSAX_A
    __encoding aarch32_SSAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SSAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum  = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);
            diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);
            R[d]<15:0>  = sum<15:0>;
            R[d]<31:16> = diff<15:0>;
            PSTATE.GE<1:0> = if sum  >= 0 then '11' else '00';
            PSTATE.GE<3:2> = if diff >= 0 then '11' else '00';

__instruction aarch32_TEQ_rr_A
    __encoding aarch32_TEQ_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0011xxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            shift_t = DecodeRegShift(type1);
            if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
            result = R[n] EOR shifted;
            PSTATE.N = result<31>;
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry;
            // PSTATE.V unchanged

__instruction aarch32_USADA8_A
    __encoding aarch32_USADA8_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field Rn 0 +: 4
        __opcode 'xxxx0111 1000xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __decode
            if Ra == '1111' then SEE USAD8;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_USADA8_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111011 0111xxxx xxxxxxxx 0000xxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE USAD8;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            absdiff1 = Abs(UInt(R[n]<7:0>)   - UInt(R[m]<7:0>));
            absdiff2 = Abs(UInt(R[n]<15:8>)  - UInt(R[m]<15:8>));
            absdiff3 = Abs(UInt(R[n]<23:16>) - UInt(R[m]<23:16>));
            absdiff4 = Abs(UInt(R[n]<31:24>) - UInt(R[m]<31:24>));
            result = UInt(R[a]) + absdiff1 + absdiff2 + absdiff3 + absdiff4;
            R[d] = result<31:0>;

__instruction aarch32_SADD16_A
    __encoding aarch32_SADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0001xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_SADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0000xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);
            sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);
            R[d]<15:0>  = sum1<15:0>;
            R[d]<31:16> = sum2<15:0>;
            PSTATE.GE<1:0> = if sum1 >= 0 then '11' else '00';
            PSTATE.GE<3:2> = if sum2 >= 0 then '11' else '00';

__instruction aarch32_SVC_A
    __encoding aarch32_SVC_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm24 0 +: 24
        __opcode 'xxxx1111 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            imm32 = ZeroExtend(imm24, 32);

    __encoding aarch32_SVC_T1_A
        __instruction_set T16
        __field imm8 0 +: 8
        __opcode '11011111 xxxxxxxx'
        __guard TRUE
        __decode
            imm32 = ZeroExtend(imm8, 32);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            AArch32.CallSupervisor(imm32<15:0>);

__instruction aarch32_VQMOVN_A
    __encoding aarch32_VQMOVN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 6 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx10 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if op == '00' then SEE VMOVN;
            if size == '11' || Vm<0> == '1' then UNDEFINED;
            src_unsigned = (op == '11');  dest_unsigned = (op<0> == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __encoding aarch32_VQMOVN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 6 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx10 xxxx0010 xxx0xxxx'
        __guard TRUE
        __decode
            if op == '00' then SEE VMOVN;
            if size == '11' || Vm<0> == '1' then UNDEFINED;
            src_unsigned = (op == '11');  dest_unsigned = (op<0> == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for e = 0 to elements-1
                operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
                (Elem[D[d],e,esize], sat) = SatQ(operand, esize, dest_unsigned);
                if sat then FPSCR.QC = '1';

__instruction aarch32_SBFX_A
    __encoding aarch32_SBFX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field widthm1 16 +: 5
        __field Rd 12 +: 4
        __field lsb 7 +: 5
        __field Rn 0 +: 4
        __opcode 'xxxx0111 101xxxxx xxxxxxxx x101xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);
            lsbit = UInt(lsb);  widthminus1 = UInt(widthm1);
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_SBFX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field widthm1 0 +: 5
        __opcode '11110x11 0100xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);
            lsbit = UInt(imm3:imm2);  widthminus1 = UInt(widthm1);
            if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            msbit = lsbit + widthminus1;
            if msbit <= 31 then
                R[d] = SignExtend(R[n]<msbit:lsbit>, 32);
            else
                UNPREDICTABLE;

__instruction aarch32_RSC_rr_A
    __encoding aarch32_RSC_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 111xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, PSTATE.C);
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_PUSH_A
    __encoding aarch32_PUSH_T1_A
        __instruction_set T16
        __field M 8 +: 1
        __field register_list 0 +: 8
        __opcode '1011010x xxxxxxxx'
        __guard TRUE
        __decode
            registers = '0':M:'000000':register_list;  UnalignedAllowed = FALSE;
            if BitCount(registers) < 1 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = SP - 4*BitCount(registers);
            for i = 0 to 14
                if registers<i> == '1' then
                    if i == 13 && i != LowestSetBit(registers) then  // Only possible for encoding A1
                        MemA[address,4] = bits(32) UNKNOWN;
                    else
                        if UnalignedAllowed then
                            MemU[address,4] = R[i];
                        else
                            MemA[address,4] = R[i];
                    address = address + 4;
            if registers<15> == '1' then  // Only possible for encoding A1 or A2
                if UnalignedAllowed then
                    MemU[address,4] = PCStoreValue();
                else
                    MemA[address,4] = PCStoreValue();
            SP = SP - 4*BitCount(registers);

__instruction aarch32_VMOV_sr_A
    __encoding aarch32_VMOV_sr_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field opc1 21 +: 2
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __field opc2 5 +: 2
        __opcode 'xxxx1110 xxx1xxxx xxxx1011 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            case U:opc1:opc2 of
                when 'x1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1<0>:opc2);
                when 'x0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1<0>:opc2<1>);
                when '00x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1<0>);
                when '10x00'  UNDEFINED;
                when 'x0x10'  UNDEFINED;
            t = UInt(Rt);  n = UInt(N:Vn);  unsigned = (U == '1');
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMOV_sr_T1A1_A
        __instruction_set T32
        __field U 23 +: 1
        __field opc1 21 +: 2
        __field Vn 16 +: 4
        __field Rt 12 +: 4
        __field N 7 +: 1
        __field opc2 5 +: 2
        __opcode '11101110 xxx1xxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            case U:opc1:opc2 of
                when 'x1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1<0>:opc2);
                when 'x0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1<0>:opc2<1>);
                when '00x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1<0>);
                when '10x00'  UNDEFINED;
                when 'x0x10'  UNDEFINED;
            t = UInt(Rt);  n = UInt(N:Vn);  unsigned = (U == '1');
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if unsigned then
                R[t] = ZeroExtend(Elem[D[n],index,esize], 32);
            else
                R[t] = SignExtend(Elem[D[n],index,esize], 32);

__instruction aarch32_VMOVX_A
    __encoding aarch32_VMOVX_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x110000 xxxx1010 01x0xxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            d = UInt(Vd:D); m = UInt(Vm:M);

    __encoding aarch32_VMOVX_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x110000 xxxx1010 01x0xxxx'
        __guard TRUE
        __decode
            if !HaveFP16Ext() then UNDEFINED;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if InITBlock() then UNPREDICTABLE;
            d = UInt(Vd:D); m = UInt(Vm:M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            S[d] = Zeros(16) : S[m]<31:16>;

__instruction aarch32_BFI_A
    __encoding aarch32_BFI_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field msb 16 +: 5
        __field Rd 12 +: 4
        __field lsb 7 +: 5
        __field Rn 0 +: 4
        __opcode 'xxxx0111 110xxxxx xxxxxxxx x001xxxx'
        __guard cond != '1111'
        __decode
            if Rn == '1111' then SEE BFC;
            d = UInt(Rd);  n = UInt(Rn);  msbit = UInt(msb);  lsbit = UInt(lsb);
            if d == 15 then UNPREDICTABLE;

    __encoding aarch32_BFI_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field msb 0 +: 5
        __opcode '11110x11 0110xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            if Rn == '1111' then SEE BFC;
            d = UInt(Rd);  n = UInt(Rn);  msbit = UInt(msb);  lsbit = UInt(imm3:imm2);
            if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if msbit >= lsbit then
                R[d]<msbit:lsbit> = R[n]<(msbit-lsbit):0>;
                // Other bits of R[d] are unchanged
            else
                UNPREDICTABLE;

__instruction aarch32_VNEG_A
    __encoding aarch32_VNEG_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx01 xxxx0x11 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            advsimd = TRUE;  floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VNEG_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x110001 xxxx10xx 01x0xxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VNEG_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field F 10 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx01 xxxx0x11 1xx0xxxx'
        __guard TRUE
        __decode
            if size == '11' then UNDEFINED;
            if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
            if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            advsimd = TRUE;  floating_point = (F == '1');
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VNEG_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x110001 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            advsimd = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            if advsimd then  // Advanced SIMD instruction
                for r = 0 to regs-1
                    for e = 0 to elements-1
                        if floating_point then
                            Elem[D[d+r],e,esize] = FPNeg(Elem[D[m+r],e,esize]);
                        else
                            result = -SInt(Elem[D[m+r],e,esize]);
                            Elem[D[d+r],e,esize] = result<esize-1:0>;
            else             // VFP instruction
                case esize of
                    when 16 S[d] = Zeros(16) : FPNeg(S[m]<15:0>);
                    when 32 S[d] = FPNeg(S[m]);
                    when 64 D[d] = FPNeg(D[m]);

__instruction aarch32_CMP_i_A
    __encoding aarch32_CMP_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0011 0101xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_CMP_i_T1_A
        __instruction_set T16
        __field Rn 8 +: 3
        __field imm8 0 +: 8
        __opcode '00101xxx xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);

    __encoding aarch32_CMP_i_T2_A
        __instruction_set T32
        __field i 26 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm8 0 +: 8
        __opcode '11110x01 1011xxxx 0xxx1111 xxxxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  imm32 = T32ExpandImm(i:imm3:imm8);
            if n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result, nzcv) = AddWithCarry(R[n], NOT(imm32), '1');
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VLD1_1_A
    __encoding aarch32_VLD1_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD1 (single element to all lanes);
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  alignment = 1;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VLD1_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD1 (single element to all lanes);
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VLD1_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD1 (single element to all lanes);
            if index_align<2> != '0' then UNDEFINED;
            if index_align<1:0> != '00' && index_align<1:0> != '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            alignment = if index_align<1:0> == '00' then 1 else 4;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VLD1_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD1 (single element to all lanes);
            if index_align<0> != '0' then UNDEFINED;
            ebytes = 1;  index = UInt(index_align<3:1>);  alignment = 1;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VLD1_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0100 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD1 (single element to all lanes);
            if index_align<1> != '0' then UNDEFINED;
            ebytes = 2;  index = UInt(index_align<3:2>);
            alignment = if index_align<0> == '0' then 1 else 2;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __encoding aarch32_VLD1_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1000 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD1 (single element to all lanes);
            if index_align<2> != '0' then UNDEFINED;
            if index_align<1:0> != '00' && index_align<1:0> != '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            alignment = if index_align<1:0> == '00' then 1 else 4;
            d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = FALSE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            Elem[D[d],index] = MemU[address,ebytes];
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + ebytes;

__instruction aarch32_VLD4_m_A
    __encoding aarch32_VLD4_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx000x xxxxxxxx'
        __guard TRUE
        __decode
            case type1 of
                when '0000'
                    inc = 1;
                when '0001'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx000x xxxxxxxx'
        __guard TRUE
        __decode
            case type1 of
                when '0000'
                    inc = 1;
                when '0001'
                    inc = 2;
                otherwise
                    SEE "Related encodings";
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = FALSE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            for e = 0 to elements-1
                Elem[D[d], e] = MemU[address,ebytes];
                Elem[D[d2],e] = MemU[address+ebytes,ebytes];
                Elem[D[d3],e] = MemU[address+2*ebytes,ebytes];
                Elem[D[d4],e] = MemU[address+3*ebytes,ebytes];
                address = address + 4*ebytes;
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 32;

__instruction aarch32_VSEL_A
    __encoding aarch32_VSEL_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field cc 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0xxxxxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            cond = cc:(cc<1> EOR cc<0>):'0';

    __encoding aarch32_VSEL_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field cc 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 0xxxxxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            cond = cc:(cc<1> EOR cc<0>):'0';
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : (if ConditionHolds(cond) then S[n] else S[m])<15:0>;
            when 32
                S[d] = if ConditionHolds(cond) then S[n] else S[m];
            when 64
                D[d] = if ConditionHolds(cond) then D[n] else D[m];

__instruction aarch32_VLD4_1_A
    __encoding aarch32_VLD4_1_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD4 (single 4-element structure to all lanes);
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_1_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD4 (single 4-element structure to all lanes);
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_1_T3A3_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11110100 1x10xxxx xxxx1011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD4 (single 4-element structure to all lanes);
            if index_align<1:0> == '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<1:0> == '00' then 1 else 4 << UInt(index_align<1:0>);
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_1_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD4 (single 4-element structure to all lanes);
            ebytes = 1;  index = UInt(index_align<3:1>);  inc = 1;
            alignment = if index_align<0> == '0' then 1 else 4;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_1_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx0111 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD4 (single 4-element structure to all lanes);
            ebytes = 2;  index = UInt(index_align<3:2>);
            inc = if index_align<1> == '0' then 1 else 2;
            alignment = if index_align<0> == '0' then 1 else 8;
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __encoding aarch32_VLD4_1_T3A3_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 10 +: 2
        __field index_align 4 +: 4
        __field Rm 0 +: 4
        __opcode '11111001 1x10xxxx xxxx1011 xxxxxxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE VLD4 (single 4-element structure to all lanes);
            if index_align<1:0> == '11' then UNDEFINED;
            ebytes = 4;  index = UInt(index_align<3>);
            inc = if index_align<2> == '0' then 1 else 2;
            alignment = if index_align<1:0> == '00' then 1 else 4 << UInt(index_align<1:0>);
            d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d4 > 31 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = FALSE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            Elem[D[d], index] = MemU[address,ebytes];
            Elem[D[d2],index] = MemU[address+ebytes,ebytes];
            Elem[D[d3],index] = MemU[address+2*ebytes,ebytes];
            Elem[D[d4],index] = MemU[address+3*ebytes,ebytes];
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 4*ebytes;

__instruction aarch32_MRS_AS
    __encoding aarch32_MRS_A1_AS
        __instruction_set A32
        __field cond 28 +: 4
        __field R 22 +: 1
        __field Rd 12 +: 4
        __opcode 'xxxx0001 0x00xxxx xxxxxx0x 0000xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 11 == '0'
        __unpredictable_unless 10 == '0'
        __unpredictable_unless 8 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            d = UInt(Rd);  read_spsr = (R == '1');
            if d == 15 then UNPREDICTABLE;

    __encoding aarch32_MRS_T1_AS
        __instruction_set T32
        __field R 20 +: 1
        __field Rd 8 +: 4
        __opcode '11110011 111xxxxx 10x0xxxx xx0xxxxx'
        __guard TRUE
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 7 == '0'
        __unpredictable_unless 6 == '0'
        __unpredictable_unless 4 == '0'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            d = UInt(Rd);  read_spsr = (R == '1');
            if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            if read_spsr then
                if PSTATE.M IN {M32_User,M32_System} then
                    UNPREDICTABLE;
                else
                    R[d] = SPSR[];
            else
                // CPSR has same bit assignments as SPSR, but with the IT, J, SS, IL, and T bits masked out.
                bits(32) mask = '11111000 00001111 00000011 11011111';
                if HavePANExt() then
                    mask<22> = '1';
                psr_val = GetPSRFromPSTATE() AND mask;
                if PSTATE.EL == EL0 then
                    // If accessed from User mode return UNKNOWN values for E, A, I, F bits, bits<9:6>,
                    // and for the M field, bits<4:0>
                    psr_val<22> = bits(1) UNKNOWN;
                    psr_val<9:6> = bits(4) UNKNOWN;
                    psr_val<4:0> = bits(5) UNKNOWN;
                R[d] = psr_val;

__instruction aarch32_VSTR_A
    __encoding aarch32_VSTR_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode 'xxxx1101 xx00xxxx xxxx10xx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);
            if n == 15 && CurrentInstrSet() != InstrSet_A32 then UNPREDICTABLE;

    __encoding aarch32_VSTR_T1_A
        __instruction_set T32
        __field U 23 +: 1
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field imm8 0 +: 8
        __opcode '11101101 xx00xxxx xxxx10xx xxxxxxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            esize = 8 << UInt(size);  add = (U == '1');
            imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
            case size of
                when '01' d = UInt(Vd:D);
                when '10' d = UInt(Vd:D);
                when '11' d = UInt(D:Vd);
            n = UInt(Rn);
            if n == 15 && CurrentInstrSet() != InstrSet_A32 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckVFPEnabled(TRUE);
            address = if add then (R[n] + imm32) else (R[n] - imm32);
            case esize of
                when 16
                    MemA[address,2] = S[d]<15:0>;
                when 32
                    MemA[address,4] = S[d];
                when 64
                    // Store as two word-aligned words in the correct order for current endianness.
                    MemA[address,4]   = if BigEndian() then D[d]<63:32> else D[d]<31:0>;
                    MemA[address+4,4] = if BigEndian() then D[d]<31:0>  else D[d]<63:32>;

__instruction aarch32_SSAT_A
    __encoding aarch32_SSAT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field sat_imm 16 +: 5
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field sh 6 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0110 101xxxxx xxxxxxxx xx01xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
            (shift_t, shift_n) = DecodeImmShift(sh:'0', imm5);
            if d == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_SSAT_T1_A
        __instruction_set T32
        __field sh 21 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field sat_imm 0 +: 5
        __opcode '11110x11 00x0xxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 26 == '0'
        __unpredictable_unless 5 == '0'
        __decode
            if sh == '1' && (imm3:imm2) == '00000' then SEE SSAT16;
            d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
            (shift_t, shift_n) = DecodeImmShift(sh:'0', imm3:imm2);
            if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand = Shift(R[n], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored
            (result, sat) = SignedSatQ(SInt(operand), saturate_to);
            R[d] = SignExtend(result, 32);
            if sat then
                PSTATE.Q = '1';

__instruction aarch32_VFNMA_A
    __encoding aarch32_VFNMA_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode 'xxxx1110 1x01xxxx xxxx10xx x0x0xxxx'
        __guard cond != '1111'
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && cond != '1110' then UNPREDICTABLE;
            op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VFNMA_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101110 1x01xxxx xxxx10xx x0x0xxxx'
        __guard TRUE
        __decode
            if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            op1_neg = (op == '1');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
            case esize of
                when 16
                    op16 = if op1_neg then FPNeg(S[n]<15:0>) else S[n]<15:0>;
                    S[d] = Zeros(16) : FPMulAdd(FPNeg(S[d]<15:0>), op16, S[m]<15:0>, FPSCR);
                when 32
                    op32 = if op1_neg then FPNeg(S[n]) else S[n];
                    S[d] = FPMulAdd(FPNeg(S[d]), op32, S[m], FPSCR);
                when 64
                    op64 = if op1_neg then FPNeg(D[n]) else D[n];
                    D[d] = FPMulAdd(FPNeg(D[d]), op64, D[m], FPSCR);

__instruction aarch32_BX_A
    __encoding aarch32_BX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0010xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 19 == '1'
        __unpredictable_unless 18 == '1'
        __unpredictable_unless 17 == '1'
        __unpredictable_unless 16 == '1'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            m = UInt(Rm);

    __encoding aarch32_BX_T1_A
        __instruction_set T16
        __field Rm 3 +: 4
        __opcode '01000111 0xxxxxxx'
        __guard TRUE
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            m = UInt(Rm);
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            BXWritePC(R[m]);

__instruction aarch32_SMLABB_A
    __encoding aarch32_SMLABB_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rd 16 +: 4
        __field Ra 12 +: 4
        __field Rm 8 +: 4
        __field M 6 +: 1
        __field N 5 +: 1
        __field Rn 0 +: 4
        __opcode 'xxxx0001 0000xxxx xxxxxxxx 1xx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            n_high = (N == '1');  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

    __encoding aarch32_SMLABB_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Ra 12 +: 4
        __field Rd 8 +: 4
        __field N 5 +: 1
        __field M 4 +: 1
        __field Rm 0 +: 4
        __opcode '11111011 0001xxxx xxxxxxxx 00xxxxxx'
        __guard TRUE
        __decode
            if Ra == '1111' then SEE SMULBB, SMULBT, SMULTB, SMULTT;
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
            n_high = (N == '1');  m_high = (M == '1');
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;
            operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
            result = SInt(operand1) * SInt(operand2) + SInt(R[a]);
            R[d] = result<31:0>;
            if result != SInt(result<31:0>) then  // Signed overflow
                PSTATE.Q = '1';

__instruction aarch32_VMAXNM_A
    __encoding aarch32_VMAXNM_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0x1xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VMAXNM_A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x00xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            advsimd = FALSE;
            maximum = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

    __encoding aarch32_VMAXNM_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field op 21 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0x1xxxxx xxxx1111 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            maximum = (op == '0');
            advsimd = TRUE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;
            if InITBlock() then UNPREDICTABLE;

    __encoding aarch32_VMAXNM_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field N 7 +: 1
        __field op 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x00xxxx xxxx10xx x1x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            advsimd = FALSE;
            maximum = (op == '0');
            case size of
                when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
        if advsimd then             // Advanced SIMD instruction
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[n+r], e, esize]; op2 = Elem[D[m+r], e, esize];
                    if maximum then
                        Elem[D[d+r], e, esize] = FPMaxNum(op1, op2, StandardFPSCRValue());
                    else
                        Elem[D[d+r], e, esize] = FPMinNum(op1, op2, StandardFPSCRValue());
        else                        // VFP instruction
            case esize of
                when 16
                    if maximum then
                        S[d] = Zeros(16) : FPMaxNum(S[n]<15:0>, S[m]<15:0>, FPSCR);
                    else
                        S[d] = Zeros(16) : FPMinNum(S[n]<15:0>, S[m]<15:0>, FPSCR);
                when 32
                    if maximum then
                        S[d] = FPMaxNum(S[n], S[m], FPSCR);
                    else
                        S[d] = FPMinNum(S[n], S[m], FPSCR);
                when 64
                    if maximum then
                        D[d] = FPMaxNum(D[n], D[m], FPSCR);
                    else
                        D[d] = FPMinNum(D[n], D[m], FPSCR);

__instruction aarch32_VMOV_rs_A
    __encoding aarch32_VMOV_rs_T1A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field opc1 21 +: 2
        __field Vd 16 +: 4
        __field Rt 12 +: 4
        __field D 7 +: 1
        __field opc2 5 +: 2
        __opcode 'xxxx1110 0xx0xxxx xxxx1011 xxx1xxxx'
        __guard cond != '1111'
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            case opc1:opc2 of
                when '1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1<0>:opc2);
                when '0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1<0>:opc2<1>);
                when '0x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1<0>);
                when '0x10'  UNDEFINED;
            d = UInt(D:Vd);  t = UInt(Rt);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __encoding aarch32_VMOV_rs_T1A1_A
        __instruction_set T32
        __field opc1 21 +: 2
        __field Vd 16 +: 4
        __field Rt 12 +: 4
        __field D 7 +: 1
        __field opc2 5 +: 2
        __opcode '11101110 0xx0xxxx xxxx1011 xxx1xxxx'
        __guard TRUE
        __unpredictable_unless 3 == '0'
        __unpredictable_unless 2 == '0'
        __unpredictable_unless 1 == '0'
        __unpredictable_unless 0 == '0'
        __decode
            case opc1:opc2 of
                when '1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1<0>:opc2);
                when '0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1<0>:opc2<1>);
                when '0x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1<0>);
                when '0x10'  UNDEFINED;
            d = UInt(D:Vd);  t = UInt(Rt);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
            Elem[D[d],index,esize] = R[t]<esize-1:0>;

__instruction aarch32_STL_A
    __encoding aarch32_STL_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rt 0 +: 4
        __opcode 'xxxx0001 1000xxxx xxxxxx00 1001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __encoding aarch32_STL_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __opcode '11101000 1100xxxx xxxxxxxx 1010xxxx'
        __guard TRUE
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __unpredictable_unless 3 == '1'
        __unpredictable_unless 2 == '1'
        __unpredictable_unless 1 == '1'
        __unpredictable_unless 0 == '1'
        __decode
            t = UInt(Rt); n = UInt(Rn);
            if t == 15 || n == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = R[n];
            MemO[address, 4] = R[t];

__instruction aarch32_VCEQ_r_A
    __encoding aarch32_VCEQ_r_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 0xxxxxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            int_operation = TRUE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCEQ_r_A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110010 0x0xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            int_operation = FALSE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCEQ_r_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 0xxxxxxx xxxx1000 xxx1xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if size == '11' then UNDEFINED;
            int_operation = TRUE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCEQ_r_T2_A
        __instruction_set T32
        __field D 22 +: 1
        __field sz 20 +: 1
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11101111 0x0xxxxx xxxx1110 xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vn<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if sz == '1' && !HaveFP16Ext() then UNDEFINED;
            if sz == '1' && InITBlock() then UNPREDICTABLE;
            int_operation = FALSE;
            case sz of
                when '0' esize = 32; elements = 2;
                when '1' esize = 16; elements = 4;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
                    if int_operation then
                        test_passed = (op1 == op2);
                    else
                        test_passed = FPCompareEQ(op1, op2, StandardFPSCRValue());
                    Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);

__instruction aarch32_B_A
    __encoding aarch32_B_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field imm24 0 +: 24
        __opcode 'xxxx1010 xxxxxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            imm32 = SignExtend(imm24:'00', 32);

    __encoding aarch32_B_T1_A
        __instruction_set T16
        __field cond 8 +: 4
        __field imm8 0 +: 8
        __opcode '1101xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if cond == '1110' then SEE UDF;
            if cond == '1111' then SEE SVC;
            imm32 = SignExtend(imm8:'0', 32);
            if InITBlock() then UNPREDICTABLE;

    __encoding aarch32_B_T2_A
        __instruction_set T16
        __field imm11 0 +: 11
        __opcode '11100xxx xxxxxxxx'
        __guard TRUE
        __decode
            imm32 = SignExtend(imm11:'0', 32);
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __encoding aarch32_B_T3_A
        __instruction_set T32
        __field S 26 +: 1
        __field cond 22 +: 4
        __field imm6 16 +: 6
        __field J1 13 +: 1
        __field J2 11 +: 1
        __field imm11 0 +: 11
        __opcode '11110xxx xxxxxxxx 10x0xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if cond<3:1> == '111' then SEE "Related encodings";
            imm32 = SignExtend(S:J2:J1:imm6:imm11:'0', 32);
            if InITBlock() then UNPREDICTABLE;

    __encoding aarch32_B_T4_A
        __instruction_set T32
        __field S 26 +: 1
        __field imm10 16 +: 10
        __field J1 13 +: 1
        __field J2 11 +: 1
        __field imm11 0 +: 11
        __opcode '11110xxx xxxxxxxx 10x1xxxx xxxxxxxx'
        __guard TRUE
        __decode
            I1 = NOT(J1 EOR S);  I2 = NOT(J2 EOR S);  imm32 = SignExtend(S:I1:I2:imm10:imm11:'0', 32);
            if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            BranchWritePC(PC + imm32);

__instruction aarch32_VSHR_A
    __encoding aarch32_VSHR_T1A1_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0000 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VSHR_T1A1_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field imm6 16 +: 6
        __field Vd 12 +: 4
        __field L 7 +: 1
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0000 xxx1xxxx'
        __guard TRUE
        __decode
            if (L:imm6) == '0000xxx' then SEE "Related encodings";
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            case L:imm6 of
                when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
                when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
                when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
                when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
            unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            for r = 0 to regs-1
                for e = 0 to elements-1
                    result = Int(Elem[D[m+r],e,esize], unsigned) >> shift_amount;
                    Elem[D[d+r],e,esize] = result<esize-1:0>;

__instruction aarch32_VCVT_is_A
    __encoding aarch32_VCVT_is_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1x11xx11 xxxx011x xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            to_integer = (op<1> == '1');  unsigned = (op<0> == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __encoding aarch32_VCVT_is_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 18 +: 2
        __field Vd 12 +: 4
        __field op 7 +: 2
        __field Q 6 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1x11xx11 xxxx011x xxx0xxxx'
        __guard TRUE
        __decode
            if Q == '1' && (Vd<0> == '1' || Vm<0> == '1') then UNDEFINED;
            if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
            if size == '01' && InITBlock()  then UNPREDICTABLE;
            to_integer = (op<1> == '1');  unsigned = (op<0> == '1');
            case size of
                when '01' esize = 16; elements = 4;
                when '10' esize = 32; elements = 2;
            d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            bits(esize) result;
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[D[m+r],e,esize];
                    if to_integer then
                        result = FPToFixed(op1, 0, unsigned, StandardFPSCRValue(), FPRounding_ZERO);
                    else
                        result = FixedToFP(op1, 0, unsigned, StandardFPSCRValue(), FPRounding_TIEEVEN);
                    Elem[D[d+r],e,esize] = result;

__instruction aarch32_VLD2_m_A
    __encoding aarch32_VLD2_m_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx100x xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align == '11' then UNDEFINED;
            if size == '11' then UNDEFINED;
            inc = if type1 == '1001' then 2 else 1;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD2_m_T2A2_A
        __instruction_set A32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11110100 0x10xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  inc = 2;
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD2_m_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field type1 8 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx100x xxxxxxxx'
        __guard TRUE
        __decode
            regs = 1;  if align == '11' then UNDEFINED;
            if size == '11' then UNDEFINED;
            inc = if type1 == '1001' then 2 else 1;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __encoding aarch32_VLD2_m_T2A2_A
        __instruction_set T32
        __field D 22 +: 1
        __field Rn 16 +: 4
        __field Vd 12 +: 4
        __field size 6 +: 2
        __field align 4 +: 2
        __field Rm 0 +: 4
        __opcode '11111001 0x10xxxx xxxx0011 xxxxxxxx'
        __guard TRUE
        __decode
            regs = 2;  inc = 2;
            if size == '11' then UNDEFINED;
            alignment = if align == '00' then 1 else 4 << UInt(align);
            ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
            d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
            wback = (m != 15);  register_index = (m != 15 && m != 13);
            if n == 15 || d2+regs > 32 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            address = R[n];  iswrite = FALSE;
            - = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    Elem[D[d+r], e] = MemU[address,ebytes];
                    Elem[D[d2+r],e] = MemU[address+ebytes,ebytes];
                    address = address + 2*ebytes;
            if wback then
                if register_index then
                    R[n] = R[n] + R[m];
                else
                    R[n] = R[n] + 16*regs;

__instruction aarch32_VRSUBHN_A
    __encoding aarch32_VRSUBHN_T1A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11110011 1xxxxxxx xxxx0110 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __encoding aarch32_VRSUBHN_T1A1_A
        __instruction_set T32
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111111 1xxxxxxx xxxx0110 x0x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if Vn<0> == '1' || Vm<0> == '1' then UNDEFINED;
            esize = 8 << UInt(size);  elements = 64 DIV esize;
            d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            round_const = 1 << (esize-1);
            for e = 0 to elements-1
                result = Elem[Qin[n>>1],e,2*esize] - Elem[Qin[m>>1],e,2*esize] + round_const;
                Elem[D[d],e,esize] = result<2*esize-1:esize>;

__instruction aarch32_ADC_i_A
    __encoding aarch32_ADC_i_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0010 101xxxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

    __encoding aarch32_ADC_i_T1_A
        __instruction_set T32
        __field i 26 +: 1
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm8 0 +: 8
        __opcode '11110x01 010xxxxx 0xxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
            if d == 15 || n == 15 then UNPREDICTABLE;  // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            (result, nzcv) = AddWithCarry(R[n], imm32, PSTATE.C);
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_ADC_rr_A
    __encoding aarch32_ADC_rr_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rs 8 +: 4
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 101xxxxx xxxxxxxx 0xx1xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
            setflags = (S == '1');  shift_t = DecodeRegShift(type1);
            if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shift_n = UInt(R[s]<7:0>);
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);
            R[d] = result;
            if setflags then
                PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_LDRT_A
    __encoding aarch32_LDRT_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx0100 x011xxxx xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
            register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
            if t == 15 || n == 15 || n == t then UNPREDICTABLE;

    __encoding aarch32_LDRT_A2_A
        __instruction_set A32
        __field cond 28 +: 4
        __field U 23 +: 1
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0110 x011xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
            register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(type1, imm5);
            if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

    __encoding aarch32_LDRT_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rt 12 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 0101xxxx xxxx1110 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE LDR (literal);
            t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
            register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
            if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
            EncodingSpecificOperations();
            offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
            offset_addr = if add then (R[n] + offset) else (R[n] - offset);
            address = if postindex then R[n] else offset_addr;
            data = MemU_unpriv[address,4];
            if postindex then R[n] = offset_addr;
            R[t] = data;

__instruction aarch32_LDR_l_A
    __encoding aarch32_LDR_l_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field P 24 +: 1
        __field U 23 +: 1
        __field W 21 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode 'xxxx010x x0x11111 xxxxxxxx xxxxxxxx'
        __guard cond != '1111'
        __decode
            if P == '0' && W == '1' then SEE LDRT;
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);
            add = (U == '1');  wback = (P == '0') || (W == '1');
            if wback then UNPREDICTABLE;

    __encoding aarch32_LDR_l_T1_A
        __instruction_set T16
        __field Rt 8 +: 3
        __field imm8 0 +: 8
        __opcode '01001xxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  imm32 = ZeroExtend(imm8:'00', 32);  add = TRUE;

    __encoding aarch32_LDR_l_T2_A
        __instruction_set T32
        __field U 23 +: 1
        __field Rt 12 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 x1011111 xxxxxxxx xxxxxxxx'
        __guard TRUE
        __decode
            t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
            if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            base = Align(PC,4);
            address = if add then (base + imm32) else (base - imm32);
            data = MemU[address,4];
            if t == 15 then
                if address<1:0> == '00' then
                    LoadWritePC(data);
                else
                    UNPREDICTABLE;
            else
                R[t] = data;

__instruction aarch32_UQADD16_A
    __encoding aarch32_UQADD16_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0110xxxx xxxxxxxx 0001xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_UQADD16_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1001xxxx 1111xxxx 0101xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);
            sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);
            R[d]<15:0>  = UnsignedSat(sum1, 16);
            R[d]<31:16> = UnsignedSat(sum2, 16);

__instruction aarch32_VRINTA_vfp_A
    __encoding aarch32_VRINTA_vfp_A1_A
        __instruction_set A32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111001 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

    __encoding aarch32_VRINTA_vfp_T1_A
        __instruction_set T32
        __field D 22 +: 1
        __field RM 16 +: 2
        __field Vd 12 +: 4
        __field size 8 +: 2
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '11111110 1x111001 xxxx10xx 01x0xxxx'
        __guard TRUE
        __decode
            if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
            rounding = FPDecodeRM(RM);  exact = FALSE;
            case size of
                when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
                when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
                when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);
            if InITBlock() then UNPREDICTABLE;

    __execute
        EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
        case esize of
            when 16
                S[d] = Zeros(16) : FPRoundInt(S[m]<15:0>, FPSCR, rounding, exact);
            when 32
                S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
            when 64
                D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);

__instruction aarch32_CMN_r_A
    __encoding aarch32_CMN_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0001 0111xxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __unpredictable_unless 15 == '0'
        __unpredictable_unless 14 == '0'
        __unpredictable_unless 13 == '0'
        __unpredictable_unless 12 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_CMN_r_T1_A
        __instruction_set T16
        __field Rm 3 +: 3
        __field Rn 0 +: 3
        __opcode '01000010 11xxxxxx'
        __guard TRUE
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = (SRType_LSL, 0);

    __encoding aarch32_CMN_r_T2_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 0001xxxx xxxx1111 xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            n = UInt(Rn);  m = UInt(Rm);
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(R[n], shifted, '0');
            PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_PLD_i_A
    __encoding aarch32_PLD_i_A1_A
        __instruction_set A32
        __field U 23 +: 1
        __field R 22 +: 1
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode '11110101 xx01xxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '1'
        __unpredictable_unless 14 == '1'
        __unpredictable_unless 13 == '1'
        __unpredictable_unless 12 == '1'
        __decode
            if Rn == '1111' then SEE PLD (literal);
            n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');  is_pldw = (R == '0');

    __encoding aarch32_PLD_i_T1_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm12 0 +: 12
        __opcode '11111000 10x1xxxx 1111xxxx xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE PLD (literal);
            n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = TRUE;  is_pldw = (W == '1');

    __encoding aarch32_PLD_i_T2_A
        __instruction_set T32
        __field W 21 +: 1
        __field Rn 16 +: 4
        __field imm8 0 +: 8
        __opcode '11111000 00x1xxxx 11111100 xxxxxxxx'
        __guard TRUE
        __decode
            if Rn == '1111' then SEE PLD (literal);
            n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);  add = FALSE;  is_pldw = (W == '1');

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            address = if add then (R[n] + imm32) else (R[n] - imm32);
            if is_pldw then
                Hint_PreloadDataForWrite(address);
            else
                Hint_PreloadData(address);

__instruction aarch32_QSAX_A
    __encoding aarch32_QSAX_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field Rm 0 +: 4
        __opcode 'xxxx0110 0010xxxx xxxxxxxx 0101xxxx'
        __guard cond != '1111'
        __unpredictable_unless 11 == '1'
        __unpredictable_unless 10 == '1'
        __unpredictable_unless 9 == '1'
        __unpredictable_unless 8 == '1'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

    __encoding aarch32_QSAX_T1_A
        __instruction_set T32
        __field Rn 16 +: 4
        __field Rd 8 +: 4
        __field Rm 0 +: 4
        __opcode '11111010 1110xxxx 1111xxxx 0001xxxx'
        __guard TRUE
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            sum  = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);
            diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);
            R[d]<15:0>  = SignedSat(sum, 16);
            R[d]<31:16> = SignedSat(diff, 16);

__instruction aarch32_RSB_r_A
    __encoding aarch32_RSB_r_A1_A
        __instruction_set A32
        __field cond 28 +: 4
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field Rd 12 +: 4
        __field imm5 7 +: 5
        __field type1 5 +: 2
        __field Rm 0 +: 4
        __opcode 'xxxx0000 011xxxxx xxxxxxxx xxx0xxxx'
        __guard cond != '1111'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm5);

    __encoding aarch32_RSB_r_T1_A
        __instruction_set T32
        __field S 20 +: 1
        __field Rn 16 +: 4
        __field imm3 12 +: 3
        __field Rd 8 +: 4
        __field imm2 6 +: 2
        __field type1 4 +: 2
        __field Rm 0 +: 4
        __opcode '11101011 110xxxxx xxxxxxxx xxxxxxxx'
        __guard TRUE
        __unpredictable_unless 15 == '0'
        __decode
            d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
            (shift_t, shift_n) = DecodeImmShift(type1, imm3:imm2);
            if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();
            shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
            (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, '1');
            if d == 15 then          // Can only occur for A32 encoding
                if setflags then
                    ALUExceptionReturn(result);
                else
                    ALUWritePC(result);
            else
                R[d] = result;
                if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

__instruction aarch32_VMLA_s_A
    __encoding aarch32_VMLA_s_T2A2_A
        __instruction_set A32
        __field U 24 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '1111001x 1xxxxxxx xxxx0110 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __encoding aarch32_VMLA_s_T2A2_A
        __instruction_set T32
        __field U 28 +: 1
        __field D 22 +: 1
        __field size 20 +: 2
        __field Vn 16 +: 4
        __field Vd 12 +: 4
        __field op 10 +: 1
        __field N 7 +: 1
        __field M 5 +: 1
        __field Vm 0 +: 4
        __opcode '111x1111 1xxxxxxx xxxx0110 x1x0xxxx'
        __guard TRUE
        __decode
            if size == '11' then SEE "Related encodings";
            if size == '00' || Vd<0> == '1' then UNDEFINED;
            unsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;
            d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
            if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm<2:0>);  index = UInt(M:Vm<3>);
            if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

    __execute
        if ConditionPassed() then
            EncodingSpecificOperations();  CheckAdvSIMDEnabled();
            op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
            for r = 0 to regs-1
                for e = 0 to elements-1
                    op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
                    if floating_point then
                        fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));
                        Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());
                    else
                        addend = if add then op1val*op2val else -op1val*op2val;
                        if long_destination then
                            Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
                        else
                            Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;

////////////////////////////////////////////////////////////////////////
// End
////////////////////////////////////////////////////////////////////////
